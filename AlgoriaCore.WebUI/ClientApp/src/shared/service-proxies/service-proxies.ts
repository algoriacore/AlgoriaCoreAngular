//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';
import 'moment-duration-format';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class MailServiceMailAttachServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    getMailServiceMailAttachPagedList(query: MailServiceMailAttachGetListQuery): Observable<PagedResultDtoOfMailServiceMailAttachListResponse> {
        let url_ = this.baseUrl + "/api/MailServiceMailAttach/GetMailServiceMailAttachPagedList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMailServiceMailAttachPagedList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMailServiceMailAttachPagedList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMailServiceMailAttachListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMailServiceMailAttachListResponse>;
        }));
    }

    protected processGetMailServiceMailAttachPagedList(response: HttpResponseBase): Observable<PagedResultDtoOfMailServiceMailAttachListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMailServiceMailAttachListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMailServiceMailAttachForEdit(dto: MailServiceMailAttachGetForEditQuery): Observable<MailServiceMailAttachForEditResponse> {
        let url_ = this.baseUrl + "/api/MailServiceMailAttach/GetMailServiceMailAttachForEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMailServiceMailAttachForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMailServiceMailAttachForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MailServiceMailAttachForEditResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MailServiceMailAttachForEditResponse>;
        }));
    }

    protected processGetMailServiceMailAttachForEdit(response: HttpResponseBase): Observable<MailServiceMailAttachForEditResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MailServiceMailAttachForEditResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMailServiceMailAttachFile(dto: MailServiceMailAttachGetFileQuery): Observable<MailServiceMailAttachForEditResponse> {
        let url_ = this.baseUrl + "/api/MailServiceMailAttach/GetMailServiceMailAttachFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMailServiceMailAttachFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMailServiceMailAttachFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MailServiceMailAttachForEditResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MailServiceMailAttachForEditResponse>;
        }));
    }

    protected processGetMailServiceMailAttachFile(response: HttpResponseBase): Observable<MailServiceMailAttachForEditResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MailServiceMailAttachForEditResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MailServiceMailConfigServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    getMailServiceMailConfigForEdit(dto: MailServiceMailConfigGetForEditQuery): Observable<MailServiceMailConfigForEditResponse> {
        let url_ = this.baseUrl + "/api/MailServiceMailConfig/GetMailServiceMailConfigForEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMailServiceMailConfigForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMailServiceMailConfigForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MailServiceMailConfigForEditResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MailServiceMailConfigForEditResponse>;
        }));
    }

    protected processGetMailServiceMailConfigForEdit(response: HttpResponseBase): Observable<MailServiceMailConfigForEditResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MailServiceMailConfigForEditResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MailServiceMailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    getMailServiceMailPagedList(query: MailServiceMailGetListQuery): Observable<PagedResultDtoOfMailServiceMailListResponse> {
        let url_ = this.baseUrl + "/api/MailServiceMail/GetMailServiceMailPagedList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMailServiceMailPagedList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMailServiceMailPagedList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMailServiceMailListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMailServiceMailListResponse>;
        }));
    }

    protected processGetMailServiceMailPagedList(response: HttpResponseBase): Observable<PagedResultDtoOfMailServiceMailListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMailServiceMailListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMailServiceMailForEdit(dto: MailServiceMailGetForEditQuery): Observable<MailServiceMailForEditResponse> {
        let url_ = this.baseUrl + "/api/MailServiceMail/GetMailServiceMailForEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMailServiceMailForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMailServiceMailForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MailServiceMailForEditResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MailServiceMailForEditResponse>;
        }));
    }

    protected processGetMailServiceMailForEdit(response: HttpResponseBase): Observable<MailServiceMailForEditResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MailServiceMailForEditResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SampleLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    createSampleLogTrace(dto: SampleLogTraceCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/SampleLog/CreateSampleLogTrace";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSampleLogTrace(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSampleLogTrace(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreateSampleLogTrace(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createSampleLogDebug(dto: SampleLogDebugCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/SampleLog/CreateSampleLogDebug";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSampleLogDebug(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSampleLogDebug(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreateSampleLogDebug(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createSampleLogInformation(dto: SampleLogInformationCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/SampleLog/CreateSampleLogInformation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSampleLogInformation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSampleLogInformation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreateSampleLogInformation(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createSampleLogWarning(dto: SampleLogWarningCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/SampleLog/CreateSampleLogWarning";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSampleLogWarning(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSampleLogWarning(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreateSampleLogWarning(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createSampleLogError(dto: SampleLogErrorCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/SampleLog/CreateSampleLogError";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSampleLogError(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSampleLogError(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreateSampleLogError(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createSampleLogCritical(dto: SampleLogCriticalCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/SampleLog/CreateSampleLogCritical";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSampleLogCritical(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSampleLogCritical(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreateSampleLogCritical(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    getAuditLogList(query: AuditLogGetListQuery): Observable<PagedResultDtoOfAuditLogListResponse> {
        let url_ = this.baseUrl + "/api/AuditLog/GetAuditLogList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfAuditLogListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfAuditLogListResponse>;
        }));
    }

    protected processGetAuditLogList(response: HttpResponseBase): Observable<PagedResultDtoOfAuditLogListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAuditLogListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAuditLogsToExcel(query: AuditLogGetExcelQuery): Observable<AuditLogExcelResponse> {
        let url_ = this.baseUrl + "/api/AuditLog/GetAuditLogsToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuditLogExcelResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuditLogExcelResponse>;
        }));
    }

    protected processGetAuditLogsToExcel(response: HttpResponseBase): Observable<AuditLogExcelResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuditLogExcelResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    login(query: UserLoginQuery): Observable<SessionLoginResponseController> {
        let url_ = this.baseUrl + "/api/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SessionLoginResponseController>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SessionLoginResponseController>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<SessionLoginResponseController> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SessionLoginResponseController.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    loginByToken(): Observable<SessionLoginResponseController> {
        let url_ = this.baseUrl + "/api/auth/loginbytoken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoginByToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoginByToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SessionLoginResponseController>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SessionLoginResponseController>;
        }));
    }

    protected processLoginByToken(response: HttpResponseBase): Observable<SessionLoginResponseController> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SessionLoginResponseController.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    impersonalizeTenant(query: UserImpersonalizeQuery): Observable<SessionLoginResponseController> {
        let url_ = this.baseUrl + "/api/auth/impersonalizetenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonalizeTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonalizeTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SessionLoginResponseController>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SessionLoginResponseController>;
        }));
    }

    protected processImpersonalizeTenant(response: HttpResponseBase): Observable<SessionLoginResponseController> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SessionLoginResponseController.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    impersonalizeUser(user: number | undefined): Observable<SessionLoginResponseController> {
        let url_ = this.baseUrl + "/api/auth/impersonalizeuser?";
        if (user === null)
            throw new Error("The parameter 'user' cannot be null.");
        else if (user !== undefined)
            url_ += "user=" + encodeURIComponent("" + user) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonalizeUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonalizeUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SessionLoginResponseController>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SessionLoginResponseController>;
        }));
    }

    protected processImpersonalizeUser(response: HttpResponseBase): Observable<SessionLoginResponseController> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SessionLoginResponseController.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    changePassword(dto: UserChangePasswordCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/auth/changep";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    resetPassword(dto: UserResetPasswordCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/auth/resetp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    confirmResetPassword(dto: ConfirmPasswordCommandReset): Observable<number> {
        let url_ = this.baseUrl + "/api/auth/confirmresetp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processConfirmResetPassword(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CatalogCustomServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    getCatalogCustomList(query: CatalogCustomGetListQuery): Observable<PagedResultDtoOfCatalogCustomForListResponse> {
        let url_ = this.baseUrl + "/api/CatalogCustom/GetCatalogCustomList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCatalogCustomList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCatalogCustomList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfCatalogCustomForListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfCatalogCustomForListResponse>;
        }));
    }

    protected processGetCatalogCustomList(response: HttpResponseBase): Observable<PagedResultDtoOfCatalogCustomForListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCatalogCustomForListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCatalogCustomCombo(query: CatalogCustomGetComboQuery): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/CatalogCustom/GetCatalogCustomCombo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCatalogCustomCombo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCatalogCustomCombo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboboxItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboboxItemDto[]>;
        }));
    }

    protected processGetCatalogCustomCombo(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboboxItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCatalogCustom(id: string | null): Observable<CatalogCustomResponse> {
        let url_ = this.baseUrl + "/api/CatalogCustom/GetCatalogCustom/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCatalogCustom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCatalogCustom(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CatalogCustomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CatalogCustomResponse>;
        }));
    }

    protected processGetCatalogCustom(response: HttpResponseBase): Observable<CatalogCustomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogCustomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCatalogCustomForEdit(dto: CatalogCustomGetForEditQuery): Observable<CatalogCustomForEditResponse> {
        let url_ = this.baseUrl + "/api/CatalogCustom/GetCatalogCustomForEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCatalogCustomForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCatalogCustomForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CatalogCustomForEditResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CatalogCustomForEditResponse>;
        }));
    }

    protected processGetCatalogCustomForEdit(response: HttpResponseBase): Observable<CatalogCustomForEditResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogCustomForEditResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createCatalogCustom(dto: CatalogCustomCreateCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/CatalogCustom/CreateCatalogCustom";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCatalogCustom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCatalogCustom(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreateCatalogCustom(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateCatalogCustom(dto: CatalogCustomUpdateCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/CatalogCustom/UpdateCatalogCustom";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCatalogCustom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCatalogCustom(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUpdateCatalogCustom(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteCatalogCustom(id: string | null): Observable<string> {
        let url_ = this.baseUrl + "/api/CatalogCustom/DeleteCatalogCustom/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCatalogCustom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCatalogCustom(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processDeleteCatalogCustom(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCatalogCustomFieldCombo(query: CatalogCustomFieldGetComboQuery): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/CatalogCustom/GetCatalogCustomFieldCombo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCatalogCustomFieldCombo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCatalogCustomFieldCombo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboboxItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboboxItemDto[]>;
        }));
    }

    protected processGetCatalogCustomFieldCombo(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboboxItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CatalogCustomImplServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    getCatalogCustomImplList(query: CatalogCustomImplGetListQuery): Observable<PagedResultDtoOfDictionaryOfStringAndObject> {
        let url_ = this.baseUrl + "/api/CatalogCustomImpl/GetCatalogCustomImplList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCatalogCustomImplList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCatalogCustomImplList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfDictionaryOfStringAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfDictionaryOfStringAndObject>;
        }));
    }

    protected processGetCatalogCustomImplList(response: HttpResponseBase): Observable<PagedResultDtoOfDictionaryOfStringAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDictionaryOfStringAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCatalogCustomImplCombo(query: CatalogCustomImplGetComboQuery): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/CatalogCustomImpl/GetCatalogCustomImplCombo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCatalogCustomImplCombo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCatalogCustomImplCombo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboboxItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboboxItemDto[]>;
        }));
    }

    protected processGetCatalogCustomImplCombo(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboboxItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProcess(query: CatalogCustomImplGetByIdQuery): Observable<CatalogCustomImplResponse> {
        let url_ = this.baseUrl + "/api/CatalogCustomImpl/GetProcess";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcess(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CatalogCustomImplResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CatalogCustomImplResponse>;
        }));
    }

    protected processGetProcess(response: HttpResponseBase): Observable<CatalogCustomImplResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogCustomImplResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCatalogCustomImplForRead(dto: CatalogCustomImplGetForReadQuery): Observable<CatalogCustomImplForReadResponse> {
        let url_ = this.baseUrl + "/api/CatalogCustomImpl/GetCatalogCustomImplForRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCatalogCustomImplForRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCatalogCustomImplForRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CatalogCustomImplForReadResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CatalogCustomImplForReadResponse>;
        }));
    }

    protected processGetCatalogCustomImplForRead(response: HttpResponseBase): Observable<CatalogCustomImplForReadResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogCustomImplForReadResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCatalogCustomImplForEdit(dto: CatalogCustomImplGetForEditQuery): Observable<CatalogCustomImplForEditResponse> {
        let url_ = this.baseUrl + "/api/CatalogCustomImpl/GetCatalogCustomImplForEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCatalogCustomImplForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCatalogCustomImplForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CatalogCustomImplForEditResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CatalogCustomImplForEditResponse>;
        }));
    }

    protected processGetCatalogCustomImplForEdit(response: HttpResponseBase): Observable<CatalogCustomImplForEditResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogCustomImplForEditResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createCatalogCustomImpl(dto: CatalogCustomImplCreateCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/CatalogCustomImpl/CreateCatalogCustomImpl";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCatalogCustomImpl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCatalogCustomImpl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreateCatalogCustomImpl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateCatalogCustomImpl(dto: CatalogCustomImplUpdateCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/CatalogCustomImpl/UpdateCatalogCustomImpl";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCatalogCustomImpl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCatalogCustomImpl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUpdateCatalogCustomImpl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteCatalogCustomImpl(dto: CatalogCustomImplDeleteCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/CatalogCustomImpl/DeleteCatalogCustomImpl";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCatalogCustomImpl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCatalogCustomImpl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processDeleteCatalogCustomImpl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ChangeLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    getChangeLogList(query: ChangeLogGetListQuery): Observable<PagedResultDtoOfChangeLogForListResponse> {
        let url_ = this.baseUrl + "/api/ChangeLog/GetChangeLogList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChangeLogList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChangeLogList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfChangeLogForListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfChangeLogForListResponse>;
        }));
    }

    protected processGetChangeLogList(response: HttpResponseBase): Observable<PagedResultDtoOfChangeLogForListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfChangeLogForListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ChatMessageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    getChatMessageList(query: ChatMessageGetListQuery): Observable<PagedResultDtoOfChatMessageListResponse> {
        let url_ = this.baseUrl + "/api/ChatMessage/GetChatMessageList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChatMessageList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChatMessageList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfChatMessageListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfChatMessageListResponse>;
        }));
    }

    protected processGetChatMessageList(response: HttpResponseBase): Observable<PagedResultDtoOfChatMessageListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfChatMessageListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    markAllUnreadMessagesOfUserAsRead(query: ChatMessageMarkReadCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ChatMessage/MarkAllUnreadMessagesOfUserAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAllUnreadMessagesOfUserAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAllUnreadMessagesOfUserAsRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processMarkAllUnreadMessagesOfUserAsRead(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ChatRoomServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    getChatRoomList(query: ChatRoomGetListQuery): Observable<PagedResultDtoOfChatRoomForListResponse> {
        let url_ = this.baseUrl + "/api/ChatRoom/GetChatRoomList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChatRoomList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChatRoomList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfChatRoomForListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfChatRoomForListResponse>;
        }));
    }

    protected processGetChatRoomList(response: HttpResponseBase): Observable<PagedResultDtoOfChatRoomForListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfChatRoomForListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getChatRoom(id: number): Observable<ChatRoomResponse> {
        let url_ = this.baseUrl + "/api/ChatRoom/GetChatRoom/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChatRoom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChatRoom(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatRoomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatRoomResponse>;
        }));
    }

    protected processGetChatRoom(response: HttpResponseBase): Observable<ChatRoomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatRoomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getChatRoomByChatRoomId(chatRoomId: string | null | undefined): Observable<ChatRoomResponse> {
        let url_ = this.baseUrl + "/api/ChatRoom/GetChatRoomByChatRoomId?";
        if (chatRoomId !== undefined && chatRoomId !== null)
            url_ += "chatRoomId=" + encodeURIComponent("" + chatRoomId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChatRoomByChatRoomId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChatRoomByChatRoomId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatRoomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatRoomResponse>;
        }));
    }

    protected processGetChatRoomByChatRoomId(response: HttpResponseBase): Observable<ChatRoomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatRoomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getChatRoomForEdit(dto: ChatRoomGetForEditQuery): Observable<ChatRoomForEditResponse> {
        let url_ = this.baseUrl + "/api/ChatRoom/GetChatRoomForEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChatRoomForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChatRoomForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatRoomForEditResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatRoomForEditResponse>;
        }));
    }

    protected processGetChatRoomForEdit(response: HttpResponseBase): Observable<ChatRoomForEditResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatRoomForEditResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrCreateChatRoom(dto: ChatRoomGetOrCreateCommand): Observable<ChatRoomResponse> {
        let url_ = this.baseUrl + "/api/ChatRoom/GetOrCreateChatRoom";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrCreateChatRoom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrCreateChatRoom(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatRoomResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatRoomResponse>;
        }));
    }

    protected processGetOrCreateChatRoom(response: HttpResponseBase): Observable<ChatRoomResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatRoomResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createChatRoom(dto: ChatRoomCreateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ChatRoom/CreateChatRoom";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateChatRoom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateChatRoom(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateChatRoom(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateChatRoom(dto: ChatRoomUpdateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ChatRoom/UpdateChatRoom";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateChatRoom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateChatRoom(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdateChatRoom(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getChatRoomChatList(query: ChatRoomChatGetListQuery): Observable<PagedResultDtoOfChatRoomChatForListResponse> {
        let url_ = this.baseUrl + "/api/ChatRoom/GetChatRoomChatList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChatRoomChatList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChatRoomChatList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfChatRoomChatForListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfChatRoomChatForListResponse>;
        }));
    }

    protected processGetChatRoomChatList(response: HttpResponseBase): Observable<PagedResultDtoOfChatRoomChatForListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfChatRoomChatForListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createChatRoomChat(dto: ChatRoomChatCreateCommand): Observable<ChatRoomChatResponse> {
        let url_ = this.baseUrl + "/api/ChatRoom/CreateChatRoomChat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateChatRoomChat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateChatRoomChat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatRoomChatResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatRoomChatResponse>;
        }));
    }

    protected processCreateChatRoomChat(response: HttpResponseBase): Observable<ChatRoomChatResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatRoomChatResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class FileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    getFile(uuid: string | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/File/GetFile?";
        if (uuid !== undefined && uuid !== null)
            url_ += "uuid=" + encodeURIComponent("" + uuid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetFile(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    downloadFileByUUID(uuid: string | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/File/DownloadFileByUUID?";
        if (uuid !== undefined && uuid !== null)
            url_ += "uuid=" + encodeURIComponent("" + uuid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFileByUUID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFileByUUID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processDownloadFileByUUID(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFileB64(uuid: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/File/GetFileB64?";
        if (uuid !== undefined && uuid !== null)
            url_ += "uuid=" + encodeURIComponent("" + uuid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFileB64(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFileB64(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetFileB64(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadTemp(file: FileParameter | null | undefined): Observable<FileUploadResponse> {
        let url_ = this.baseUrl + "/api/File/UploadTemp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadTemp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadTemp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileUploadResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileUploadResponse>;
        }));
    }

    protected processUploadTemp(response: HttpResponseBase): Observable<FileUploadResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileUploadResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFileTemp(tempFileName: string | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/File/GetFileTemp?";
        if (tempFileName !== undefined && tempFileName !== null)
            url_ += "tempFileName=" + encodeURIComponent("" + tempFileName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFileTemp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFileTemp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetFileTemp(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    downloadTempFile(fileName: string | null | undefined, fileType: string | null | undefined, fileToken: string | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/File/DownloadTempFile?";
        if (fileName !== undefined && fileName !== null)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (fileType !== undefined && fileType !== null)
            url_ += "fileType=" + encodeURIComponent("" + fileType) + "&";
        if (fileToken !== undefined && fileToken !== null)
            url_ += "fileToken=" + encodeURIComponent("" + fileToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadTempFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadTempFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processDownloadTempFile(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    downloadTempFilePDF(tempFileName: string | null | undefined, downloadName: string | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/File/DownloadTempFilePDF?";
        if (tempFileName !== undefined && tempFileName !== null)
            url_ += "tempFileName=" + encodeURIComponent("" + tempFileName) + "&";
        if (downloadName !== undefined && downloadName !== null)
            url_ += "downloadName=" + encodeURIComponent("" + downloadName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadTempFilePDF(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadTempFilePDF(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processDownloadTempFilePDF(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class FriendshipServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    getFriendshipList(query: FriendshipGetListQuery): Observable<PagedResultDtoOfFriendshipListResponse> {
        let url_ = this.baseUrl + "/api/Friendship/GetFriendshipList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFriendshipList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFriendshipList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfFriendshipListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfFriendshipListResponse>;
        }));
    }

    protected processGetFriendshipList(response: HttpResponseBase): Observable<PagedResultDtoOfFriendshipListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfFriendshipListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createFriendship(query: FriendshipCreateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Friendship/CreateFriendship";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendship(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendship(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateFriendship(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    blockFriendship(query: FriendshipBlockCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Friendship/BlockFriendship";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBlockFriendship(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBlockFriendship(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processBlockFriendship(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    unblockFriendship(query: FriendshipUnblockCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Friendship/UnblockFriendship";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnblockFriendship(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnblockFriendship(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUnblockFriendship(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class HelpServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    getHelpList(query: HelpGetListQuery): Observable<PagedResultDtoOfHelpForListResponse> {
        let url_ = this.baseUrl + "/api/Help/GetHelpList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHelpList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHelpList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfHelpForListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfHelpForListResponse>;
        }));
    }

    protected processGetHelpList(response: HttpResponseBase): Observable<PagedResultDtoOfHelpForListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfHelpForListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getHelp(id: number): Observable<HelpResponse> {
        let url_ = this.baseUrl + "/api/Help/GetHelp/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHelp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHelp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HelpResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HelpResponse>;
        }));
    }

    protected processGetHelp(response: HttpResponseBase): Observable<HelpResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HelpResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getHelpByKeyForCurrentUser(key: string | null): Observable<HelpResponse> {
        let url_ = this.baseUrl + "/api/Help/GetHelpByKeyForCurrentUser/{key}";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHelpByKeyForCurrentUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHelpByKeyForCurrentUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HelpResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HelpResponse>;
        }));
    }

    protected processGetHelpByKeyForCurrentUser(response: HttpResponseBase): Observable<HelpResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HelpResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getHelpForEdit(dto: HelpGetForEditQuery): Observable<HelpForEditResponse> {
        let url_ = this.baseUrl + "/api/Help/GetHelpForEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHelpForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHelpForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HelpForEditResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HelpForEditResponse>;
        }));
    }

    protected processGetHelpForEdit(response: HttpResponseBase): Observable<HelpForEditResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HelpForEditResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createHelp(dto: HelpCreateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Help/CreateHelp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateHelp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateHelp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateHelp(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateHelp(dto: HelpUpdateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Help/UpdateHelp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateHelp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateHelp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdateHelp(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteHelp(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/Help/DeleteHelp/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteHelp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteHelp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDeleteHelp(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class HostSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    getSettingsForEdit(dto: HostSettingsGetForEditQuery): Observable<HostSettingsForEditResponse> {
        let url_ = this.baseUrl + "/api/HostSettings/GetSettingsForEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSettingsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSettingsForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HostSettingsForEditResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HostSettingsForEditResponse>;
        }));
    }

    protected processGetSettingsForEdit(response: HttpResponseBase): Observable<HostSettingsForEditResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HostSettingsForEditResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateAllSettings(dto: HostSettingsUpdateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/HostSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sendTestEmail(dto: HostSettingsSendTestEmailCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/HostSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LanguageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    getLanguageList(query: LanguageGetListQuery): Observable<PagedResultDtoOfLanguageForListResponse> {
        let url_ = this.baseUrl + "/api/Language/GetLanguageList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfLanguageForListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfLanguageForListResponse>;
        }));
    }

    protected processGetLanguageList(response: HttpResponseBase): Observable<PagedResultDtoOfLanguageForListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLanguageForListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getLanguage(id: number): Observable<LanguageResponse> {
        let url_ = this.baseUrl + "/api/Language/GetLanguage/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LanguageResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LanguageResponse>;
        }));
    }

    protected processGetLanguage(response: HttpResponseBase): Observable<LanguageResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LanguageResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getLanguageForEdit(dto: LanguageGetForEditQuery): Observable<LanguageForEditResponse> {
        let url_ = this.baseUrl + "/api/Language/GetLanguageForEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LanguageForEditResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LanguageForEditResponse>;
        }));
    }

    protected processGetLanguageForEdit(response: HttpResponseBase): Observable<LanguageForEditResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LanguageForEditResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createLanguage(dto: LanguageCreateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Language/CreateLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateLanguage(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateLanguage(dto: LanguageUpdateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Language/UpdateLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdateLanguage(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteLanguage(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/Language/DeleteLanguage/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDeleteLanguage(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setLanguageDefault(language: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Language/SetLanguageDefault?";
        if (language === null)
            throw new Error("The parameter 'language' cannot be null.");
        else if (language !== undefined)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetLanguageDefault(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetLanguageDefault(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSetLanguageDefault(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getLanguageTextList(query: LanguageTextGetListQuery): Observable<PagedResultDtoOfLanguageTextForListResponse> {
        let url_ = this.baseUrl + "/api/Language/GetLanguageTextList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageTextList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageTextList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfLanguageTextForListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfLanguageTextForListResponse>;
        }));
    }

    protected processGetLanguageTextList(response: HttpResponseBase): Observable<PagedResultDtoOfLanguageTextForListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLanguageTextForListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getLanguageText(id: number): Observable<LanguageTextResponse> {
        let url_ = this.baseUrl + "/api/Language/GetLanguageText/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageText(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LanguageTextResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LanguageTextResponse>;
        }));
    }

    protected processGetLanguageText(response: HttpResponseBase): Observable<LanguageTextResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LanguageTextResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getLanguageTextForEdit(dto: LanguageTextGetForEditQuery): Observable<LanguageTextForEditResponse> {
        let url_ = this.baseUrl + "/api/Language/GetLanguageTextForEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageTextForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageTextForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LanguageTextForEditResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LanguageTextForEditResponse>;
        }));
    }

    protected processGetLanguageTextForEdit(response: HttpResponseBase): Observable<LanguageTextForEditResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LanguageTextForEditResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateLanguageText(dto: LanguageTextUpdateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Language/UpdateLanguageText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLanguageText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLanguageText(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdateLanguageText(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MailGroupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    getMailGroupList(query: MailGroupGetListQuery): Observable<PagedResultDtoOfMailGroupListResponse> {
        let url_ = this.baseUrl + "/api/MailGroup/GetMailGroupList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMailGroupList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMailGroupList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMailGroupListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMailGroupListResponse>;
        }));
    }

    protected processGetMailGroupList(response: HttpResponseBase): Observable<PagedResultDtoOfMailGroupListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMailGroupListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createMailGroup(dto: MailGroupCreateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/MailGroup/CreateMailGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMailGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMailGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateMailGroup(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateMailGroup(dto: MailGroupUpdateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/MailGroup/UpdateMailGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMailGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMailGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdateMailGroup(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMailGroupForEdit(dto: MailGroupGetForEditQuery): Observable<MailGroupForEditResponse> {
        let url_ = this.baseUrl + "/api/MailGroup/GetMailGroupForEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMailGroupForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMailGroupForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MailGroupForEditResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MailGroupForEditResponse>;
        }));
    }

    protected processGetMailGroupForEdit(response: HttpResponseBase): Observable<MailGroupForEditResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MailGroupForEditResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    copyMailGroup(dto: MailGroupCopyCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/MailGroup/CopyMailGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCopyMailGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCopyMailGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCopyMailGroup(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkMailGroup(dto: MailGroupCheckCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/MailGroup/CheckMailGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckMailGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckMailGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCheckMailGroup(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    unCheckMailGroup(dto: MailGroupUnCheckCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/MailGroup/UnCheckMailGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnCheckMailGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnCheckMailGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUnCheckMailGroup(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMailTemplateList(query: MailTemplateGetListQuery): Observable<PagedResultDtoOfMailTemplateListResponse> {
        let url_ = this.baseUrl + "/api/MailGroup/GetMailTemplateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMailTemplateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMailTemplateList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMailTemplateListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMailTemplateListResponse>;
        }));
    }

    protected processGetMailTemplateList(response: HttpResponseBase): Observable<PagedResultDtoOfMailTemplateListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMailTemplateListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createMailTemplate(dto: MailTemplateCreateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/MailGroup/CreateMailTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMailTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMailTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateMailTemplate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateMailTemplate(dto: MailTemplateUpdateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/MailGroup/UpdateMailTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMailTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMailTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdateMailTemplate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMailTemplateForEdit(dto: MailTemplateGetForEditQuery): Observable<MailTemplateForEditResponse> {
        let url_ = this.baseUrl + "/api/MailGroup/GetMailTemplateForEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMailTemplateForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMailTemplateForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MailTemplateForEditResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MailTemplateForEditResponse>;
        }));
    }

    protected processGetMailTemplateForEdit(response: HttpResponseBase): Observable<MailTemplateForEditResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MailTemplateForEditResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sendTestEmail(dto: MailTemplateSendTestCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/MailGroup/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMailTemplateGetBodyParamList(query: MailTemplateGetBodyParamListQuery): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/MailGroup/GetMailTemplateGetBodyParamList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMailTemplateGetBodyParamList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMailTemplateGetBodyParamList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboboxItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboboxItemDto[]>;
        }));
    }

    protected processGetMailTemplateGetBodyParamList(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboboxItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMailTemplateGetMailKeyAvailableList(query: MailTemplateGetMailKeyAvailableListQuery): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/MailGroup/GetMailTemplateGetMailKeyAvailableList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMailTemplateGetMailKeyAvailableList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMailTemplateGetMailKeyAvailableList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboboxItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboboxItemDto[]>;
        }));
    }

    protected processGetMailTemplateGetMailKeyAvailableList(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboboxItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OrgUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    getOrgUnitList(query: OrgUnitGetListQuery): Observable<PagedResultDtoOfOrgUnitForListResponse> {
        let url_ = this.baseUrl + "/api/OrgUnit/GetOrgUnitList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrgUnitList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrgUnitList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfOrgUnitForListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfOrgUnitForListResponse>;
        }));
    }

    protected processGetOrgUnitList(response: HttpResponseBase): Observable<PagedResultDtoOfOrgUnitForListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOrgUnitForListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrgUnitByParentOUList(parentOU: number | undefined): Observable<OrgUnitForListResponse[]> {
        let url_ = this.baseUrl + "/api/OrgUnit/GetOrgUnitByParentOUList?";
        if (parentOU === null)
            throw new Error("The parameter 'parentOU' cannot be null.");
        else if (parentOU !== undefined)
            url_ += "parentOU=" + encodeURIComponent("" + parentOU) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrgUnitByParentOUList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrgUnitByParentOUList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrgUnitForListResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrgUnitForListResponse[]>;
        }));
    }

    protected processGetOrgUnitByParentOUList(response: HttpResponseBase): Observable<OrgUnitForListResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrgUnitForListResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrgUnit(id: number): Observable<OrgUnitResponse> {
        let url_ = this.baseUrl + "/api/OrgUnit/GetOrgUnit/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrgUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrgUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrgUnitResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrgUnitResponse>;
        }));
    }

    protected processGetOrgUnit(response: HttpResponseBase): Observable<OrgUnitResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrgUnitResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrgUnitCombo(query: OrgUnitGetComboQuery): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/OrgUnit/GetOrgUnitCombo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrgUnitCombo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrgUnitCombo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboboxItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboboxItemDto[]>;
        }));
    }

    protected processGetOrgUnitCombo(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboboxItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrgUnitForEdit(dto: OrgUnitGetForEditQuery): Observable<OrgUnitForEditResponse> {
        let url_ = this.baseUrl + "/api/OrgUnit/GetOrgUnitForEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrgUnitForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrgUnitForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrgUnitForEditResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrgUnitForEditResponse>;
        }));
    }

    protected processGetOrgUnitForEdit(response: HttpResponseBase): Observable<OrgUnitForEditResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrgUnitForEditResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createOrgUnit(dto: OrgUnitCreateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/OrgUnit/CreateOrgUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrgUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrgUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateOrgUnit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateOrgUnit(dto: OrgUnitUpdateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/OrgUnit/UpdateOrgUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrgUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrgUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdateOrgUnit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteOrgUnit(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/OrgUnit/DeleteOrgUnit/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrgUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrgUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDeleteOrgUnit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrgUnitUserList(query: OrgUnitUserGetListQuery): Observable<PagedResultDtoOfOrgUnitUserForListResponse> {
        let url_ = this.baseUrl + "/api/OrgUnit/GetOrgUnitUserList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrgUnitUserList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrgUnitUserList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfOrgUnitUserForListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfOrgUnitUserForListResponse>;
        }));
    }

    protected processGetOrgUnitUserList(response: HttpResponseBase): Observable<PagedResultDtoOfOrgUnitUserForListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOrgUnitUserForListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createOrgUnitUser(dto: OrgUnitUserCreateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/OrgUnit/CreateOrgUnitUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrgUnitUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrgUnitUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateOrgUnitUser(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteOrgUnitUser(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/OrgUnit/DeleteOrgUnitUser/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrgUnitUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrgUnitUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDeleteOrgUnitUser(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    getPermissionsTree(): Observable<Permission> {
        let url_ = this.baseUrl + "/api/Permission/GetPermissionsTree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPermissionsTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionsTree(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Permission>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Permission>;
        }));
    }

    protected processGetPermissionsTree(response: HttpResponseBase): Observable<Permission> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Permission.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProcessServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    getProcessList(query: ProcessGetListQuery): Observable<PagedResultDtoOfDictionaryOfStringAndObject> {
        let url_ = this.baseUrl + "/api/Process/GetProcessList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfDictionaryOfStringAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfDictionaryOfStringAndObject>;
        }));
    }

    protected processGetProcessList(response: HttpResponseBase): Observable<PagedResultDtoOfDictionaryOfStringAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDictionaryOfStringAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProcessCombo(query: ProcessGetComboQuery): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/Process/GetProcessCombo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessCombo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessCombo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboboxItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboboxItemDto[]>;
        }));
    }

    protected processGetProcessCombo(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboboxItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProcess(query: ProcessGetByIdQuery): Observable<ProcessResponse> {
        let url_ = this.baseUrl + "/api/Process/GetProcess";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcess(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessResponse>;
        }));
    }

    protected processGetProcess(response: HttpResponseBase): Observable<ProcessResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProcessForRead(dto: ProcessGetForReadQuery): Observable<ProcessForReadResponse> {
        let url_ = this.baseUrl + "/api/Process/GetProcessForRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessForRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessForRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessForReadResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessForReadResponse>;
        }));
    }

    protected processGetProcessForRead(response: HttpResponseBase): Observable<ProcessForReadResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessForReadResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProcessForEdit(dto: ProcessGetForEditQuery): Observable<ProcessForEditResponse> {
        let url_ = this.baseUrl + "/api/Process/GetProcessForEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessForEditResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessForEditResponse>;
        }));
    }

    protected processGetProcessForEdit(response: HttpResponseBase): Observable<ProcessForEditResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessForEditResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createProcess(dto: ProcessCreateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Process/CreateProcess";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProcess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProcess(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateProcess(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateProcess(dto: ProcessUpdateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Process/UpdateProcess";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProcess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProcess(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdateProcess(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteProcess(dto: ProcessDeleteCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Process/DeleteProcess";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProcess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProcess(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDeleteProcess(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getToDoTimeSheet(id: number): Observable<ToDoTimeSheetResponse> {
        let url_ = this.baseUrl + "/api/Process/GetToDoTimeSheet/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToDoTimeSheet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToDoTimeSheet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ToDoTimeSheetResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ToDoTimeSheetResponse>;
        }));
    }

    protected processGetToDoTimeSheet(response: HttpResponseBase): Observable<ToDoTimeSheetResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ToDoTimeSheetResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getToDoTimeSheetForEdit(dto: ToDoTimeSheetGetForEditQuery): Observable<ToDoTimeSheetForEditResponse> {
        let url_ = this.baseUrl + "/api/Process/GetToDoTimeSheetForEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToDoTimeSheetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToDoTimeSheetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ToDoTimeSheetForEditResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ToDoTimeSheetForEditResponse>;
        }));
    }

    protected processGetToDoTimeSheetForEdit(response: HttpResponseBase): Observable<ToDoTimeSheetForEditResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ToDoTimeSheetForEditResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createToDoTimeSheet(dto: ToDoTimeSheetCreateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Process/CreateToDoTimeSheet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateToDoTimeSheet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateToDoTimeSheet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateToDoTimeSheet(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateToDoTimeSheet(dto: ToDoTimeSheetUpdateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Process/UpdateToDoTimeSheet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateToDoTimeSheet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateToDoTimeSheet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdateToDoTimeSheet(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteToDoTimeSheet(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/Process/DeleteToDoTimeSheet/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteToDoTimeSheet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteToDoTimeSheet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDeleteToDoTimeSheet(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProcessSecurityMemberList(query: ProcessSecurityMemberGetListQuery): Observable<PagedResultDtoOfProcessSecurityMemberForListResponse> {
        let url_ = this.baseUrl + "/api/Process/GetProcessSecurityMemberList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessSecurityMemberList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessSecurityMemberList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfProcessSecurityMemberForListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfProcessSecurityMemberForListResponse>;
        }));
    }

    protected processGetProcessSecurityMemberList(response: HttpResponseBase): Observable<PagedResultDtoOfProcessSecurityMemberForListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProcessSecurityMemberForListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createProcessSecurityMember(dto: ProcessSecurityMemberCreateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Process/CreateProcessSecurityMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProcessSecurityMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProcessSecurityMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateProcessSecurityMember(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteProcessSecurityMember(dto: ProcessSecurityMemberDeleteCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Process/DeleteProcessSecurityMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProcessSecurityMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProcessSecurityMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDeleteProcessSecurityMember(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class QuestionnaireServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    getQuestionnaireList(query: QuestionnaireGetListQuery): Observable<PagedResultDtoOfQuestionnaireForListResponse> {
        let url_ = this.baseUrl + "/api/Questionnaire/GetQuestionnaireList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuestionnaireList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuestionnaireList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfQuestionnaireForListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfQuestionnaireForListResponse>;
        }));
    }

    protected processGetQuestionnaireList(response: HttpResponseBase): Observable<PagedResultDtoOfQuestionnaireForListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfQuestionnaireForListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getQuestionnaireCombo(query: QuestionnaireGetComboQuery): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/Questionnaire/GetQuestionnaireCombo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuestionnaireCombo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuestionnaireCombo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboboxItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboboxItemDto[]>;
        }));
    }

    protected processGetQuestionnaireCombo(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboboxItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getQuestionnaire(id: string | null): Observable<QuestionnaireResponse> {
        let url_ = this.baseUrl + "/api/Questionnaire/GetQuestionnaire/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuestionnaire(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuestionnaire(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QuestionnaireResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QuestionnaireResponse>;
        }));
    }

    protected processGetQuestionnaire(response: HttpResponseBase): Observable<QuestionnaireResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuestionnaireResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createQuestionnaire(dto: QuestionnaireCreateCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Questionnaire/CreateQuestionnaire";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateQuestionnaire(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateQuestionnaire(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreateQuestionnaire(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateQuestionnaire(dto: QuestionnaireUpdateCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Questionnaire/UpdateQuestionnaire";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateQuestionnaire(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateQuestionnaire(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUpdateQuestionnaire(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteQuestionnaire(id: string | null): Observable<string> {
        let url_ = this.baseUrl + "/api/Questionnaire/DeleteQuestionnaire/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteQuestionnaire(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteQuestionnaire(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processDeleteQuestionnaire(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getQuestionnaireFieldCombo(query: QuestionnaireFieldGetComboQuery): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/Questionnaire/GetQuestionnaireFieldCombo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuestionnaireFieldCombo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuestionnaireFieldCombo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboboxItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboboxItemDto[]>;
        }));
    }

    protected processGetQuestionnaireFieldCombo(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboboxItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RegisterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    create(dto: TenantCreateRegistrationCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/register/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    confirm(dto: TenantConfirmRegistrationCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/register/confirm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processConfirm(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RolServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    getRolList(query: RolGetListQuery): Observable<PagedResultDtoOfRolForListResponse> {
        let url_ = this.baseUrl + "/api/Rol/GetRolList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRolList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRolList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfRolForListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfRolForListResponse>;
        }));
    }

    protected processGetRolList(response: HttpResponseBase): Observable<PagedResultDtoOfRolForListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfRolForListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(dto: RolGetByIdQuery): Observable<RolResponse> {
        let url_ = this.baseUrl + "/api/Rol/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RolResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RolResponse>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RolResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RolResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createRol(dto: RolCreateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Rol/CreateRol";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRol(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRol(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateRol(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateRol(dto: RolUpdateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Rol/UpdateRol";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRol(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRol(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdateRol(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRol(dto: RolDeleteCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Rol/DeleteRol";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRol(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRol(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDeleteRol(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRolForEdit(dto: RolGetForEditQuery): Observable<RolForEditReponse> {
        let url_ = this.baseUrl + "/api/Rol/GetRolForEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRolForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRolForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RolForEditReponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RolForEditReponse>;
        }));
    }

    protected processGetRolForEdit(response: HttpResponseBase): Observable<RolForEditReponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RolForEditReponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRolListActive(query: RolGetForListActiveQuery): Observable<RolForListActiveResponse[]> {
        let url_ = this.baseUrl + "/api/Rol/GetRolListActive";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRolListActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRolListActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RolForListActiveResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RolForListActiveResponse[]>;
        }));
    }

    protected processGetRolListActive(response: HttpResponseBase): Observable<RolForListActiveResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RolForListActiveResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SampleDataServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    weatherForecasts(id: string | null): Observable<WeatherForecast[]> {
        let url_ = this.baseUrl + "/api/SampleData/WeatherForecasts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherForecasts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherForecasts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherForecast[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherForecast[]>;
        }));
    }

    protected processWeatherForecasts(response: HttpResponseBase): Observable<WeatherForecast[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SampleDateDataServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    getSampleDateDataList(query: SampleDateDataGetListQuery): Observable<PagedResultDtoOfSampleDateDataForListResponse> {
        let url_ = this.baseUrl + "/api/SampleDateData/GetSampleDateDataList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSampleDateDataList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSampleDateDataList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfSampleDateDataForListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfSampleDateDataForListResponse>;
        }));
    }

    protected processGetSampleDateDataList(response: HttpResponseBase): Observable<PagedResultDtoOfSampleDateDataForListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSampleDateDataForListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSampleDateData(id: number): Observable<SampleDateDataResponse> {
        let url_ = this.baseUrl + "/api/SampleDateData/GetSampleDateData/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSampleDateData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSampleDateData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SampleDateDataResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SampleDateDataResponse>;
        }));
    }

    protected processGetSampleDateData(response: HttpResponseBase): Observable<SampleDateDataResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SampleDateDataResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSampleDateDataForEdit(dto: SampleDateDataGetForEditQuery): Observable<SampleDateDataForEditResponse> {
        let url_ = this.baseUrl + "/api/SampleDateData/GetSampleDateDataForEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSampleDateDataForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSampleDateDataForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SampleDateDataForEditResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SampleDateDataForEditResponse>;
        }));
    }

    protected processGetSampleDateDataForEdit(response: HttpResponseBase): Observable<SampleDateDataForEditResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SampleDateDataForEditResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createSampleDateData(dto: SampleDateDataCreateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/SampleDateData/CreateSampleDateData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSampleDateData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSampleDateData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateSampleDateData(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateSampleDateData(dto: SampleDateDataUpdateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/SampleDateData/UpdateSampleDateData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSampleDateData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSampleDateData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdateSampleDateData(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteSampleDateData(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/SampleDateData/DeleteSampleDateData/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSampleDateData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSampleDateData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDeleteSampleDateData(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    convertSampleDateData(dto: SampleDateDataConvertCommand): Observable<moment.Moment> {
        let url_ = this.baseUrl + "/api/SampleDateData/ConvertSampleDateData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConvertSampleDateData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConvertSampleDateData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<moment.Moment>;
                }
            } else
                return _observableThrow(response_) as any as Observable<moment.Moment>;
        }));
    }

    protected processConvertSampleDateData(response: HttpResponseBase): Observable<moment.Moment> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? moment(resultData200.toString()) : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SettingClientServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    changeSettingClient(dto: SettingClientChangeCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/SettingClient/ChangeSettingClient";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeSettingClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeSettingClient(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processChangeSettingClient(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TemplatesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    getTemplateNoPagedList(): Observable<TemplateForListResponse[]> {
        let url_ = this.baseUrl + "/api/Templates/GetTemplateNoPagedList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateNoPagedList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateNoPagedList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateForListResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateForListResponse[]>;
        }));
    }

    protected processGetTemplateNoPagedList(response: HttpResponseBase): Observable<TemplateForListResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TemplateForListResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTemplate(id: number): Observable<TemplateResponse> {
        let url_ = this.baseUrl + "/api/Templates/GetTemplate/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateResponse>;
        }));
    }

    protected processGetTemplate(response: HttpResponseBase): Observable<TemplateResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTemplateForEdit(dto: TemplateGetForEditQuery): Observable<TemplateForEditResponse> {
        let url_ = this.baseUrl + "/api/Templates/GetTemplateForEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateForEditResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateForEditResponse>;
        }));
    }

    protected processGetTemplateForEdit(response: HttpResponseBase): Observable<TemplateForEditResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateForEditResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createTemplate(dto: TemplateCreateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Templates/CreateTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateTemplate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateTemplate(dto: TemplateUpdateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Templates/UpdateTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdateTemplate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteTemplate(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/Templates/DeleteTemplate/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDeleteTemplate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    generateDbTable(id: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Templates/GenerateDbTable?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateDbTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateDbTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGenerateDbTable(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTemplateSectionList(query: TemplateSectionGetListQuery): Observable<PagedResultDtoOfTemplateSectionForListResponse> {
        let url_ = this.baseUrl + "/api/Templates/GetTemplateSectionList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateSectionList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateSectionList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTemplateSectionForListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTemplateSectionForListResponse>;
        }));
    }

    protected processGetTemplateSectionList(response: HttpResponseBase): Observable<PagedResultDtoOfTemplateSectionForListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTemplateSectionForListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTemplateSection(id: number): Observable<TemplateSectionResponse> {
        let url_ = this.baseUrl + "/api/Templates/GetTemplateSection/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateSection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateSection(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateSectionResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateSectionResponse>;
        }));
    }

    protected processGetTemplateSection(response: HttpResponseBase): Observable<TemplateSectionResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateSectionResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTemplateSectionForEdit(dto: TemplateSectionGetForEditQuery): Observable<TemplateSectionForEditResponse> {
        let url_ = this.baseUrl + "/api/Templates/GetTemplateSectionForEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateSectionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateSectionForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateSectionForEditResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateSectionForEditResponse>;
        }));
    }

    protected processGetTemplateSectionForEdit(response: HttpResponseBase): Observable<TemplateSectionForEditResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateSectionForEditResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createTemplateSection(dto: TemplateSectionCreateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Templates/CreateTemplateSection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTemplateSection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTemplateSection(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateTemplateSection(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateTemplateSection(dto: TemplateSectionUpdateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Templates/UpdateTemplateSection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTemplateSection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTemplateSection(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdateTemplateSection(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteTemplateSection(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/Templates/DeleteTemplateSection/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTemplateSection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTemplateSection(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDeleteTemplateSection(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTemplateFieldList(query: TemplateFieldGetListQuery): Observable<PagedResultDtoOfTemplateFieldForListResponse> {
        let url_ = this.baseUrl + "/api/Templates/GetTemplateFieldList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateFieldList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateFieldList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTemplateFieldForListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTemplateFieldForListResponse>;
        }));
    }

    protected processGetTemplateFieldList(response: HttpResponseBase): Observable<PagedResultDtoOfTemplateFieldForListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTemplateFieldForListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTemplateFieldListByTemplate(query: TemplateFieldGetListByTemplateQuery): Observable<TemplateFieldResponse[]> {
        let url_ = this.baseUrl + "/api/Templates/GetTemplateFieldListByTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateFieldListByTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateFieldListByTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateFieldResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateFieldResponse[]>;
        }));
    }

    protected processGetTemplateFieldListByTemplate(response: HttpResponseBase): Observable<TemplateFieldResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TemplateFieldResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTemplateFieldCombo(query: TemplateFieldGetComboQuery): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/Templates/GetTemplateFieldCombo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateFieldCombo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateFieldCombo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboboxItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboboxItemDto[]>;
        }));
    }

    protected processGetTemplateFieldCombo(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboboxItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTemplateField(id: number): Observable<TemplateFieldResponse> {
        let url_ = this.baseUrl + "/api/Templates/GetTemplateField/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateField(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateField(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateFieldResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateFieldResponse>;
        }));
    }

    protected processGetTemplateField(response: HttpResponseBase): Observable<TemplateFieldResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateFieldResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTemplateFieldForEdit(dto: TemplateFieldGetForEditQuery): Observable<TemplateFieldForEditResponse> {
        let url_ = this.baseUrl + "/api/Templates/GetTemplateFieldForEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateFieldForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateFieldForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateFieldForEditResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateFieldForEditResponse>;
        }));
    }

    protected processGetTemplateFieldForEdit(response: HttpResponseBase): Observable<TemplateFieldForEditResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateFieldForEditResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createTemplateField(dto: TemplateFieldCreateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Templates/CreateTemplateField";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTemplateField(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTemplateField(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateTemplateField(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateTemplateField(dto: TemplateFieldUpdateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Templates/UpdateTemplateField";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTemplateField(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTemplateField(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdateTemplateField(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteTemplateField(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/Templates/DeleteTemplateField/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTemplateField(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTemplateField(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDeleteTemplateField(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTemplateFieldNextOrderByTemplateSection(templateSection: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Templates/GetTemplateFieldNextOrderByTemplateSection?";
        if (templateSection === null)
            throw new Error("The parameter 'templateSection' cannot be null.");
        else if (templateSection !== undefined)
            url_ += "templateSection=" + encodeURIComponent("" + templateSection) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateFieldNextOrderByTemplateSection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateFieldNextOrderByTemplateSection(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetTemplateFieldNextOrderByTemplateSection(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTemplateToDoStatusList(query: TemplateToDoStatusGetListQuery): Observable<PagedResultDtoOfTemplateToDoStatusForListResponse> {
        let url_ = this.baseUrl + "/api/Templates/GetTemplateToDoStatusList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateToDoStatusList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateToDoStatusList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTemplateToDoStatusForListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTemplateToDoStatusForListResponse>;
        }));
    }

    protected processGetTemplateToDoStatusList(response: HttpResponseBase): Observable<PagedResultDtoOfTemplateToDoStatusForListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTemplateToDoStatusForListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTemplateToDoStatus(id: number): Observable<TemplateToDoStatusResponse> {
        let url_ = this.baseUrl + "/api/Templates/GetTemplateToDoStatus/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateToDoStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateToDoStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateToDoStatusResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateToDoStatusResponse>;
        }));
    }

    protected processGetTemplateToDoStatus(response: HttpResponseBase): Observable<TemplateToDoStatusResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateToDoStatusResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTemplateToDoStatusForEdit(dto: TemplateToDoStatusGetForEditQuery): Observable<TemplateToDoStatusForEditResponse> {
        let url_ = this.baseUrl + "/api/Templates/GetTemplateToDoStatusForEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateToDoStatusForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateToDoStatusForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateToDoStatusForEditResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateToDoStatusForEditResponse>;
        }));
    }

    protected processGetTemplateToDoStatusForEdit(response: HttpResponseBase): Observable<TemplateToDoStatusForEditResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateToDoStatusForEditResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createTemplateToDoStatus(dto: TemplateToDoStatusCreateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Templates/CreateTemplateToDoStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTemplateToDoStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTemplateToDoStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateTemplateToDoStatus(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateTemplateToDoStatus(dto: TemplateToDoStatusUpdateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Templates/UpdateTemplateToDoStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTemplateToDoStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTemplateToDoStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdateTemplateToDoStatus(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteTemplateToDoStatus(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/Templates/DeleteTemplateToDoStatus/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTemplateToDoStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTemplateToDoStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDeleteTemplateToDoStatus(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTemplateSecurityMemberList(query: TemplateSecurityMemberGetListQuery): Observable<PagedResultDtoOfTemplateSecurityMemberForListResponse> {
        let url_ = this.baseUrl + "/api/Templates/GetTemplateSecurityMemberList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateSecurityMemberList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateSecurityMemberList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTemplateSecurityMemberForListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTemplateSecurityMemberForListResponse>;
        }));
    }

    protected processGetTemplateSecurityMemberList(response: HttpResponseBase): Observable<PagedResultDtoOfTemplateSecurityMemberForListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTemplateSecurityMemberForListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createTemplateSecurityMember(dto: TemplateSecurityMemberCreateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Templates/CreateTemplateSecurityMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTemplateSecurityMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTemplateSecurityMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateTemplateSecurityMember(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteTemplateSecurityMember(dto: TemplateSecurityMemberDeleteCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Templates/DeleteTemplateSecurityMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTemplateSecurityMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTemplateSecurityMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDeleteTemplateSecurityMember(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    getTenantById(id: number): Observable<TenantResponse> {
        let url_ = this.baseUrl + "/api/Tenant/GetTenantById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantResponse>;
        }));
    }

    protected processGetTenantById(response: HttpResponseBase): Observable<TenantResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createTenant(command: TenantCreateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Tenant/CreateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateTenant(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateTenant(command: UpdateTenantCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Tenant/UpdateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdateTenant(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTenantsList(query: TenantGetListQuery): Observable<PagedResultDtoOfTenantListResponse> {
        let url_ = this.baseUrl + "/api/Tenant/GetTenantsList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantsList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTenantListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTenantListResponse>;
        }));
    }

    protected processGetTenantsList(response: HttpResponseBase): Observable<PagedResultDtoOfTenantListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTenantListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTenantsListCompleter(query: TenantGetListCompleterQuery): Observable<TenantListResponse[]> {
        let url_ = this.baseUrl + "/api/Tenant/GetTenantsListCompleter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantsListCompleter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantsListCompleter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantListResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantListResponse[]>;
        }));
    }

    protected processGetTenantsListCompleter(response: HttpResponseBase): Observable<TenantListResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TenantListResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteTenant(dto: TenantDeleteCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Tenant/DeleteTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDeleteTenant(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    getSettingsForEdit(dto: TenantSettingsGetForEditQuery): Observable<TenantSettingsForEditResponse> {
        let url_ = this.baseUrl + "/api/TenantSettings/GetSettingsForEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSettingsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSettingsForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantSettingsForEditResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantSettingsForEditResponse>;
        }));
    }

    protected processGetSettingsForEdit(response: HttpResponseBase): Observable<TenantSettingsForEditResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantSettingsForEditResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateAllSettings(dto: TenantSettingsUpdateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/TenantSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sendTestEmail(dto: TenantSettingsSendTestEmailCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/TenantSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    getAll(dto: UserConfigurationGetAllQuery): Observable<UserConfigurationResponse> {
        let url_ = this.baseUrl + "/api/UserConfiguration/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserConfigurationResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserConfigurationResponse>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserConfigurationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserConfigurationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    getUserList(query: UserGetListQuery): Observable<PagedResultDtoOfUserListResponse> {
        let url_ = this.baseUrl + "/api/User/GetUserList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfUserListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfUserListResponse>;
        }));
    }

    protected processGetUserList(response: HttpResponseBase): Observable<PagedResultDtoOfUserListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserAutocompleteList(term: string | null | undefined): Observable<UserListResponse[]> {
        let url_ = this.baseUrl + "/api/User/GetUserAutocompleteList?";
        if (term !== undefined && term !== null)
            url_ += "term=" + encodeURIComponent("" + term) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserAutocompleteList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserAutocompleteList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserListResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserListResponse[]>;
        }));
    }

    protected processGetUserAutocompleteList(response: HttpResponseBase): Observable<UserListResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserListResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserForEditorAutocompleteList(term: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/User/GetUserForEditorAutocompleteList?";
        if (term !== undefined && term !== null)
            url_ += "term=" + encodeURIComponent("" + term) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserForEditorAutocompleteList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserForEditorAutocompleteList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any[]>;
        }));
    }

    protected processGetUserForEditorAutocompleteList(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createUser(dto: UserCreateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/User/CreateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateUser(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateUser(dto: UserUpdateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/User/UpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserForEdit(dto: UserGetForEditQuery): Observable<UserForEditResponse> {
        let url_ = this.baseUrl + "/api/User/GetUserForEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserForEditResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserForEditResponse>;
        }));
    }

    protected processGetUserForEdit(response: HttpResponseBase): Observable<UserForEditResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserForEditResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserProfile(dto: UserProfileQuery): Observable<UserForEditResponse> {
        let url_ = this.baseUrl + "/api/User/GetUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserForEditResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserForEditResponse>;
        }));
    }

    protected processGetUserProfile(response: HttpResponseBase): Observable<UserForEditResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserForEditResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateUserProfile(dto: UserUpdateProfileCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/User/UpdateUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdateUserProfile(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPictureProfile(id: number | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/User/GetPictureProfile?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPictureProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPictureProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetPictureProfile(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteUser(dto: UserDeleteCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/User/DeleteUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    lockUser(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/User/LockUser/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLockUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processLockUser(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    unlockUser(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/User/UnlockUser/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUnlockUser(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class WebLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:60900";
    }

    getLatestWebLogs(query: WebLogGetLastestQuery): Observable<WebLogGetLastestResponse> {
        let url_ = this.baseUrl + "/api/WebLog/GetLatestWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestWebLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WebLogGetLastestResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WebLogGetLastestResponse>;
        }));
    }

    protected processGetLatestWebLogs(response: HttpResponseBase): Observable<WebLogGetLastestResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WebLogGetLastestResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    downloadWebLogs(query: WebLogDownloadZipQuery): Observable<WebLogDownloadZipResponse> {
        let url_ = this.baseUrl + "/api/WebLog/DownloadWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWebLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WebLogDownloadZipResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WebLogDownloadZipResponse>;
        }));
    }

    protected processDownloadWebLogs(response: HttpResponseBase): Observable<WebLogDownloadZipResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WebLogDownloadZipResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class PagedResultDtoOfMailServiceMailAttachListResponse implements IPagedResultDtoOfMailServiceMailAttachListResponse {
    totalCount!: number;
    items?: MailServiceMailAttachListResponse[] | undefined;

    constructor(data?: IPagedResultDtoOfMailServiceMailAttachListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MailServiceMailAttachListResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMailServiceMailAttachListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMailServiceMailAttachListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMailServiceMailAttachListResponse {
    totalCount: number;
    items?: MailServiceMailAttachListResponse[] | undefined;
}

export class MailServiceMailAttachListResponse implements IMailServiceMailAttachListResponse {
    contenType?: string | undefined;
    fileName?: string | undefined;
    id!: number;

    constructor(data?: IMailServiceMailAttachListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contenType = _data["contenType"];
            this.fileName = _data["fileName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MailServiceMailAttachListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MailServiceMailAttachListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contenType"] = this.contenType;
        data["fileName"] = this.fileName;
        data["id"] = this.id;
        return data;
    }
}

export interface IMailServiceMailAttachListResponse {
    contenType?: string | undefined;
    fileName?: string | undefined;
    id: number;
}

export class PageListByDto implements IPageListByDto {
    sorting?: string | undefined;
    filter?: string | undefined;
    pageSize?: number | undefined;
    pageNumber?: number | undefined;
    isPaged!: boolean;

    constructor(data?: IPageListByDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sorting = _data["sorting"];
            this.filter = _data["filter"];
            this.pageSize = _data["pageSize"];
            this.pageNumber = _data["pageNumber"];
            this.isPaged = _data["isPaged"];
        }
    }

    static fromJS(data: any): PageListByDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageListByDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sorting"] = this.sorting;
        data["filter"] = this.filter;
        data["pageSize"] = this.pageSize;
        data["pageNumber"] = this.pageNumber;
        data["isPaged"] = this.isPaged;
        return data;
    }
}

export interface IPageListByDto {
    sorting?: string | undefined;
    filter?: string | undefined;
    pageSize?: number | undefined;
    pageNumber?: number | undefined;
    isPaged: boolean;
}

export class MailServiceMailAttachGetListQuery extends PageListByDto implements IMailServiceMailAttachGetListQuery {
    mailServiceMailBody?: number | undefined;

    constructor(data?: IMailServiceMailAttachGetListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.mailServiceMailBody = _data["mailServiceMailBody"];
        }
    }

    static override fromJS(data: any): MailServiceMailAttachGetListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new MailServiceMailAttachGetListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mailServiceMailBody"] = this.mailServiceMailBody;
        super.toJSON(data);
        return data;
    }
}

export interface IMailServiceMailAttachGetListQuery extends IPageListByDto {
    mailServiceMailBody?: number | undefined;
}

export class MailServiceMailAttachForEditResponse implements IMailServiceMailAttachForEditResponse {
    id!: number;
    mailServiceMailBody?: number | undefined;
    mailServiceMailBodyDesc?: string | undefined;
    contenType?: string | undefined;
    fileName?: string | undefined;
    base64File?: string | undefined;

    constructor(data?: IMailServiceMailAttachForEditResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.mailServiceMailBody = _data["mailServiceMailBody"];
            this.mailServiceMailBodyDesc = _data["mailServiceMailBodyDesc"];
            this.contenType = _data["contenType"];
            this.fileName = _data["fileName"];
            this.base64File = _data["base64File"];
        }
    }

    static fromJS(data: any): MailServiceMailAttachForEditResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MailServiceMailAttachForEditResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["mailServiceMailBody"] = this.mailServiceMailBody;
        data["mailServiceMailBodyDesc"] = this.mailServiceMailBodyDesc;
        data["contenType"] = this.contenType;
        data["fileName"] = this.fileName;
        data["base64File"] = this.base64File;
        return data;
    }
}

export interface IMailServiceMailAttachForEditResponse {
    id: number;
    mailServiceMailBody?: number | undefined;
    mailServiceMailBodyDesc?: string | undefined;
    contenType?: string | undefined;
    fileName?: string | undefined;
    base64File?: string | undefined;
}

export class MailServiceMailAttachGetForEditQuery implements IMailServiceMailAttachGetForEditQuery {
    id!: number;

    constructor(data?: IMailServiceMailAttachGetForEditQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MailServiceMailAttachGetForEditQuery {
        data = typeof data === 'object' ? data : {};
        let result = new MailServiceMailAttachGetForEditQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IMailServiceMailAttachGetForEditQuery {
    id: number;
}

export class MailServiceMailAttachGetFileQuery implements IMailServiceMailAttachGetFileQuery {
    id!: number;

    constructor(data?: IMailServiceMailAttachGetFileQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MailServiceMailAttachGetFileQuery {
        data = typeof data === 'object' ? data : {};
        let result = new MailServiceMailAttachGetFileQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IMailServiceMailAttachGetFileQuery {
    id: number;
}

export class MailServiceMailConfigForEditResponse implements IMailServiceMailConfigForEditResponse {
    mailServiceMail!: number;
    mailServiceMailDesc?: string | undefined;
    sender?: string | undefined;
    senderDisplay?: string | undefined;
    smpthost?: string | undefined;
    smptport?: number | undefined;
    isSsl?: boolean | undefined;
    isSslDesc?: string | undefined;
    useDefaultCredential?: boolean | undefined;
    useDefaultCredentialDesc?: string | undefined;
    domain?: string | undefined;
    mailUser?: string | undefined;
    mailPassword?: string | undefined;
    id!: number;

    constructor(data?: IMailServiceMailConfigForEditResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mailServiceMail = _data["mailServiceMail"];
            this.mailServiceMailDesc = _data["mailServiceMailDesc"];
            this.sender = _data["sender"];
            this.senderDisplay = _data["senderDisplay"];
            this.smpthost = _data["smpthost"];
            this.smptport = _data["smptport"];
            this.isSsl = _data["isSsl"];
            this.isSslDesc = _data["isSslDesc"];
            this.useDefaultCredential = _data["useDefaultCredential"];
            this.useDefaultCredentialDesc = _data["useDefaultCredentialDesc"];
            this.domain = _data["domain"];
            this.mailUser = _data["mailUser"];
            this.mailPassword = _data["mailPassword"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MailServiceMailConfigForEditResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MailServiceMailConfigForEditResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mailServiceMail"] = this.mailServiceMail;
        data["mailServiceMailDesc"] = this.mailServiceMailDesc;
        data["sender"] = this.sender;
        data["senderDisplay"] = this.senderDisplay;
        data["smpthost"] = this.smpthost;
        data["smptport"] = this.smptport;
        data["isSsl"] = this.isSsl;
        data["isSslDesc"] = this.isSslDesc;
        data["useDefaultCredential"] = this.useDefaultCredential;
        data["useDefaultCredentialDesc"] = this.useDefaultCredentialDesc;
        data["domain"] = this.domain;
        data["mailUser"] = this.mailUser;
        data["mailPassword"] = this.mailPassword;
        data["id"] = this.id;
        return data;
    }
}

export interface IMailServiceMailConfigForEditResponse {
    mailServiceMail: number;
    mailServiceMailDesc?: string | undefined;
    sender?: string | undefined;
    senderDisplay?: string | undefined;
    smpthost?: string | undefined;
    smptport?: number | undefined;
    isSsl?: boolean | undefined;
    isSslDesc?: string | undefined;
    useDefaultCredential?: boolean | undefined;
    useDefaultCredentialDesc?: string | undefined;
    domain?: string | undefined;
    mailUser?: string | undefined;
    mailPassword?: string | undefined;
    id: number;
}

export class MailServiceMailConfigGetForEditQuery implements IMailServiceMailConfigGetForEditQuery {
    id!: number;

    constructor(data?: IMailServiceMailConfigGetForEditQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MailServiceMailConfigGetForEditQuery {
        data = typeof data === 'object' ? data : {};
        let result = new MailServiceMailConfigGetForEditQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IMailServiceMailConfigGetForEditQuery {
    id: number;
}

export class PagedResultDtoOfMailServiceMailListResponse implements IPagedResultDtoOfMailServiceMailListResponse {
    totalCount!: number;
    items?: MailServiceMailListResponse[] | undefined;

    constructor(data?: IPagedResultDtoOfMailServiceMailListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MailServiceMailListResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMailServiceMailListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMailServiceMailListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMailServiceMailListResponse {
    totalCount: number;
    items?: MailServiceMailListResponse[] | undefined;
}

export class MailServiceMailListResponse implements IMailServiceMailListResponse {
    id!: number;
    mailServiceRequest!: number;
    mailServiceRequestDate?: moment.Moment | undefined;
    isLocalConfig!: boolean;
    isLocalConfigDesc?: string | undefined;
    sendto?: string | undefined;
    copyTo?: string | undefined;
    subject?: string | undefined;
    status!: number;
    statusDesc?: string | undefined;

    constructor(data?: IMailServiceMailListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.mailServiceRequest = _data["mailServiceRequest"];
            this.mailServiceRequestDate = _data["mailServiceRequestDate"] ? moment(_data["mailServiceRequestDate"].toString()) : <any>undefined;
            this.isLocalConfig = _data["isLocalConfig"];
            this.isLocalConfigDesc = _data["isLocalConfigDesc"];
            this.sendto = _data["sendto"];
            this.copyTo = _data["copyTo"];
            this.subject = _data["subject"];
            this.status = _data["status"];
            this.statusDesc = _data["statusDesc"];
        }
    }

    static fromJS(data: any): MailServiceMailListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MailServiceMailListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["mailServiceRequest"] = this.mailServiceRequest;
        data["mailServiceRequestDate"] = this.mailServiceRequestDate ? this.mailServiceRequestDate.toISOString() : <any>undefined;
        data["isLocalConfig"] = this.isLocalConfig;
        data["isLocalConfigDesc"] = this.isLocalConfigDesc;
        data["sendto"] = this.sendto;
        data["copyTo"] = this.copyTo;
        data["subject"] = this.subject;
        data["status"] = this.status;
        data["statusDesc"] = this.statusDesc;
        return data;
    }
}

export interface IMailServiceMailListResponse {
    id: number;
    mailServiceRequest: number;
    mailServiceRequestDate?: moment.Moment | undefined;
    isLocalConfig: boolean;
    isLocalConfigDesc?: string | undefined;
    sendto?: string | undefined;
    copyTo?: string | undefined;
    subject?: string | undefined;
    status: number;
    statusDesc?: string | undefined;
}

export class MailServiceMailGetListQuery extends PageListByDto implements IMailServiceMailGetListQuery {
    startDate!: moment.Moment;
    endDate!: moment.Moment;
    tenantId?: number | undefined;
    onlyHost?: boolean | undefined;

    constructor(data?: IMailServiceMailGetListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.onlyHost = _data["onlyHost"];
        }
    }

    static override fromJS(data: any): MailServiceMailGetListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new MailServiceMailGetListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["onlyHost"] = this.onlyHost;
        super.toJSON(data);
        return data;
    }
}

export interface IMailServiceMailGetListQuery extends IPageListByDto {
    startDate: moment.Moment;
    endDate: moment.Moment;
    tenantId?: number | undefined;
    onlyHost?: boolean | undefined;
}

export class MailServiceMailForEditResponse implements IMailServiceMailForEditResponse {
    id?: number | undefined;
    mailServiceRequest?: number | undefined;
    mailServiceRequestDate?: moment.Moment | undefined;
    isLocalConfig?: boolean | undefined;
    isLocalConfigDesc?: string | undefined;
    sendto?: string | undefined;
    copyTo?: string | undefined;
    blindCopyTo?: string | undefined;
    subject?: string | undefined;
    mailServiceMailStatus?: MailServiceMailStatusDto | undefined;
    mailServiceMailBody?: MailServiceMailBodyDto | undefined;

    constructor(data?: IMailServiceMailForEditResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.mailServiceRequest = _data["mailServiceRequest"];
            this.mailServiceRequestDate = _data["mailServiceRequestDate"] ? moment(_data["mailServiceRequestDate"].toString()) : <any>undefined;
            this.isLocalConfig = _data["isLocalConfig"];
            this.isLocalConfigDesc = _data["isLocalConfigDesc"];
            this.sendto = _data["sendto"];
            this.copyTo = _data["copyTo"];
            this.blindCopyTo = _data["blindCopyTo"];
            this.subject = _data["subject"];
            this.mailServiceMailStatus = _data["mailServiceMailStatus"] ? MailServiceMailStatusDto.fromJS(_data["mailServiceMailStatus"]) : <any>undefined;
            this.mailServiceMailBody = _data["mailServiceMailBody"] ? MailServiceMailBodyDto.fromJS(_data["mailServiceMailBody"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MailServiceMailForEditResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MailServiceMailForEditResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["mailServiceRequest"] = this.mailServiceRequest;
        data["mailServiceRequestDate"] = this.mailServiceRequestDate ? this.mailServiceRequestDate.toISOString() : <any>undefined;
        data["isLocalConfig"] = this.isLocalConfig;
        data["isLocalConfigDesc"] = this.isLocalConfigDesc;
        data["sendto"] = this.sendto;
        data["copyTo"] = this.copyTo;
        data["blindCopyTo"] = this.blindCopyTo;
        data["subject"] = this.subject;
        data["mailServiceMailStatus"] = this.mailServiceMailStatus ? this.mailServiceMailStatus.toJSON() : <any>undefined;
        data["mailServiceMailBody"] = this.mailServiceMailBody ? this.mailServiceMailBody.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMailServiceMailForEditResponse {
    id?: number | undefined;
    mailServiceRequest?: number | undefined;
    mailServiceRequestDate?: moment.Moment | undefined;
    isLocalConfig?: boolean | undefined;
    isLocalConfigDesc?: string | undefined;
    sendto?: string | undefined;
    copyTo?: string | undefined;
    blindCopyTo?: string | undefined;
    subject?: string | undefined;
    mailServiceMailStatus?: MailServiceMailStatusDto | undefined;
    mailServiceMailBody?: MailServiceMailBodyDto | undefined;
}

export class MailServiceMailStatusDto implements IMailServiceMailStatusDto {
    mailServiceMail!: number;
    mailServiceMailDesc?: string | undefined;
    sentTime?: moment.Moment | undefined;
    status!: number;
    statusDesc?: string | undefined;
    error?: string | undefined;
    id!: number;

    constructor(data?: IMailServiceMailStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mailServiceMail = _data["mailServiceMail"];
            this.mailServiceMailDesc = _data["mailServiceMailDesc"];
            this.sentTime = _data["sentTime"] ? moment(_data["sentTime"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.statusDesc = _data["statusDesc"];
            this.error = _data["error"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MailServiceMailStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new MailServiceMailStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mailServiceMail"] = this.mailServiceMail;
        data["mailServiceMailDesc"] = this.mailServiceMailDesc;
        data["sentTime"] = this.sentTime ? this.sentTime.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["statusDesc"] = this.statusDesc;
        data["error"] = this.error;
        data["id"] = this.id;
        return data;
    }
}

export interface IMailServiceMailStatusDto {
    mailServiceMail: number;
    mailServiceMailDesc?: string | undefined;
    sentTime?: moment.Moment | undefined;
    status: number;
    statusDesc?: string | undefined;
    error?: string | undefined;
    id: number;
}

export class MailServiceMailBodyDto implements IMailServiceMailBodyDto {
    mailServiceMail!: number;
    mailServiceMailDesc?: string | undefined;
    body?: string | undefined;
    id!: number;

    constructor(data?: IMailServiceMailBodyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mailServiceMail = _data["mailServiceMail"];
            this.mailServiceMailDesc = _data["mailServiceMailDesc"];
            this.body = _data["body"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MailServiceMailBodyDto {
        data = typeof data === 'object' ? data : {};
        let result = new MailServiceMailBodyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mailServiceMail"] = this.mailServiceMail;
        data["mailServiceMailDesc"] = this.mailServiceMailDesc;
        data["body"] = this.body;
        data["id"] = this.id;
        return data;
    }
}

export interface IMailServiceMailBodyDto {
    mailServiceMail: number;
    mailServiceMailDesc?: string | undefined;
    body?: string | undefined;
    id: number;
}

export class MailServiceMailGetForEditQuery implements IMailServiceMailGetForEditQuery {
    id!: number;

    constructor(data?: IMailServiceMailGetForEditQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MailServiceMailGetForEditQuery {
        data = typeof data === 'object' ? data : {};
        let result = new MailServiceMailGetForEditQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IMailServiceMailGetForEditQuery {
    id: number;
}

export class SampleLogTraceCommand implements ISampleLogTraceCommand {
    message?: string | undefined;

    constructor(data?: ISampleLogTraceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): SampleLogTraceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SampleLogTraceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        return data;
    }
}

export interface ISampleLogTraceCommand {
    message?: string | undefined;
}

export class SampleLogDebugCommand implements ISampleLogDebugCommand {
    message?: string | undefined;

    constructor(data?: ISampleLogDebugCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): SampleLogDebugCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SampleLogDebugCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        return data;
    }
}

export interface ISampleLogDebugCommand {
    message?: string | undefined;
}

export class SampleLogInformationCommand implements ISampleLogInformationCommand {
    message?: string | undefined;

    constructor(data?: ISampleLogInformationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): SampleLogInformationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SampleLogInformationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        return data;
    }
}

export interface ISampleLogInformationCommand {
    message?: string | undefined;
}

export class SampleLogWarningCommand implements ISampleLogWarningCommand {
    message?: string | undefined;

    constructor(data?: ISampleLogWarningCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): SampleLogWarningCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SampleLogWarningCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        return data;
    }
}

export interface ISampleLogWarningCommand {
    message?: string | undefined;
}

export class SampleLogErrorCommand implements ISampleLogErrorCommand {
    message?: string | undefined;

    constructor(data?: ISampleLogErrorCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): SampleLogErrorCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SampleLogErrorCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        return data;
    }
}

export interface ISampleLogErrorCommand {
    message?: string | undefined;
}

export class SampleLogCriticalCommand implements ISampleLogCriticalCommand {
    message?: string | undefined;
    email?: string | undefined;

    constructor(data?: ISampleLogCriticalCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): SampleLogCriticalCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SampleLogCriticalCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["email"] = this.email;
        return data;
    }
}

export interface ISampleLogCriticalCommand {
    message?: string | undefined;
    email?: string | undefined;
}

export class PagedResultDtoOfAuditLogListResponse implements IPagedResultDtoOfAuditLogListResponse {
    totalCount!: number;
    items?: AuditLogListResponse[] | undefined;

    constructor(data?: IPagedResultDtoOfAuditLogListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AuditLogListResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAuditLogListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAuditLogListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfAuditLogListResponse {
    totalCount: number;
    items?: AuditLogListResponse[] | undefined;
}

export class AuditLogListResponse implements IAuditLogListResponse {
    id?: number | undefined;
    tenantName?: string | undefined;
    userId?: number | undefined;
    userName?: string | undefined;
    impersonalizerUserId?: number | undefined;
    impersonalizerUserName?: string | undefined;
    serviceName?: string | undefined;
    methodName?: string | undefined;
    parameters?: string | undefined;
    executionTime?: moment.Moment | undefined;
    executionDuration?: number | undefined;
    clientIpAddress?: string | undefined;
    clientName?: string | undefined;
    browserInfo?: string | undefined;
    exception?: string | undefined;
    customData?: string | undefined;
    severity?: number | undefined;

    constructor(data?: IAuditLogListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantName = _data["tenantName"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.impersonalizerUserId = _data["impersonalizerUserId"];
            this.impersonalizerUserName = _data["impersonalizerUserName"];
            this.serviceName = _data["serviceName"];
            this.methodName = _data["methodName"];
            this.parameters = _data["parameters"];
            this.executionTime = _data["executionTime"] ? moment(_data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = _data["executionDuration"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.clientName = _data["clientName"];
            this.browserInfo = _data["browserInfo"];
            this.exception = _data["exception"];
            this.customData = _data["customData"];
            this.severity = _data["severity"];
        }
    }

    static fromJS(data: any): AuditLogListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantName"] = this.tenantName;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["impersonalizerUserId"] = this.impersonalizerUserId;
        data["impersonalizerUserName"] = this.impersonalizerUserName;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        data["severity"] = this.severity;
        return data;
    }
}

export interface IAuditLogListResponse {
    id?: number | undefined;
    tenantName?: string | undefined;
    userId?: number | undefined;
    userName?: string | undefined;
    impersonalizerUserId?: number | undefined;
    impersonalizerUserName?: string | undefined;
    serviceName?: string | undefined;
    methodName?: string | undefined;
    parameters?: string | undefined;
    executionTime?: moment.Moment | undefined;
    executionDuration?: number | undefined;
    clientIpAddress?: string | undefined;
    clientName?: string | undefined;
    browserInfo?: string | undefined;
    exception?: string | undefined;
    customData?: string | undefined;
    severity?: number | undefined;
}

export class AuditLogGetListQuery extends PageListByDto implements IAuditLogGetListQuery {
    startDate!: moment.Moment;
    endDate!: moment.Moment;
    userName?: string | undefined;
    serviceName?: string | undefined;
    methodName?: string | undefined;
    browserInfo?: string | undefined;
    tenantId?: number | undefined;
    hasException?: boolean | undefined;
    minExecutionDuration?: number | undefined;
    maxExecutionDuration?: number | undefined;
    severity?: number | undefined;
    onlyHost?: boolean | undefined;

    constructor(data?: IAuditLogGetListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.userName = _data["userName"];
            this.serviceName = _data["serviceName"];
            this.methodName = _data["methodName"];
            this.browserInfo = _data["browserInfo"];
            this.tenantId = _data["tenantId"];
            this.hasException = _data["hasException"];
            this.minExecutionDuration = _data["minExecutionDuration"];
            this.maxExecutionDuration = _data["maxExecutionDuration"];
            this.severity = _data["severity"];
            this.onlyHost = _data["onlyHost"];
        }
    }

    static override fromJS(data: any): AuditLogGetListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogGetListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["userName"] = this.userName;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["browserInfo"] = this.browserInfo;
        data["tenantId"] = this.tenantId;
        data["hasException"] = this.hasException;
        data["minExecutionDuration"] = this.minExecutionDuration;
        data["maxExecutionDuration"] = this.maxExecutionDuration;
        data["severity"] = this.severity;
        data["onlyHost"] = this.onlyHost;
        super.toJSON(data);
        return data;
    }
}

export interface IAuditLogGetListQuery extends IPageListByDto {
    startDate: moment.Moment;
    endDate: moment.Moment;
    userName?: string | undefined;
    serviceName?: string | undefined;
    methodName?: string | undefined;
    browserInfo?: string | undefined;
    tenantId?: number | undefined;
    hasException?: boolean | undefined;
    minExecutionDuration?: number | undefined;
    maxExecutionDuration?: number | undefined;
    severity?: number | undefined;
    onlyHost?: boolean | undefined;
}

export class AuditLogExcelResponse implements IAuditLogExcelResponse {
    fileName?: string | undefined;
    fileType?: string | undefined;
    fileToken?: string | undefined;

    constructor(data?: IAuditLogExcelResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fileToken = _data["fileToken"];
        }
    }

    static fromJS(data: any): AuditLogExcelResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogExcelResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data;
    }
}

export interface IAuditLogExcelResponse {
    fileName?: string | undefined;
    fileType?: string | undefined;
    fileToken?: string | undefined;
}

export class AuditLogGetExcelQuery extends PageListByDto implements IAuditLogGetExcelQuery {
    startDate!: moment.Moment;
    endDate!: moment.Moment;
    userName?: string | undefined;
    serviceName?: string | undefined;
    methodName?: string | undefined;
    browserInfo?: string | undefined;
    tenantId?: number | undefined;
    hasException?: boolean | undefined;
    minExecutionDuration?: number | undefined;
    maxExecutionDuration?: number | undefined;
    severity?: number | undefined;
    onlyHost?: boolean | undefined;

    constructor(data?: IAuditLogGetExcelQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.userName = _data["userName"];
            this.serviceName = _data["serviceName"];
            this.methodName = _data["methodName"];
            this.browserInfo = _data["browserInfo"];
            this.tenantId = _data["tenantId"];
            this.hasException = _data["hasException"];
            this.minExecutionDuration = _data["minExecutionDuration"];
            this.maxExecutionDuration = _data["maxExecutionDuration"];
            this.severity = _data["severity"];
            this.onlyHost = _data["onlyHost"];
        }
    }

    static override fromJS(data: any): AuditLogGetExcelQuery {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogGetExcelQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["userName"] = this.userName;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["browserInfo"] = this.browserInfo;
        data["tenantId"] = this.tenantId;
        data["hasException"] = this.hasException;
        data["minExecutionDuration"] = this.minExecutionDuration;
        data["maxExecutionDuration"] = this.maxExecutionDuration;
        data["severity"] = this.severity;
        data["onlyHost"] = this.onlyHost;
        super.toJSON(data);
        return data;
    }
}

export interface IAuditLogGetExcelQuery extends IPageListByDto {
    startDate: moment.Moment;
    endDate: moment.Moment;
    userName?: string | undefined;
    serviceName?: string | undefined;
    methodName?: string | undefined;
    browserInfo?: string | undefined;
    tenantId?: number | undefined;
    hasException?: boolean | undefined;
    minExecutionDuration?: number | undefined;
    maxExecutionDuration?: number | undefined;
    severity?: number | undefined;
    onlyHost?: boolean | undefined;
}

export class SessionLoginResponse implements ISessionLoginResponse {
    tenantId?: number | undefined;
    tenancyName?: string | undefined;
    userId!: number;
    userName?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    secondLastName?: string | undefined;
    eMail?: string | undefined;
    isImpersonalized!: boolean;
    impersonalizerUserId?: number | undefined;

    constructor(data?: ISessionLoginResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.tenancyName = _data["tenancyName"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.secondLastName = _data["secondLastName"];
            this.eMail = _data["eMail"];
            this.isImpersonalized = _data["isImpersonalized"];
            this.impersonalizerUserId = _data["impersonalizerUserId"];
        }
    }

    static fromJS(data: any): SessionLoginResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SessionLoginResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["secondLastName"] = this.secondLastName;
        data["eMail"] = this.eMail;
        data["isImpersonalized"] = this.isImpersonalized;
        data["impersonalizerUserId"] = this.impersonalizerUserId;
        return data;
    }
}

export interface ISessionLoginResponse {
    tenantId?: number | undefined;
    tenancyName?: string | undefined;
    userId: number;
    userName?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    secondLastName?: string | undefined;
    eMail?: string | undefined;
    isImpersonalized: boolean;
    impersonalizerUserId?: number | undefined;
}

export class SessionLoginResponseController extends SessionLoginResponse implements ISessionLoginResponseController {
    token?: string | undefined;

    constructor(data?: ISessionLoginResponseController) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.token = _data["token"];
        }
    }

    static override fromJS(data: any): SessionLoginResponseController {
        data = typeof data === 'object' ? data : {};
        let result = new SessionLoginResponseController();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        super.toJSON(data);
        return data;
    }
}

export interface ISessionLoginResponseController extends ISessionLoginResponse {
    token?: string | undefined;
}

export class UserLoginQuery implements IUserLoginQuery {
    userName?: string | undefined;
    password?: string | undefined;
    tenancyName?: string | undefined;

    constructor(data?: IUserLoginQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): UserLoginQuery {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["tenancyName"] = this.tenancyName;
        return data;
    }
}

export interface IUserLoginQuery {
    userName?: string | undefined;
    password?: string | undefined;
    tenancyName?: string | undefined;
}

export class UserImpersonalizeQuery implements IUserImpersonalizeQuery {
    tenant?: number | undefined;
    user!: number;

    constructor(data?: IUserImpersonalizeQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenant = _data["tenant"];
            this.user = _data["user"];
        }
    }

    static fromJS(data: any): UserImpersonalizeQuery {
        data = typeof data === 'object' ? data : {};
        let result = new UserImpersonalizeQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenant"] = this.tenant;
        data["user"] = this.user;
        return data;
    }
}

export interface IUserImpersonalizeQuery {
    tenant?: number | undefined;
    user: number;
}

export class UserChangePasswordCommand implements IUserChangePasswordCommand {
    tenancyName?: string | undefined;
    userName?: string | undefined;
    currentPassword?: string | undefined;
    newPassword?: string | undefined;
    confirmPassword?: string | undefined;

    constructor(data?: IUserChangePasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.userName = _data["userName"];
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): UserChangePasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UserChangePasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }
}

export interface IUserChangePasswordCommand {
    tenancyName?: string | undefined;
    userName?: string | undefined;
    currentPassword?: string | undefined;
    newPassword?: string | undefined;
    confirmPassword?: string | undefined;
}

export class UserResetPasswordCommand implements IUserResetPasswordCommand {
    userName?: string | undefined;
    tenancyName?: string | undefined;

    constructor(data?: IUserResetPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): UserResetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UserResetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["tenancyName"] = this.tenancyName;
        return data;
    }
}

export interface IUserResetPasswordCommand {
    userName?: string | undefined;
    tenancyName?: string | undefined;
}

export class ConfirmPasswordCommandReset implements IConfirmPasswordCommandReset {
    confirmationCode?: string | undefined;
    password?: string | undefined;
    confirmPassword?: string | undefined;

    constructor(data?: IConfirmPasswordCommandReset) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.confirmationCode = _data["confirmationCode"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): ConfirmPasswordCommandReset {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmPasswordCommandReset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["confirmationCode"] = this.confirmationCode;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }
}

export interface IConfirmPasswordCommandReset {
    confirmationCode?: string | undefined;
    password?: string | undefined;
    confirmPassword?: string | undefined;
}

export class PagedResultDtoOfCatalogCustomForListResponse implements IPagedResultDtoOfCatalogCustomForListResponse {
    totalCount!: number;
    items?: CatalogCustomForListResponse[] | undefined;

    constructor(data?: IPagedResultDtoOfCatalogCustomForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CatalogCustomForListResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCatalogCustomForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCatalogCustomForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfCatalogCustomForListResponse {
    totalCount: number;
    items?: CatalogCustomForListResponse[] | undefined;
}

export class CatalogCustomForListResponse implements ICatalogCustomForListResponse {
    id?: string | undefined;
    creationDateTime?: moment.Moment | undefined;
    collectionName?: string | undefined;
    description?: string | undefined;
    isCollectionGenerated!: boolean;
    isCollectionGeneratedDesc?: string | undefined;
    namePlural?: string | undefined;
    nameSingular?: string | undefined;
    userCreator?: string | undefined;
    isActive!: boolean;
    isActiveDesc?: string | undefined;
    questionnaire?: string | undefined;

    constructor(data?: ICatalogCustomForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationDateTime = _data["creationDateTime"] ? moment(_data["creationDateTime"].toString()) : <any>undefined;
            this.collectionName = _data["collectionName"];
            this.description = _data["description"];
            this.isCollectionGenerated = _data["isCollectionGenerated"];
            this.isCollectionGeneratedDesc = _data["isCollectionGeneratedDesc"];
            this.namePlural = _data["namePlural"];
            this.nameSingular = _data["nameSingular"];
            this.userCreator = _data["userCreator"];
            this.isActive = _data["isActive"];
            this.isActiveDesc = _data["isActiveDesc"];
            this.questionnaire = _data["questionnaire"];
        }
    }

    static fromJS(data: any): CatalogCustomForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogCustomForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationDateTime"] = this.creationDateTime ? this.creationDateTime.toISOString() : <any>undefined;
        data["collectionName"] = this.collectionName;
        data["description"] = this.description;
        data["isCollectionGenerated"] = this.isCollectionGenerated;
        data["isCollectionGeneratedDesc"] = this.isCollectionGeneratedDesc;
        data["namePlural"] = this.namePlural;
        data["nameSingular"] = this.nameSingular;
        data["userCreator"] = this.userCreator;
        data["isActive"] = this.isActive;
        data["isActiveDesc"] = this.isActiveDesc;
        data["questionnaire"] = this.questionnaire;
        return data;
    }
}

export interface ICatalogCustomForListResponse {
    id?: string | undefined;
    creationDateTime?: moment.Moment | undefined;
    collectionName?: string | undefined;
    description?: string | undefined;
    isCollectionGenerated: boolean;
    isCollectionGeneratedDesc?: string | undefined;
    namePlural?: string | undefined;
    nameSingular?: string | undefined;
    userCreator?: string | undefined;
    isActive: boolean;
    isActiveDesc?: string | undefined;
    questionnaire?: string | undefined;
}

export class CatalogCustomGetListQuery extends PageListByDto implements ICatalogCustomGetListQuery {

    constructor(data?: ICatalogCustomGetListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CatalogCustomGetListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogCustomGetListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICatalogCustomGetListQuery extends IPageListByDto {
}

export class ComboboxItemDtoOfString implements IComboboxItemDtoOfString {
    value?: string | undefined;
    label?: string | undefined;

    constructor(data?: IComboboxItemDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): ComboboxItemDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["label"] = this.label;
        return data;
    }
}

export interface IComboboxItemDtoOfString {
    value?: string | undefined;
    label?: string | undefined;
}

export class ComboboxItemDto extends ComboboxItemDtoOfString implements IComboboxItemDto {

    constructor(data?: IComboboxItemDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IComboboxItemDto extends IComboboxItemDtoOfString {
}

export class CatalogCustomGetComboQuery implements ICatalogCustomGetComboQuery {
    filter?: string | undefined;
    isActive?: boolean | undefined;

    constructor(data?: ICatalogCustomGetComboQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filter = _data["filter"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CatalogCustomGetComboQuery {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogCustomGetComboQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICatalogCustomGetComboQuery {
    filter?: string | undefined;
    isActive?: boolean | undefined;
}

export class CatalogCustomResponse implements ICatalogCustomResponse {
    id?: string | undefined;
    creationDateTime?: moment.Moment | undefined;
    collectionName?: string | undefined;
    description?: string | undefined;
    isCollectionGenerated!: boolean;
    namePlural?: string | undefined;
    nameSingular?: string | undefined;
    userCreator?: string | undefined;
    isActive!: boolean;
    questionnaire?: string | undefined;
    fieldNames?: string[] | undefined;

    constructor(data?: ICatalogCustomResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationDateTime = _data["creationDateTime"] ? moment(_data["creationDateTime"].toString()) : <any>undefined;
            this.collectionName = _data["collectionName"];
            this.description = _data["description"];
            this.isCollectionGenerated = _data["isCollectionGenerated"];
            this.namePlural = _data["namePlural"];
            this.nameSingular = _data["nameSingular"];
            this.userCreator = _data["userCreator"];
            this.isActive = _data["isActive"];
            this.questionnaire = _data["questionnaire"];
            if (Array.isArray(_data["fieldNames"])) {
                this.fieldNames = [] as any;
                for (let item of _data["fieldNames"])
                    this.fieldNames!.push(item);
            }
        }
    }

    static fromJS(data: any): CatalogCustomResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogCustomResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationDateTime"] = this.creationDateTime ? this.creationDateTime.toISOString() : <any>undefined;
        data["collectionName"] = this.collectionName;
        data["description"] = this.description;
        data["isCollectionGenerated"] = this.isCollectionGenerated;
        data["namePlural"] = this.namePlural;
        data["nameSingular"] = this.nameSingular;
        data["userCreator"] = this.userCreator;
        data["isActive"] = this.isActive;
        data["questionnaire"] = this.questionnaire;
        if (Array.isArray(this.fieldNames)) {
            data["fieldNames"] = [];
            for (let item of this.fieldNames)
                data["fieldNames"].push(item);
        }
        return data;
    }
}

export interface ICatalogCustomResponse {
    id?: string | undefined;
    creationDateTime?: moment.Moment | undefined;
    collectionName?: string | undefined;
    description?: string | undefined;
    isCollectionGenerated: boolean;
    namePlural?: string | undefined;
    nameSingular?: string | undefined;
    userCreator?: string | undefined;
    isActive: boolean;
    questionnaire?: string | undefined;
    fieldNames?: string[] | undefined;
}

export class CatalogCustomForEditResponse implements ICatalogCustomForEditResponse {
    id?: string | undefined;
    creationDateTime?: moment.Moment | undefined;
    collectionName?: string | undefined;
    description?: string | undefined;
    isCollectionGenerated!: boolean;
    namePlural?: string | undefined;
    nameSingular?: string | undefined;
    userCreator?: string | undefined;
    isActive!: boolean;
    questionnaire?: string | undefined;
    questionnaireDesc?: string | undefined;
    fieldNames?: string[] | undefined;
    questionnaireCombo?: ComboboxItemDto[] | undefined;

    constructor(data?: ICatalogCustomForEditResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationDateTime = _data["creationDateTime"] ? moment(_data["creationDateTime"].toString()) : <any>undefined;
            this.collectionName = _data["collectionName"];
            this.description = _data["description"];
            this.isCollectionGenerated = _data["isCollectionGenerated"];
            this.namePlural = _data["namePlural"];
            this.nameSingular = _data["nameSingular"];
            this.userCreator = _data["userCreator"];
            this.isActive = _data["isActive"];
            this.questionnaire = _data["questionnaire"];
            this.questionnaireDesc = _data["questionnaireDesc"];
            if (Array.isArray(_data["fieldNames"])) {
                this.fieldNames = [] as any;
                for (let item of _data["fieldNames"])
                    this.fieldNames!.push(item);
            }
            if (Array.isArray(_data["questionnaireCombo"])) {
                this.questionnaireCombo = [] as any;
                for (let item of _data["questionnaireCombo"])
                    this.questionnaireCombo!.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CatalogCustomForEditResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogCustomForEditResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationDateTime"] = this.creationDateTime ? this.creationDateTime.toISOString() : <any>undefined;
        data["collectionName"] = this.collectionName;
        data["description"] = this.description;
        data["isCollectionGenerated"] = this.isCollectionGenerated;
        data["namePlural"] = this.namePlural;
        data["nameSingular"] = this.nameSingular;
        data["userCreator"] = this.userCreator;
        data["isActive"] = this.isActive;
        data["questionnaire"] = this.questionnaire;
        data["questionnaireDesc"] = this.questionnaireDesc;
        if (Array.isArray(this.fieldNames)) {
            data["fieldNames"] = [];
            for (let item of this.fieldNames)
                data["fieldNames"].push(item);
        }
        if (Array.isArray(this.questionnaireCombo)) {
            data["questionnaireCombo"] = [];
            for (let item of this.questionnaireCombo)
                data["questionnaireCombo"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICatalogCustomForEditResponse {
    id?: string | undefined;
    creationDateTime?: moment.Moment | undefined;
    collectionName?: string | undefined;
    description?: string | undefined;
    isCollectionGenerated: boolean;
    namePlural?: string | undefined;
    nameSingular?: string | undefined;
    userCreator?: string | undefined;
    isActive: boolean;
    questionnaire?: string | undefined;
    questionnaireDesc?: string | undefined;
    fieldNames?: string[] | undefined;
    questionnaireCombo?: ComboboxItemDto[] | undefined;
}

export class CatalogCustomGetForEditQuery implements ICatalogCustomGetForEditQuery {
    id?: string | undefined;

    constructor(data?: ICatalogCustomGetForEditQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CatalogCustomGetForEditQuery {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogCustomGetForEditQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ICatalogCustomGetForEditQuery {
    id?: string | undefined;
}

export class CatalogCustomCreateCommand implements ICatalogCustomCreateCommand {
    description?: string | undefined;
    namePlural?: string | undefined;
    nameSingular?: string | undefined;
    userCreator?: string | undefined;
    isActive!: boolean;
    questionnaire?: string | undefined;
    fieldNames?: string[] | undefined;

    constructor(data?: ICatalogCustomCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.namePlural = _data["namePlural"];
            this.nameSingular = _data["nameSingular"];
            this.userCreator = _data["userCreator"];
            this.isActive = _data["isActive"];
            this.questionnaire = _data["questionnaire"];
            if (Array.isArray(_data["fieldNames"])) {
                this.fieldNames = [] as any;
                for (let item of _data["fieldNames"])
                    this.fieldNames!.push(item);
            }
        }
    }

    static fromJS(data: any): CatalogCustomCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogCustomCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["namePlural"] = this.namePlural;
        data["nameSingular"] = this.nameSingular;
        data["userCreator"] = this.userCreator;
        data["isActive"] = this.isActive;
        data["questionnaire"] = this.questionnaire;
        if (Array.isArray(this.fieldNames)) {
            data["fieldNames"] = [];
            for (let item of this.fieldNames)
                data["fieldNames"].push(item);
        }
        return data;
    }
}

export interface ICatalogCustomCreateCommand {
    description?: string | undefined;
    namePlural?: string | undefined;
    nameSingular?: string | undefined;
    userCreator?: string | undefined;
    isActive: boolean;
    questionnaire?: string | undefined;
    fieldNames?: string[] | undefined;
}

export class CatalogCustomUpdateCommand implements ICatalogCustomUpdateCommand {
    id?: string | undefined;
    description?: string | undefined;
    namePlural?: string | undefined;
    nameSingular?: string | undefined;
    userCreator?: string | undefined;
    isActive!: boolean;
    questionnaire?: string | undefined;
    fieldNames?: string[] | undefined;

    constructor(data?: ICatalogCustomUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.namePlural = _data["namePlural"];
            this.nameSingular = _data["nameSingular"];
            this.userCreator = _data["userCreator"];
            this.isActive = _data["isActive"];
            this.questionnaire = _data["questionnaire"];
            if (Array.isArray(_data["fieldNames"])) {
                this.fieldNames = [] as any;
                for (let item of _data["fieldNames"])
                    this.fieldNames!.push(item);
            }
        }
    }

    static fromJS(data: any): CatalogCustomUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogCustomUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["namePlural"] = this.namePlural;
        data["nameSingular"] = this.nameSingular;
        data["userCreator"] = this.userCreator;
        data["isActive"] = this.isActive;
        data["questionnaire"] = this.questionnaire;
        if (Array.isArray(this.fieldNames)) {
            data["fieldNames"] = [];
            for (let item of this.fieldNames)
                data["fieldNames"].push(item);
        }
        return data;
    }
}

export interface ICatalogCustomUpdateCommand {
    id?: string | undefined;
    description?: string | undefined;
    namePlural?: string | undefined;
    nameSingular?: string | undefined;
    userCreator?: string | undefined;
    isActive: boolean;
    questionnaire?: string | undefined;
    fieldNames?: string[] | undefined;
}

export class CatalogCustomFieldGetComboQuery implements ICatalogCustomFieldGetComboQuery {
    catalogCustom?: string | undefined;

    constructor(data?: ICatalogCustomFieldGetComboQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.catalogCustom = _data["catalogCustom"];
        }
    }

    static fromJS(data: any): CatalogCustomFieldGetComboQuery {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogCustomFieldGetComboQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catalogCustom"] = this.catalogCustom;
        return data;
    }
}

export interface ICatalogCustomFieldGetComboQuery {
    catalogCustom?: string | undefined;
}

export class PagedResultDtoOfDictionaryOfStringAndObject implements IPagedResultDtoOfDictionaryOfStringAndObject {
    totalCount!: number;
    items?: { [key: string]: any; }[] | undefined;

    constructor(data?: IPagedResultDtoOfDictionaryOfStringAndObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(item);
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDictionaryOfStringAndObject {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDictionaryOfStringAndObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item);
        }
        return data;
    }
}

export interface IPagedResultDtoOfDictionaryOfStringAndObject {
    totalCount: number;
    items?: { [key: string]: any; }[] | undefined;
}

export class CatalogCustomImplGetListQuery extends PageListByDto implements ICatalogCustomImplGetListQuery {
    catalog?: string | undefined;

    constructor(data?: ICatalogCustomImplGetListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.catalog = _data["catalog"];
        }
    }

    static override fromJS(data: any): CatalogCustomImplGetListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogCustomImplGetListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catalog"] = this.catalog;
        super.toJSON(data);
        return data;
    }
}

export interface ICatalogCustomImplGetListQuery extends IPageListByDto {
    catalog?: string | undefined;
}

export class CatalogCustomImplGetComboQuery implements ICatalogCustomImplGetComboQuery {
    filter?: string | undefined;
    catalog?: string | undefined;
    fieldName?: string | undefined;

    constructor(data?: ICatalogCustomImplGetComboQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filter = _data["filter"];
            this.catalog = _data["catalog"];
            this.fieldName = _data["fieldName"];
        }
    }

    static fromJS(data: any): CatalogCustomImplGetComboQuery {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogCustomImplGetComboQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["catalog"] = this.catalog;
        data["fieldName"] = this.fieldName;
        return data;
    }
}

export interface ICatalogCustomImplGetComboQuery {
    filter?: string | undefined;
    catalog?: string | undefined;
    fieldName?: string | undefined;
}

export class CatalogCustomImplResponse implements ICatalogCustomImplResponse {
    id?: string | undefined;
    data?: { [key: string]: any; } | undefined;

    constructor(data?: ICatalogCustomImplResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
        }
    }

    static fromJS(data: any): CatalogCustomImplResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogCustomImplResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        return data;
    }
}

export interface ICatalogCustomImplResponse {
    id?: string | undefined;
    data?: { [key: string]: any; } | undefined;
}

export class CatalogCustomImplGetByIdQuery implements ICatalogCustomImplGetByIdQuery {
    catalog?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICatalogCustomImplGetByIdQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.catalog = _data["catalog"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CatalogCustomImplGetByIdQuery {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogCustomImplGetByIdQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catalog"] = this.catalog;
        data["id"] = this.id;
        return data;
    }
}

export interface ICatalogCustomImplGetByIdQuery {
    catalog?: string | undefined;
    id?: string | undefined;
}

export class CatalogCustomImplForReadResponse implements ICatalogCustomImplForReadResponse {
    id?: string | undefined;
    data?: { [key: string]: any; } | undefined;
    catalogCustom?: CatalogCustomResponse | undefined;
    questionnaire?: QuestionnaireResponse | undefined;

    constructor(data?: ICatalogCustomImplForReadResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
            this.catalogCustom = _data["catalogCustom"] ? CatalogCustomResponse.fromJS(_data["catalogCustom"]) : <any>undefined;
            this.questionnaire = _data["questionnaire"] ? QuestionnaireResponse.fromJS(_data["questionnaire"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CatalogCustomImplForReadResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogCustomImplForReadResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        data["catalogCustom"] = this.catalogCustom ? this.catalogCustom.toJSON() : <any>undefined;
        data["questionnaire"] = this.questionnaire ? this.questionnaire.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICatalogCustomImplForReadResponse {
    id?: string | undefined;
    data?: { [key: string]: any; } | undefined;
    catalogCustom?: CatalogCustomResponse | undefined;
    questionnaire?: QuestionnaireResponse | undefined;
}

export class QuestionnaireResponse implements IQuestionnaireResponse {
    id?: string | undefined;
    creationDateTime?: moment.Moment | undefined;
    name?: string | undefined;
    customCode?: string | undefined;
    userCreator?: string | undefined;
    isActive!: boolean;
    sections?: QuestionnaireSectionResponse[] | undefined;

    constructor(data?: IQuestionnaireResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationDateTime = _data["creationDateTime"] ? moment(_data["creationDateTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.customCode = _data["customCode"];
            this.userCreator = _data["userCreator"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(QuestionnaireSectionResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuestionnaireResponse {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionnaireResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationDateTime"] = this.creationDateTime ? this.creationDateTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["customCode"] = this.customCode;
        data["userCreator"] = this.userCreator;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQuestionnaireResponse {
    id?: string | undefined;
    creationDateTime?: moment.Moment | undefined;
    name?: string | undefined;
    customCode?: string | undefined;
    userCreator?: string | undefined;
    isActive: boolean;
    sections?: QuestionnaireSectionResponse[] | undefined;
}

export class QuestionnaireSectionResponse implements IQuestionnaireSectionResponse {
    iconAF?: string | undefined;
    name?: string | undefined;
    order!: number;
    fields?: QuestionnaireFieldResponse[] | undefined;

    constructor(data?: IQuestionnaireSectionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iconAF = _data["iconAF"];
            this.name = _data["name"];
            this.order = _data["order"];
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(QuestionnaireFieldResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuestionnaireSectionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionnaireSectionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iconAF"] = this.iconAF;
        data["name"] = this.name;
        data["order"] = this.order;
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQuestionnaireSectionResponse {
    iconAF?: string | undefined;
    name?: string | undefined;
    order: number;
    fields?: QuestionnaireFieldResponse[] | undefined;
}

export class QuestionnaireFieldResponse implements IQuestionnaireFieldResponse {
    fieldControl!: QuestionnaireFieldControl;
    fieldControlDesc?: string | undefined;
    fieldName?: string | undefined;
    fieldSize?: number | undefined;
    fieldType!: QuestionnaireFieldType;
    fieldTypeDesc?: string | undefined;
    hasKeyFilter!: boolean;
    inputMask?: string | undefined;
    isRequired!: boolean;
    isRequiredDesc?: string | undefined;
    keyFilter?: string | undefined;
    name?: string | undefined;
    order!: number;
    options?: QuestionnaireFieldOptionResponse[] | undefined;
    catalogCustom?: QuestionnaireCatalogCustomResponse | undefined;
    customProperties?: QuestionnaireCustomPropertiesResponse | undefined;
    mustHaveOptions!: boolean;

    constructor(data?: IQuestionnaireFieldResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldControl = _data["fieldControl"];
            this.fieldControlDesc = _data["fieldControlDesc"];
            this.fieldName = _data["fieldName"];
            this.fieldSize = _data["fieldSize"];
            this.fieldType = _data["fieldType"];
            this.fieldTypeDesc = _data["fieldTypeDesc"];
            this.hasKeyFilter = _data["hasKeyFilter"];
            this.inputMask = _data["inputMask"];
            this.isRequired = _data["isRequired"];
            this.isRequiredDesc = _data["isRequiredDesc"];
            this.keyFilter = _data["keyFilter"];
            this.name = _data["name"];
            this.order = _data["order"];
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(QuestionnaireFieldOptionResponse.fromJS(item));
            }
            this.catalogCustom = _data["catalogCustom"] ? QuestionnaireCatalogCustomResponse.fromJS(_data["catalogCustom"]) : <any>undefined;
            this.customProperties = _data["customProperties"] ? QuestionnaireCustomPropertiesResponse.fromJS(_data["customProperties"]) : <any>undefined;
            this.mustHaveOptions = _data["mustHaveOptions"];
        }
    }

    static fromJS(data: any): QuestionnaireFieldResponse {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionnaireFieldResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldControl"] = this.fieldControl;
        data["fieldControlDesc"] = this.fieldControlDesc;
        data["fieldName"] = this.fieldName;
        data["fieldSize"] = this.fieldSize;
        data["fieldType"] = this.fieldType;
        data["fieldTypeDesc"] = this.fieldTypeDesc;
        data["hasKeyFilter"] = this.hasKeyFilter;
        data["inputMask"] = this.inputMask;
        data["isRequired"] = this.isRequired;
        data["isRequiredDesc"] = this.isRequiredDesc;
        data["keyFilter"] = this.keyFilter;
        data["name"] = this.name;
        data["order"] = this.order;
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        data["catalogCustom"] = this.catalogCustom ? this.catalogCustom.toJSON() : <any>undefined;
        data["customProperties"] = this.customProperties ? this.customProperties.toJSON() : <any>undefined;
        data["mustHaveOptions"] = this.mustHaveOptions;
        return data;
    }
}

export interface IQuestionnaireFieldResponse {
    fieldControl: QuestionnaireFieldControl;
    fieldControlDesc?: string | undefined;
    fieldName?: string | undefined;
    fieldSize?: number | undefined;
    fieldType: QuestionnaireFieldType;
    fieldTypeDesc?: string | undefined;
    hasKeyFilter: boolean;
    inputMask?: string | undefined;
    isRequired: boolean;
    isRequiredDesc?: string | undefined;
    keyFilter?: string | undefined;
    name?: string | undefined;
    order: number;
    options?: QuestionnaireFieldOptionResponse[] | undefined;
    catalogCustom?: QuestionnaireCatalogCustomResponse | undefined;
    customProperties?: QuestionnaireCustomPropertiesResponse | undefined;
    mustHaveOptions: boolean;
}

export enum QuestionnaireFieldControl {
    InputText = 10,
    DropDown = 11,
    Listbox = 12,
    RadioButton = 13,
    InputSwitch = 14,
    InputMask = 15,
    InputTextArea = 16,
    ListboxMultivalue = 21,
    Checkbox = 22,
    Multiselect = 23,
    CalendarBasic = 30,
    CalendarTime = 31,
    CalendarTimeOnly = 32,
    Spinner = 40,
    SpinnerFormatInput = 41,
    TextNumber = 45,
    GoogleAddress = 50,
    Autocomplete = 60,
    AutocompleteDynamic = 61,
}

export enum QuestionnaireFieldType {
    Boolean = 1,
    Text = 10,
    Multivalue = 20,
    Date = 30,
    DateTime = 31,
    Time = 32,
    Integer = 40,
    Decimal = 41,
    Currency = 43,
    GoogleAddress = 50,
    CatalogCustom = 60,
    User = 70,
}

export class QuestionnaireFieldOptionResponse implements IQuestionnaireFieldOptionResponse {
    description?: string | undefined;
    value!: number;

    constructor(data?: IQuestionnaireFieldOptionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): QuestionnaireFieldOptionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionnaireFieldOptionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["value"] = this.value;
        return data;
    }
}

export interface IQuestionnaireFieldOptionResponse {
    description?: string | undefined;
    value: number;
}

export class QuestionnaireCatalogCustomResponse implements IQuestionnaireCatalogCustomResponse {
    catalogCustom?: string | undefined;
    catalogCustomDesc?: string | undefined;
    fieldName?: string | undefined;

    constructor(data?: IQuestionnaireCatalogCustomResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.catalogCustom = _data["catalogCustom"];
            this.catalogCustomDesc = _data["catalogCustomDesc"];
            this.fieldName = _data["fieldName"];
        }
    }

    static fromJS(data: any): QuestionnaireCatalogCustomResponse {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionnaireCatalogCustomResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catalogCustom"] = this.catalogCustom;
        data["catalogCustomDesc"] = this.catalogCustomDesc;
        data["fieldName"] = this.fieldName;
        return data;
    }
}

export interface IQuestionnaireCatalogCustomResponse {
    catalogCustom?: string | undefined;
    catalogCustomDesc?: string | undefined;
    fieldName?: string | undefined;
}

export class QuestionnaireCustomPropertiesResponse implements IQuestionnaireCustomPropertiesResponse {
    currency?: string | undefined;
    locale?: string | undefined;
    maxValue?: number | undefined;
    minValue?: number | undefined;
    useGrouping!: boolean;

    constructor(data?: IQuestionnaireCustomPropertiesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currency = _data["currency"];
            this.locale = _data["locale"];
            this.maxValue = _data["maxValue"];
            this.minValue = _data["minValue"];
            this.useGrouping = _data["useGrouping"];
        }
    }

    static fromJS(data: any): QuestionnaireCustomPropertiesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionnaireCustomPropertiesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currency"] = this.currency;
        data["locale"] = this.locale;
        data["maxValue"] = this.maxValue;
        data["minValue"] = this.minValue;
        data["useGrouping"] = this.useGrouping;
        return data;
    }
}

export interface IQuestionnaireCustomPropertiesResponse {
    currency?: string | undefined;
    locale?: string | undefined;
    maxValue?: number | undefined;
    minValue?: number | undefined;
    useGrouping: boolean;
}

export class CatalogCustomImplGetForReadQuery implements ICatalogCustomImplGetForReadQuery {
    catalog?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICatalogCustomImplGetForReadQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.catalog = _data["catalog"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CatalogCustomImplGetForReadQuery {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogCustomImplGetForReadQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catalog"] = this.catalog;
        data["id"] = this.id;
        return data;
    }
}

export interface ICatalogCustomImplGetForReadQuery {
    catalog?: string | undefined;
    id?: string | undefined;
}

export class CatalogCustomImplForEditResponse implements ICatalogCustomImplForEditResponse {
    id?: string | undefined;
    data?: { [key: string]: any; } | undefined;
    catalogCustom?: CatalogCustomResponse | undefined;
    questionnaire?: QuestionnaireResponse | undefined;

    constructor(data?: ICatalogCustomImplForEditResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
            this.catalogCustom = _data["catalogCustom"] ? CatalogCustomResponse.fromJS(_data["catalogCustom"]) : <any>undefined;
            this.questionnaire = _data["questionnaire"] ? QuestionnaireResponse.fromJS(_data["questionnaire"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CatalogCustomImplForEditResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogCustomImplForEditResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        data["catalogCustom"] = this.catalogCustom ? this.catalogCustom.toJSON() : <any>undefined;
        data["questionnaire"] = this.questionnaire ? this.questionnaire.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICatalogCustomImplForEditResponse {
    id?: string | undefined;
    data?: { [key: string]: any; } | undefined;
    catalogCustom?: CatalogCustomResponse | undefined;
    questionnaire?: QuestionnaireResponse | undefined;
}

export class CatalogCustomImplGetForEditQuery implements ICatalogCustomImplGetForEditQuery {
    catalog?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICatalogCustomImplGetForEditQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.catalog = _data["catalog"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CatalogCustomImplGetForEditQuery {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogCustomImplGetForEditQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catalog"] = this.catalog;
        data["id"] = this.id;
        return data;
    }
}

export interface ICatalogCustomImplGetForEditQuery {
    catalog?: string | undefined;
    id?: string | undefined;
}

export class CatalogCustomImplCreateCommand implements ICatalogCustomImplCreateCommand {
    catalog?: string | undefined;
    data?: Data | undefined;

    constructor(data?: ICatalogCustomImplCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.catalog = _data["catalog"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): CatalogCustomImplCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogCustomImplCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catalog"] = this.catalog;
        data["data"] = this.data;
        return data;
    }
}

export interface ICatalogCustomImplCreateCommand {
    catalog?: string | undefined;
    data?: Data | undefined;
}

export class CatalogCustomImplUpdateCommand implements ICatalogCustomImplUpdateCommand {
    catalog?: string | undefined;
    id?: string | undefined;
    data?: Data2 | undefined;

    constructor(data?: ICatalogCustomImplUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.catalog = _data["catalog"];
            this.id = _data["id"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): CatalogCustomImplUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogCustomImplUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catalog"] = this.catalog;
        data["id"] = this.id;
        data["data"] = this.data;
        return data;
    }
}

export interface ICatalogCustomImplUpdateCommand {
    catalog?: string | undefined;
    id?: string | undefined;
    data?: Data2 | undefined;
}

export class CatalogCustomImplDeleteCommand implements ICatalogCustomImplDeleteCommand {
    catalog?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICatalogCustomImplDeleteCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.catalog = _data["catalog"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CatalogCustomImplDeleteCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogCustomImplDeleteCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catalog"] = this.catalog;
        data["id"] = this.id;
        return data;
    }
}

export interface ICatalogCustomImplDeleteCommand {
    catalog?: string | undefined;
    id?: string | undefined;
}

export class PagedResultDtoOfChangeLogForListResponse implements IPagedResultDtoOfChangeLogForListResponse {
    totalCount!: number;
    items?: ChangeLogForListResponse[] | undefined;

    constructor(data?: IPagedResultDtoOfChangeLogForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ChangeLogForListResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfChangeLogForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfChangeLogForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfChangeLogForListResponse {
    totalCount: number;
    items?: ChangeLogForListResponse[] | undefined;
}

export class ChangeLogForListResponse implements IChangeLogForListResponse {
    id?: number | undefined;
    user?: number | undefined;
    userDesc?: string | undefined;
    datetime?: moment.Moment | undefined;
    detail?: string | undefined;

    constructor(data?: IChangeLogForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user = _data["user"];
            this.userDesc = _data["userDesc"];
            this.datetime = _data["datetime"] ? moment(_data["datetime"].toString()) : <any>undefined;
            this.detail = _data["detail"];
        }
    }

    static fromJS(data: any): ChangeLogForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeLogForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user"] = this.user;
        data["userDesc"] = this.userDesc;
        data["datetime"] = this.datetime ? this.datetime.toISOString() : <any>undefined;
        data["detail"] = this.detail;
        return data;
    }
}

export interface IChangeLogForListResponse {
    id?: number | undefined;
    user?: number | undefined;
    userDesc?: string | undefined;
    datetime?: moment.Moment | undefined;
    detail?: string | undefined;
}

export class ChangeLogGetListQuery extends PageListByDto implements IChangeLogGetListQuery {
    table?: string | undefined;
    key?: string | undefined;

    constructor(data?: IChangeLogGetListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.table = _data["table"];
            this.key = _data["key"];
        }
    }

    static override fromJS(data: any): ChangeLogGetListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeLogGetListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["table"] = this.table;
        data["key"] = this.key;
        super.toJSON(data);
        return data;
    }
}

export interface IChangeLogGetListQuery extends IPageListByDto {
    table?: string | undefined;
    key?: string | undefined;
}

export class PagedResultDtoOfChatMessageListResponse implements IPagedResultDtoOfChatMessageListResponse {
    totalCount!: number;
    items?: ChatMessageListResponse[] | undefined;

    constructor(data?: IPagedResultDtoOfChatMessageListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ChatMessageListResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfChatMessageListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfChatMessageListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfChatMessageListResponse {
    totalCount: number;
    items?: ChatMessageListResponse[] | undefined;
}

export class ChatMessageListResponse implements IChatMessageListResponse {
    id!: number;
    targetUserId!: number;
    targetTenantId?: number | undefined;
    message?: string | undefined;
    creationTime!: moment.Moment;
    side!: ChatSide;
    readState!: ChatMessageReadState;

    constructor(data?: IChatMessageListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.targetUserId = _data["targetUserId"];
            this.targetTenantId = _data["targetTenantId"];
            this.message = _data["message"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.side = _data["side"];
            this.readState = _data["readState"];
        }
    }

    static fromJS(data: any): ChatMessageListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["targetUserId"] = this.targetUserId;
        data["targetTenantId"] = this.targetTenantId;
        data["message"] = this.message;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["side"] = this.side;
        data["readState"] = this.readState;
        return data;
    }
}

export interface IChatMessageListResponse {
    id: number;
    targetUserId: number;
    targetTenantId?: number | undefined;
    message?: string | undefined;
    creationTime: moment.Moment;
    side: ChatSide;
    readState: ChatMessageReadState;
}

export enum ChatSide {
    Sender = 1,
    Receiver = 2,
}

export enum ChatMessageReadState {
    Unread = 1,
    Read = 2,
}

export class ChatMessageGetListQuery implements IChatMessageGetListQuery {
    tenantId?: number | undefined;
    userId!: number;
    minMessageId?: number | undefined;

    constructor(data?: IChatMessageGetListQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.minMessageId = _data["minMessageId"];
        }
    }

    static fromJS(data: any): ChatMessageGetListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageGetListQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["minMessageId"] = this.minMessageId;
        return data;
    }
}

export interface IChatMessageGetListQuery {
    tenantId?: number | undefined;
    userId: number;
    minMessageId?: number | undefined;
}

export class ChatMessageMarkReadCommand implements IChatMessageMarkReadCommand {
    friendTenantId?: number | undefined;
    friendUserId!: number;

    constructor(data?: IChatMessageMarkReadCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.friendTenantId = _data["friendTenantId"];
            this.friendUserId = _data["friendUserId"];
        }
    }

    static fromJS(data: any): ChatMessageMarkReadCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageMarkReadCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friendTenantId"] = this.friendTenantId;
        data["friendUserId"] = this.friendUserId;
        return data;
    }
}

export interface IChatMessageMarkReadCommand {
    friendTenantId?: number | undefined;
    friendUserId: number;
}

export class PagedResultDtoOfChatRoomForListResponse implements IPagedResultDtoOfChatRoomForListResponse {
    totalCount!: number;
    items?: ChatRoomForListResponse[] | undefined;

    constructor(data?: IPagedResultDtoOfChatRoomForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ChatRoomForListResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfChatRoomForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfChatRoomForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfChatRoomForListResponse {
    totalCount: number;
    items?: ChatRoomForListResponse[] | undefined;
}

export class ChatRoomForListResponse implements IChatRoomForListResponse {
    id!: number;
    chatRoomId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    userCreatorDesc?: string | undefined;
    creationTime?: moment.Moment | undefined;

    constructor(data?: IChatRoomForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.chatRoomId = _data["chatRoomId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.userCreatorDesc = _data["userCreatorDesc"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ChatRoomForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ChatRoomForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["chatRoomId"] = this.chatRoomId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["userCreatorDesc"] = this.userCreatorDesc;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IChatRoomForListResponse {
    id: number;
    chatRoomId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    userCreatorDesc?: string | undefined;
    creationTime?: moment.Moment | undefined;
}

export class ChatRoomGetListQuery extends PageListByDto implements IChatRoomGetListQuery {

    constructor(data?: IChatRoomGetListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ChatRoomGetListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new ChatRoomGetListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IChatRoomGetListQuery extends IPageListByDto {
}

export class ChatRoomResponse implements IChatRoomResponse {
    id!: number;
    userCreator?: number | undefined;
    userCreatorDesc?: string | undefined;
    chatRoomId?: string | undefined;
    name?: string | undefined;
    creationTime?: moment.Moment | undefined;
    description?: string | undefined;

    constructor(data?: IChatRoomResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userCreator = _data["userCreator"];
            this.userCreatorDesc = _data["userCreatorDesc"];
            this.chatRoomId = _data["chatRoomId"];
            this.name = _data["name"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ChatRoomResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ChatRoomResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userCreator"] = this.userCreator;
        data["userCreatorDesc"] = this.userCreatorDesc;
        data["chatRoomId"] = this.chatRoomId;
        data["name"] = this.name;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["description"] = this.description;
        return data;
    }
}

export interface IChatRoomResponse {
    id: number;
    userCreator?: number | undefined;
    userCreatorDesc?: string | undefined;
    chatRoomId?: string | undefined;
    name?: string | undefined;
    creationTime?: moment.Moment | undefined;
    description?: string | undefined;
}

export class ChatRoomForEditResponse implements IChatRoomForEditResponse {
    id?: number | undefined;
    chatRoomId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    userCreator?: number | undefined;
    userCreatorDesc?: string | undefined;
    creationTime?: moment.Moment | undefined;

    constructor(data?: IChatRoomForEditResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.chatRoomId = _data["chatRoomId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.userCreator = _data["userCreator"];
            this.userCreatorDesc = _data["userCreatorDesc"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ChatRoomForEditResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ChatRoomForEditResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["chatRoomId"] = this.chatRoomId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["userCreator"] = this.userCreator;
        data["userCreatorDesc"] = this.userCreatorDesc;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IChatRoomForEditResponse {
    id?: number | undefined;
    chatRoomId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    userCreator?: number | undefined;
    userCreatorDesc?: string | undefined;
    creationTime?: moment.Moment | undefined;
}

export class ChatRoomGetForEditQuery implements IChatRoomGetForEditQuery {
    id?: number | undefined;

    constructor(data?: IChatRoomGetForEditQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ChatRoomGetForEditQuery {
        data = typeof data === 'object' ? data : {};
        let result = new ChatRoomGetForEditQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IChatRoomGetForEditQuery {
    id?: number | undefined;
}

export class ChatRoomGetOrCreateCommand implements IChatRoomGetOrCreateCommand {
    chatRoomId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: IChatRoomGetOrCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chatRoomId = _data["chatRoomId"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ChatRoomGetOrCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ChatRoomGetOrCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chatRoomId"] = this.chatRoomId;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IChatRoomGetOrCreateCommand {
    chatRoomId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
}

export class ChatRoomCreateCommand implements IChatRoomCreateCommand {
    chatRoomId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: IChatRoomCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chatRoomId = _data["chatRoomId"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ChatRoomCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ChatRoomCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chatRoomId"] = this.chatRoomId;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IChatRoomCreateCommand {
    chatRoomId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
}

export class ChatRoomUpdateCommand implements IChatRoomUpdateCommand {
    id!: number;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: IChatRoomUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ChatRoomUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ChatRoomUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IChatRoomUpdateCommand {
    id: number;
    name?: string | undefined;
    description?: string | undefined;
}

export class PagedResultDtoOfChatRoomChatForListResponse implements IPagedResultDtoOfChatRoomChatForListResponse {
    totalCount!: number;
    items?: ChatRoomChatForListResponse[] | undefined;

    constructor(data?: IPagedResultDtoOfChatRoomChatForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ChatRoomChatForListResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfChatRoomChatForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfChatRoomChatForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfChatRoomChatForListResponse {
    totalCount: number;
    items?: ChatRoomChatForListResponse[] | undefined;
}

export class ChatRoomChatForListResponse implements IChatRoomChatForListResponse {
    id!: number;
    chatRoom!: number;
    user?: number | undefined;
    userDesc?: string | undefined;
    creationTime?: moment.Moment | undefined;
    comment?: string | undefined;
    files?: ChatRoomChatFileResponse[] | undefined;

    constructor(data?: IChatRoomChatForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.chatRoom = _data["chatRoom"];
            this.user = _data["user"];
            this.userDesc = _data["userDesc"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.comment = _data["comment"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(ChatRoomChatFileResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChatRoomChatForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ChatRoomChatForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["chatRoom"] = this.chatRoom;
        data["user"] = this.user;
        data["userDesc"] = this.userDesc;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export interface IChatRoomChatForListResponse {
    id: number;
    chatRoom: number;
    user?: number | undefined;
    userDesc?: string | undefined;
    creationTime?: moment.Moment | undefined;
    comment?: string | undefined;
    files?: ChatRoomChatFileResponse[] | undefined;
}

export class ChatRoomChatFileResponse implements IChatRoomChatFileResponse {
    fileName?: string | undefined;
    fileExtension?: string | undefined;
    file?: string | undefined;

    constructor(data?: IChatRoomChatFileResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.fileExtension = _data["fileExtension"];
            this.file = _data["file"];
        }
    }

    static fromJS(data: any): ChatRoomChatFileResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ChatRoomChatFileResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileExtension"] = this.fileExtension;
        data["file"] = this.file;
        return data;
    }
}

export interface IChatRoomChatFileResponse {
    fileName?: string | undefined;
    fileExtension?: string | undefined;
    file?: string | undefined;
}

export class ChatRoomChatGetListQuery extends PageListByDto implements IChatRoomChatGetListQuery {
    chatRoom?: number | undefined;
    chatRoomId?: string | undefined;
    skip!: number;
    onlyFiles!: boolean;

    constructor(data?: IChatRoomChatGetListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.chatRoom = _data["chatRoom"];
            this.chatRoomId = _data["chatRoomId"];
            this.skip = _data["skip"];
            this.onlyFiles = _data["onlyFiles"];
        }
    }

    static override fromJS(data: any): ChatRoomChatGetListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new ChatRoomChatGetListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chatRoom"] = this.chatRoom;
        data["chatRoomId"] = this.chatRoomId;
        data["skip"] = this.skip;
        data["onlyFiles"] = this.onlyFiles;
        super.toJSON(data);
        return data;
    }
}

export interface IChatRoomChatGetListQuery extends IPageListByDto {
    chatRoom?: number | undefined;
    chatRoomId?: string | undefined;
    skip: number;
    onlyFiles: boolean;
}

export class ChatRoomChatResponse implements IChatRoomChatResponse {
    id!: number;
    chatRoom!: number;
    user?: number | undefined;
    userDesc?: string | undefined;
    creationTime?: moment.Moment | undefined;
    comment?: string | undefined;
    files?: ChatRoomChatFileResponse[] | undefined;

    constructor(data?: IChatRoomChatResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.chatRoom = _data["chatRoom"];
            this.user = _data["user"];
            this.userDesc = _data["userDesc"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.comment = _data["comment"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(ChatRoomChatFileResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChatRoomChatResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ChatRoomChatResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["chatRoom"] = this.chatRoom;
        data["user"] = this.user;
        data["userDesc"] = this.userDesc;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export interface IChatRoomChatResponse {
    id: number;
    chatRoom: number;
    user?: number | undefined;
    userDesc?: string | undefined;
    creationTime?: moment.Moment | undefined;
    comment?: string | undefined;
    files?: ChatRoomChatFileResponse[] | undefined;
}

export class ChatRoomChatCreateCommand implements IChatRoomChatCreateCommand {
    chatRoom!: number;
    comment?: string | undefined;
    taggedUsers?: number[] | undefined;
    files?: ChatRoomChatFileCreateCommand[] | undefined;

    constructor(data?: IChatRoomChatCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chatRoom = _data["chatRoom"];
            this.comment = _data["comment"];
            if (Array.isArray(_data["taggedUsers"])) {
                this.taggedUsers = [] as any;
                for (let item of _data["taggedUsers"])
                    this.taggedUsers!.push(item);
            }
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(ChatRoomChatFileCreateCommand.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChatRoomChatCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ChatRoomChatCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chatRoom"] = this.chatRoom;
        data["comment"] = this.comment;
        if (Array.isArray(this.taggedUsers)) {
            data["taggedUsers"] = [];
            for (let item of this.taggedUsers)
                data["taggedUsers"].push(item);
        }
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export interface IChatRoomChatCreateCommand {
    chatRoom: number;
    comment?: string | undefined;
    taggedUsers?: number[] | undefined;
    files?: ChatRoomChatFileCreateCommand[] | undefined;
}

export class ChatRoomChatFileCreateCommand implements IChatRoomChatFileCreateCommand {
    fileName?: string | undefined;
    fileExtension?: string | undefined;
    base64?: string | undefined;

    constructor(data?: IChatRoomChatFileCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.fileExtension = _data["fileExtension"];
            this.base64 = _data["base64"];
        }
    }

    static fromJS(data: any): ChatRoomChatFileCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ChatRoomChatFileCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileExtension"] = this.fileExtension;
        data["base64"] = this.base64;
        return data;
    }
}

export interface IChatRoomChatFileCreateCommand {
    fileName?: string | undefined;
    fileExtension?: string | undefined;
    base64?: string | undefined;
}

export class FileUploadResponse implements IFileUploadResponse {
    fileName?: string | undefined;
    fileSize!: number;
    tempFileName?: string | undefined;

    constructor(data?: IFileUploadResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.fileSize = _data["fileSize"];
            this.tempFileName = _data["tempFileName"];
        }
    }

    static fromJS(data: any): FileUploadResponse {
        data = typeof data === 'object' ? data : {};
        let result = new FileUploadResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileSize"] = this.fileSize;
        data["tempFileName"] = this.tempFileName;
        return data;
    }
}

export interface IFileUploadResponse {
    fileName?: string | undefined;
    fileSize: number;
    tempFileName?: string | undefined;
}

export class PagedResultDtoOfFriendshipListResponse implements IPagedResultDtoOfFriendshipListResponse {
    totalCount!: number;
    items?: FriendshipListResponse[] | undefined;

    constructor(data?: IPagedResultDtoOfFriendshipListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FriendshipListResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfFriendshipListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfFriendshipListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfFriendshipListResponse {
    totalCount: number;
    items?: FriendshipListResponse[] | undefined;
}

export class FriendshipListResponse implements IFriendshipListResponse {
    id!: number;
    friendUserId!: number;
    friendTenantId?: number | undefined;
    friendUserName?: string | undefined;
    friendTenancyName?: string | undefined;
    friendProfilePictureUrl?: string | undefined;
    unreadMessageCount!: number;
    isOnline!: boolean;
    state!: FriendshipState;

    constructor(data?: IFriendshipListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.friendUserId = _data["friendUserId"];
            this.friendTenantId = _data["friendTenantId"];
            this.friendUserName = _data["friendUserName"];
            this.friendTenancyName = _data["friendTenancyName"];
            this.friendProfilePictureUrl = _data["friendProfilePictureUrl"];
            this.unreadMessageCount = _data["unreadMessageCount"];
            this.isOnline = _data["isOnline"];
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): FriendshipListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new FriendshipListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["friendUserId"] = this.friendUserId;
        data["friendTenantId"] = this.friendTenantId;
        data["friendUserName"] = this.friendUserName;
        data["friendTenancyName"] = this.friendTenancyName;
        data["friendProfilePictureUrl"] = this.friendProfilePictureUrl;
        data["unreadMessageCount"] = this.unreadMessageCount;
        data["isOnline"] = this.isOnline;
        data["state"] = this.state;
        return data;
    }
}

export interface IFriendshipListResponse {
    id: number;
    friendUserId: number;
    friendTenantId?: number | undefined;
    friendUserName?: string | undefined;
    friendTenancyName?: string | undefined;
    friendProfilePictureUrl?: string | undefined;
    unreadMessageCount: number;
    isOnline: boolean;
    state: FriendshipState;
}

export enum FriendshipState {
    Pending = 1,
    Accepted = 2,
    Reject = 3,
    Blocked = 9,
}

export class FriendshipGetListQuery implements IFriendshipGetListQuery {

    constructor(data?: IFriendshipGetListQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): FriendshipGetListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new FriendshipGetListQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IFriendshipGetListQuery {
}

export class FriendshipCreateCommand implements IFriendshipCreateCommand {
    friendTenantId?: number | undefined;
    friendUserId!: number;

    constructor(data?: IFriendshipCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.friendTenantId = _data["friendTenantId"];
            this.friendUserId = _data["friendUserId"];
        }
    }

    static fromJS(data: any): FriendshipCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new FriendshipCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friendTenantId"] = this.friendTenantId;
        data["friendUserId"] = this.friendUserId;
        return data;
    }
}

export interface IFriendshipCreateCommand {
    friendTenantId?: number | undefined;
    friendUserId: number;
}

export class FriendshipBlockCommand implements IFriendshipBlockCommand {
    friendTenantId?: number | undefined;
    friendUserId!: number;

    constructor(data?: IFriendshipBlockCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.friendTenantId = _data["friendTenantId"];
            this.friendUserId = _data["friendUserId"];
        }
    }

    static fromJS(data: any): FriendshipBlockCommand {
        data = typeof data === 'object' ? data : {};
        let result = new FriendshipBlockCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friendTenantId"] = this.friendTenantId;
        data["friendUserId"] = this.friendUserId;
        return data;
    }
}

export interface IFriendshipBlockCommand {
    friendTenantId?: number | undefined;
    friendUserId: number;
}

export class FriendshipUnblockCommand implements IFriendshipUnblockCommand {
    friendTenantId?: number | undefined;
    friendUserId!: number;

    constructor(data?: IFriendshipUnblockCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.friendTenantId = _data["friendTenantId"];
            this.friendUserId = _data["friendUserId"];
        }
    }

    static fromJS(data: any): FriendshipUnblockCommand {
        data = typeof data === 'object' ? data : {};
        let result = new FriendshipUnblockCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friendTenantId"] = this.friendTenantId;
        data["friendUserId"] = this.friendUserId;
        return data;
    }
}

export interface IFriendshipUnblockCommand {
    friendTenantId?: number | undefined;
    friendUserId: number;
}

export class PagedResultDtoOfHelpForListResponse implements IPagedResultDtoOfHelpForListResponse {
    totalCount!: number;
    items?: HelpForListResponse[] | undefined;

    constructor(data?: IPagedResultDtoOfHelpForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(HelpForListResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfHelpForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfHelpForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfHelpForListResponse {
    totalCount: number;
    items?: HelpForListResponse[] | undefined;
}

export class HelpForListResponse implements IHelpForListResponse {
    id!: number;
    languageDesc?: string | undefined;
    key?: string | undefined;
    displayName?: string | undefined;
    isActive!: boolean;
    isActiveDesc?: string | undefined;

    constructor(data?: IHelpForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.languageDesc = _data["languageDesc"];
            this.key = _data["key"];
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
            this.isActiveDesc = _data["isActiveDesc"];
        }
    }

    static fromJS(data: any): HelpForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HelpForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["languageDesc"] = this.languageDesc;
        data["key"] = this.key;
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        data["isActiveDesc"] = this.isActiveDesc;
        return data;
    }
}

export interface IHelpForListResponse {
    id: number;
    languageDesc?: string | undefined;
    key?: string | undefined;
    displayName?: string | undefined;
    isActive: boolean;
    isActiveDesc?: string | undefined;
}

export class HelpGetListQuery extends PageListByDto implements IHelpGetListQuery {

    constructor(data?: IHelpGetListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): HelpGetListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new HelpGetListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IHelpGetListQuery extends IPageListByDto {
}

export class HelpResponse implements IHelpResponse {
    id?: number | undefined;
    language!: number;
    languageDesc?: string | undefined;
    key?: string | undefined;
    displayName?: string | undefined;
    body?: string | undefined;
    isActive!: boolean;

    constructor(data?: IHelpResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.language = _data["language"];
            this.languageDesc = _data["languageDesc"];
            this.key = _data["key"];
            this.displayName = _data["displayName"];
            this.body = _data["body"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): HelpResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HelpResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["language"] = this.language;
        data["languageDesc"] = this.languageDesc;
        data["key"] = this.key;
        data["displayName"] = this.displayName;
        data["body"] = this.body;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IHelpResponse {
    id?: number | undefined;
    language: number;
    languageDesc?: string | undefined;
    key?: string | undefined;
    displayName?: string | undefined;
    body?: string | undefined;
    isActive: boolean;
}

export class HelpForEditResponse implements IHelpForEditResponse {
    id?: number | undefined;
    language?: number | undefined;
    languageDesc?: string | undefined;
    key?: string | undefined;
    displayName?: string | undefined;
    body?: string | undefined;
    isActive!: boolean;
    languageCombo?: ComboboxItemDto[] | undefined;
    keyCombo?: ComboboxItemDto[] | undefined;

    constructor(data?: IHelpForEditResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.language = _data["language"];
            this.languageDesc = _data["languageDesc"];
            this.key = _data["key"];
            this.displayName = _data["displayName"];
            this.body = _data["body"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["languageCombo"])) {
                this.languageCombo = [] as any;
                for (let item of _data["languageCombo"])
                    this.languageCombo!.push(ComboboxItemDto.fromJS(item));
            }
            if (Array.isArray(_data["keyCombo"])) {
                this.keyCombo = [] as any;
                for (let item of _data["keyCombo"])
                    this.keyCombo!.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HelpForEditResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HelpForEditResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["language"] = this.language;
        data["languageDesc"] = this.languageDesc;
        data["key"] = this.key;
        data["displayName"] = this.displayName;
        data["body"] = this.body;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.languageCombo)) {
            data["languageCombo"] = [];
            for (let item of this.languageCombo)
                data["languageCombo"].push(item.toJSON());
        }
        if (Array.isArray(this.keyCombo)) {
            data["keyCombo"] = [];
            for (let item of this.keyCombo)
                data["keyCombo"].push(item.toJSON());
        }
        return data;
    }
}

export interface IHelpForEditResponse {
    id?: number | undefined;
    language?: number | undefined;
    languageDesc?: string | undefined;
    key?: string | undefined;
    displayName?: string | undefined;
    body?: string | undefined;
    isActive: boolean;
    languageCombo?: ComboboxItemDto[] | undefined;
    keyCombo?: ComboboxItemDto[] | undefined;
}

export class HelpGetForEditQuery implements IHelpGetForEditQuery {
    id?: number | undefined;

    constructor(data?: IHelpGetForEditQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): HelpGetForEditQuery {
        data = typeof data === 'object' ? data : {};
        let result = new HelpGetForEditQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IHelpGetForEditQuery {
    id?: number | undefined;
}

export class HelpCreateCommand implements IHelpCreateCommand {
    language!: number;
    key?: string | undefined;
    displayName?: string | undefined;
    body?: string | undefined;
    isActive!: boolean;

    constructor(data?: IHelpCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.language = _data["language"];
            this.key = _data["key"];
            this.displayName = _data["displayName"];
            this.body = _data["body"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): HelpCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new HelpCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language;
        data["key"] = this.key;
        data["displayName"] = this.displayName;
        data["body"] = this.body;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IHelpCreateCommand {
    language: number;
    key?: string | undefined;
    displayName?: string | undefined;
    body?: string | undefined;
    isActive: boolean;
}

export class HelpUpdateCommand implements IHelpUpdateCommand {
    id!: number;
    language!: number;
    key?: string | undefined;
    displayName?: string | undefined;
    body?: string | undefined;
    isActive!: boolean;

    constructor(data?: IHelpUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.language = _data["language"];
            this.key = _data["key"];
            this.displayName = _data["displayName"];
            this.body = _data["body"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): HelpUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new HelpUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["language"] = this.language;
        data["key"] = this.key;
        data["displayName"] = this.displayName;
        data["body"] = this.body;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IHelpUpdateCommand {
    id: number;
    language: number;
    key?: string | undefined;
    displayName?: string | undefined;
    body?: string | undefined;
    isActive: boolean;
}

export class HostSettingsForEditResponse implements IHostSettingsForEditResponse {
    webSiteRootAddress?: string | undefined;
    passwordUseDefaultConfiguration!: boolean;
    passwordComplexity?: HostSettingsPasswordComplexityResponse | undefined;
    passwordComplexityDefault?: HostSettingsPasswordComplexityResponse | undefined;
    enableUserBlocking!: boolean;
    failedAttemptsToBlockUser!: number;
    userBlockingDuration!: number;
    enableTwoFactorLogin!: boolean;
    enableMailVerification!: boolean;
    enableSMSVerification!: boolean;
    enableBrowserRemenberMe!: boolean;
    mailSMTPSenderDefault?: string | undefined;
    mailSMTPSenderDefaultDisplayName?: string | undefined;
    mailSMTPHost?: string | undefined;
    mailSMTPPort?: number | undefined;
    mailEnableSSL!: boolean;
    mailUseDefaultCredentials!: boolean;
    mailDomainName?: string | undefined;
    mailUserName?: string | undefined;
    mailUserPassword?: string | undefined;
    emailSendMethod!: EmailSendMethod;
    grpcEmail?: HostGrpcEmailResponse | undefined;

    constructor(data?: IHostSettingsForEditResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.webSiteRootAddress = _data["webSiteRootAddress"];
            this.passwordUseDefaultConfiguration = _data["passwordUseDefaultConfiguration"];
            this.passwordComplexity = _data["passwordComplexity"] ? HostSettingsPasswordComplexityResponse.fromJS(_data["passwordComplexity"]) : <any>undefined;
            this.passwordComplexityDefault = _data["passwordComplexityDefault"] ? HostSettingsPasswordComplexityResponse.fromJS(_data["passwordComplexityDefault"]) : <any>undefined;
            this.enableUserBlocking = _data["enableUserBlocking"];
            this.failedAttemptsToBlockUser = _data["failedAttemptsToBlockUser"];
            this.userBlockingDuration = _data["userBlockingDuration"];
            this.enableTwoFactorLogin = _data["enableTwoFactorLogin"];
            this.enableMailVerification = _data["enableMailVerification"];
            this.enableSMSVerification = _data["enableSMSVerification"];
            this.enableBrowserRemenberMe = _data["enableBrowserRemenberMe"];
            this.mailSMTPSenderDefault = _data["mailSMTPSenderDefault"];
            this.mailSMTPSenderDefaultDisplayName = _data["mailSMTPSenderDefaultDisplayName"];
            this.mailSMTPHost = _data["mailSMTPHost"];
            this.mailSMTPPort = _data["mailSMTPPort"];
            this.mailEnableSSL = _data["mailEnableSSL"];
            this.mailUseDefaultCredentials = _data["mailUseDefaultCredentials"];
            this.mailDomainName = _data["mailDomainName"];
            this.mailUserName = _data["mailUserName"];
            this.mailUserPassword = _data["mailUserPassword"];
            this.emailSendMethod = _data["emailSendMethod"];
            this.grpcEmail = _data["grpcEmail"] ? HostGrpcEmailResponse.fromJS(_data["grpcEmail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostSettingsForEditResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsForEditResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webSiteRootAddress"] = this.webSiteRootAddress;
        data["passwordUseDefaultConfiguration"] = this.passwordUseDefaultConfiguration;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["passwordComplexityDefault"] = this.passwordComplexityDefault ? this.passwordComplexityDefault.toJSON() : <any>undefined;
        data["enableUserBlocking"] = this.enableUserBlocking;
        data["failedAttemptsToBlockUser"] = this.failedAttemptsToBlockUser;
        data["userBlockingDuration"] = this.userBlockingDuration;
        data["enableTwoFactorLogin"] = this.enableTwoFactorLogin;
        data["enableMailVerification"] = this.enableMailVerification;
        data["enableSMSVerification"] = this.enableSMSVerification;
        data["enableBrowserRemenberMe"] = this.enableBrowserRemenberMe;
        data["mailSMTPSenderDefault"] = this.mailSMTPSenderDefault;
        data["mailSMTPSenderDefaultDisplayName"] = this.mailSMTPSenderDefaultDisplayName;
        data["mailSMTPHost"] = this.mailSMTPHost;
        data["mailSMTPPort"] = this.mailSMTPPort;
        data["mailEnableSSL"] = this.mailEnableSSL;
        data["mailUseDefaultCredentials"] = this.mailUseDefaultCredentials;
        data["mailDomainName"] = this.mailDomainName;
        data["mailUserName"] = this.mailUserName;
        data["mailUserPassword"] = this.mailUserPassword;
        data["emailSendMethod"] = this.emailSendMethod;
        data["grpcEmail"] = this.grpcEmail ? this.grpcEmail.toJSON() : <any>undefined;
        return data;
    }
}

export interface IHostSettingsForEditResponse {
    webSiteRootAddress?: string | undefined;
    passwordUseDefaultConfiguration: boolean;
    passwordComplexity?: HostSettingsPasswordComplexityResponse | undefined;
    passwordComplexityDefault?: HostSettingsPasswordComplexityResponse | undefined;
    enableUserBlocking: boolean;
    failedAttemptsToBlockUser: number;
    userBlockingDuration: number;
    enableTwoFactorLogin: boolean;
    enableMailVerification: boolean;
    enableSMSVerification: boolean;
    enableBrowserRemenberMe: boolean;
    mailSMTPSenderDefault?: string | undefined;
    mailSMTPSenderDefaultDisplayName?: string | undefined;
    mailSMTPHost?: string | undefined;
    mailSMTPPort?: number | undefined;
    mailEnableSSL: boolean;
    mailUseDefaultCredentials: boolean;
    mailDomainName?: string | undefined;
    mailUserName?: string | undefined;
    mailUserPassword?: string | undefined;
    emailSendMethod: EmailSendMethod;
    grpcEmail?: HostGrpcEmailResponse | undefined;
}

export class HostSettingsPasswordComplexityResponse implements IHostSettingsPasswordComplexityResponse {
    minimumLength!: number;
    maximumLength!: number;
    useNumbers!: boolean;
    useUppercase!: boolean;
    useLowercase!: boolean;
    usePunctuationSymbols!: boolean;

    constructor(data?: IHostSettingsPasswordComplexityResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.minimumLength = _data["minimumLength"];
            this.maximumLength = _data["maximumLength"];
            this.useNumbers = _data["useNumbers"];
            this.useUppercase = _data["useUppercase"];
            this.useLowercase = _data["useLowercase"];
            this.usePunctuationSymbols = _data["usePunctuationSymbols"];
        }
    }

    static fromJS(data: any): HostSettingsPasswordComplexityResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsPasswordComplexityResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minimumLength"] = this.minimumLength;
        data["maximumLength"] = this.maximumLength;
        data["useNumbers"] = this.useNumbers;
        data["useUppercase"] = this.useUppercase;
        data["useLowercase"] = this.useLowercase;
        data["usePunctuationSymbols"] = this.usePunctuationSymbols;
        return data;
    }
}

export interface IHostSettingsPasswordComplexityResponse {
    minimumLength: number;
    maximumLength: number;
    useNumbers: boolean;
    useUppercase: boolean;
    useLowercase: boolean;
    usePunctuationSymbols: boolean;
}

export enum EmailSendMethod {
    Normal = 0,
    Grpc = 1,
}

export class HostGrpcEmailResponse implements IHostGrpcEmailResponse {
    sendConfiguration!: boolean;
    tenancyName?: string | undefined;
    userName?: string | undefined;
    password?: string | undefined;

    constructor(data?: IHostGrpcEmailResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sendConfiguration = _data["sendConfiguration"];
            this.tenancyName = _data["tenancyName"];
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): HostGrpcEmailResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HostGrpcEmailResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sendConfiguration"] = this.sendConfiguration;
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data;
    }
}

export interface IHostGrpcEmailResponse {
    sendConfiguration: boolean;
    tenancyName?: string | undefined;
    userName?: string | undefined;
    password?: string | undefined;
}

export class HostSettingsGetForEditQuery implements IHostSettingsGetForEditQuery {

    constructor(data?: IHostSettingsGetForEditQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): HostSettingsGetForEditQuery {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsGetForEditQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IHostSettingsGetForEditQuery {
}

export class HostSettingsUpdateCommand implements IHostSettingsUpdateCommand {
    webSiteRootAddress?: string | undefined;
    passwordUseDefaultConfiguration!: boolean;
    passwordComplexity?: HostSettingsPasswordComplexityCommand | undefined;
    enableUserBlocking!: boolean;
    failedAttemptsToBlockUser!: number;
    userBlockingDuration!: number;
    enableTwoFactorLogin!: boolean;
    enableMailVerification!: boolean;
    enableSMSVerification!: boolean;
    enableBrowserRemenberMe!: boolean;
    mailSMTPSenderDefault?: string | undefined;
    mailSMTPSenderDefaultDisplayName?: string | undefined;
    mailSMTPHost?: string | undefined;
    mailSMTPPort?: number | undefined;
    mailEnableSSL!: boolean;
    mailUseDefaultCredentials!: boolean;
    mailDomainName?: string | undefined;
    mailUserName?: string | undefined;
    mailUserPassword?: string | undefined;
    grpcEmail?: HostGrpcEmailCommand | undefined;

    constructor(data?: IHostSettingsUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.webSiteRootAddress = _data["webSiteRootAddress"];
            this.passwordUseDefaultConfiguration = _data["passwordUseDefaultConfiguration"];
            this.passwordComplexity = _data["passwordComplexity"] ? HostSettingsPasswordComplexityCommand.fromJS(_data["passwordComplexity"]) : <any>undefined;
            this.enableUserBlocking = _data["enableUserBlocking"];
            this.failedAttemptsToBlockUser = _data["failedAttemptsToBlockUser"];
            this.userBlockingDuration = _data["userBlockingDuration"];
            this.enableTwoFactorLogin = _data["enableTwoFactorLogin"];
            this.enableMailVerification = _data["enableMailVerification"];
            this.enableSMSVerification = _data["enableSMSVerification"];
            this.enableBrowserRemenberMe = _data["enableBrowserRemenberMe"];
            this.mailSMTPSenderDefault = _data["mailSMTPSenderDefault"];
            this.mailSMTPSenderDefaultDisplayName = _data["mailSMTPSenderDefaultDisplayName"];
            this.mailSMTPHost = _data["mailSMTPHost"];
            this.mailSMTPPort = _data["mailSMTPPort"];
            this.mailEnableSSL = _data["mailEnableSSL"];
            this.mailUseDefaultCredentials = _data["mailUseDefaultCredentials"];
            this.mailDomainName = _data["mailDomainName"];
            this.mailUserName = _data["mailUserName"];
            this.mailUserPassword = _data["mailUserPassword"];
            this.grpcEmail = _data["grpcEmail"] ? HostGrpcEmailCommand.fromJS(_data["grpcEmail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostSettingsUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webSiteRootAddress"] = this.webSiteRootAddress;
        data["passwordUseDefaultConfiguration"] = this.passwordUseDefaultConfiguration;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["enableUserBlocking"] = this.enableUserBlocking;
        data["failedAttemptsToBlockUser"] = this.failedAttemptsToBlockUser;
        data["userBlockingDuration"] = this.userBlockingDuration;
        data["enableTwoFactorLogin"] = this.enableTwoFactorLogin;
        data["enableMailVerification"] = this.enableMailVerification;
        data["enableSMSVerification"] = this.enableSMSVerification;
        data["enableBrowserRemenberMe"] = this.enableBrowserRemenberMe;
        data["mailSMTPSenderDefault"] = this.mailSMTPSenderDefault;
        data["mailSMTPSenderDefaultDisplayName"] = this.mailSMTPSenderDefaultDisplayName;
        data["mailSMTPHost"] = this.mailSMTPHost;
        data["mailSMTPPort"] = this.mailSMTPPort;
        data["mailEnableSSL"] = this.mailEnableSSL;
        data["mailUseDefaultCredentials"] = this.mailUseDefaultCredentials;
        data["mailDomainName"] = this.mailDomainName;
        data["mailUserName"] = this.mailUserName;
        data["mailUserPassword"] = this.mailUserPassword;
        data["grpcEmail"] = this.grpcEmail ? this.grpcEmail.toJSON() : <any>undefined;
        return data;
    }
}

export interface IHostSettingsUpdateCommand {
    webSiteRootAddress?: string | undefined;
    passwordUseDefaultConfiguration: boolean;
    passwordComplexity?: HostSettingsPasswordComplexityCommand | undefined;
    enableUserBlocking: boolean;
    failedAttemptsToBlockUser: number;
    userBlockingDuration: number;
    enableTwoFactorLogin: boolean;
    enableMailVerification: boolean;
    enableSMSVerification: boolean;
    enableBrowserRemenberMe: boolean;
    mailSMTPSenderDefault?: string | undefined;
    mailSMTPSenderDefaultDisplayName?: string | undefined;
    mailSMTPHost?: string | undefined;
    mailSMTPPort?: number | undefined;
    mailEnableSSL: boolean;
    mailUseDefaultCredentials: boolean;
    mailDomainName?: string | undefined;
    mailUserName?: string | undefined;
    mailUserPassword?: string | undefined;
    grpcEmail?: HostGrpcEmailCommand | undefined;
}

export class HostSettingsPasswordComplexityCommand implements IHostSettingsPasswordComplexityCommand {
    minimumLength!: number;
    maximumLength!: number;
    useNumbers!: boolean;
    useUppercase!: boolean;
    useLowercase!: boolean;
    usePunctuationSymbols!: boolean;

    constructor(data?: IHostSettingsPasswordComplexityCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.minimumLength = _data["minimumLength"];
            this.maximumLength = _data["maximumLength"];
            this.useNumbers = _data["useNumbers"];
            this.useUppercase = _data["useUppercase"];
            this.useLowercase = _data["useLowercase"];
            this.usePunctuationSymbols = _data["usePunctuationSymbols"];
        }
    }

    static fromJS(data: any): HostSettingsPasswordComplexityCommand {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsPasswordComplexityCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minimumLength"] = this.minimumLength;
        data["maximumLength"] = this.maximumLength;
        data["useNumbers"] = this.useNumbers;
        data["useUppercase"] = this.useUppercase;
        data["useLowercase"] = this.useLowercase;
        data["usePunctuationSymbols"] = this.usePunctuationSymbols;
        return data;
    }
}

export interface IHostSettingsPasswordComplexityCommand {
    minimumLength: number;
    maximumLength: number;
    useNumbers: boolean;
    useUppercase: boolean;
    useLowercase: boolean;
    usePunctuationSymbols: boolean;
}

export class HostGrpcEmailCommand implements IHostGrpcEmailCommand {
    tenancyName?: string | undefined;
    userName?: string | undefined;
    password?: string | undefined;

    constructor(data?: IHostGrpcEmailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): HostGrpcEmailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new HostGrpcEmailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data;
    }
}

export interface IHostGrpcEmailCommand {
    tenancyName?: string | undefined;
    userName?: string | undefined;
    password?: string | undefined;
}

export class HostSettingsSendTestEmailCommand implements IHostSettingsSendTestEmailCommand {
    emailAddress?: string | undefined;

    constructor(data?: IHostSettingsSendTestEmailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): HostSettingsSendTestEmailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsSendTestEmailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface IHostSettingsSendTestEmailCommand {
    emailAddress?: string | undefined;
}

export class PagedResultDtoOfLanguageForListResponse implements IPagedResultDtoOfLanguageForListResponse {
    totalCount!: number;
    items?: LanguageForListResponse[] | undefined;

    constructor(data?: IPagedResultDtoOfLanguageForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LanguageForListResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLanguageForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLanguageForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfLanguageForListResponse {
    totalCount: number;
    items?: LanguageForListResponse[] | undefined;
}

export class LanguageForListResponse implements ILanguageForListResponse {
    id?: number | undefined;
    name?: string | undefined;
    displayName?: string | undefined;
    isActive!: boolean;
    isActiveDesc?: string | undefined;

    constructor(data?: ILanguageForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
            this.isActiveDesc = _data["isActiveDesc"];
        }
    }

    static fromJS(data: any): LanguageForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        data["isActiveDesc"] = this.isActiveDesc;
        return data;
    }
}

export interface ILanguageForListResponse {
    id?: number | undefined;
    name?: string | undefined;
    displayName?: string | undefined;
    isActive: boolean;
    isActiveDesc?: string | undefined;
}

export class LanguageGetListQuery extends PageListByDto implements ILanguageGetListQuery {

    constructor(data?: ILanguageGetListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): LanguageGetListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageGetListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ILanguageGetListQuery extends IPageListByDto {
}

export class LanguageResponse implements ILanguageResponse {
    id?: number | undefined;
    name?: string | undefined;
    displayName?: string | undefined;
    isActive!: boolean;

    constructor(data?: ILanguageResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): LanguageResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ILanguageResponse {
    id?: number | undefined;
    name?: string | undefined;
    displayName?: string | undefined;
    isActive: boolean;
}

export class LanguageForEditResponse implements ILanguageForEditResponse {
    id?: number | undefined;
    name?: string | undefined;
    displayName?: string | undefined;
    isActive!: boolean;
    languageCombo?: ComboboxItemDto[] | undefined;

    constructor(data?: ILanguageForEditResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["languageCombo"])) {
                this.languageCombo = [] as any;
                for (let item of _data["languageCombo"])
                    this.languageCombo!.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LanguageForEditResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageForEditResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.languageCombo)) {
            data["languageCombo"] = [];
            for (let item of this.languageCombo)
                data["languageCombo"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILanguageForEditResponse {
    id?: number | undefined;
    name?: string | undefined;
    displayName?: string | undefined;
    isActive: boolean;
    languageCombo?: ComboboxItemDto[] | undefined;
}

export class LanguageGetForEditQuery implements ILanguageGetForEditQuery {
    id?: number | undefined;

    constructor(data?: ILanguageGetForEditQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LanguageGetForEditQuery {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageGetForEditQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ILanguageGetForEditQuery {
    id?: number | undefined;
}

export class LanguageCreateCommand implements ILanguageCreateCommand {
    name?: string | undefined;
    displayName?: string | undefined;
    isActive!: boolean;

    constructor(data?: ILanguageCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): LanguageCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ILanguageCreateCommand {
    name?: string | undefined;
    displayName?: string | undefined;
    isActive: boolean;
}

export class LanguageUpdateCommand implements ILanguageUpdateCommand {
    id!: number;
    name?: string | undefined;
    displayName?: string | undefined;
    isActive!: boolean;

    constructor(data?: ILanguageUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): LanguageUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ILanguageUpdateCommand {
    id: number;
    name?: string | undefined;
    displayName?: string | undefined;
    isActive: boolean;
}

export class PagedResultDtoOfLanguageTextForListResponse implements IPagedResultDtoOfLanguageTextForListResponse {
    totalCount!: number;
    items?: LanguageTextForListResponse[] | undefined;

    constructor(data?: IPagedResultDtoOfLanguageTextForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LanguageTextForListResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLanguageTextForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLanguageTextForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfLanguageTextForListResponse {
    totalCount: number;
    items?: LanguageTextForListResponse[] | undefined;
}

export class LanguageTextForListResponse implements ILanguageTextForListResponse {
    id?: number | undefined;
    languageId?: number | undefined;
    key?: string | undefined;
    value?: string | undefined;

    constructor(data?: ILanguageTextForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.languageId = _data["languageId"];
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): LanguageTextForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["languageId"] = this.languageId;
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface ILanguageTextForListResponse {
    id?: number | undefined;
    languageId?: number | undefined;
    key?: string | undefined;
    value?: string | undefined;
}

export class LanguageTextGetListQuery extends PageListByDto implements ILanguageTextGetListQuery {
    languageId?: number | undefined;

    constructor(data?: ILanguageTextGetListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.languageId = _data["languageId"];
        }
    }

    static override fromJS(data: any): LanguageTextGetListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextGetListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageId"] = this.languageId;
        super.toJSON(data);
        return data;
    }
}

export interface ILanguageTextGetListQuery extends IPageListByDto {
    languageId?: number | undefined;
}

export class LanguageTextResponse implements ILanguageTextResponse {
    id?: number | undefined;
    languageId?: number | undefined;
    key?: string | undefined;
    value?: string | undefined;

    constructor(data?: ILanguageTextResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.languageId = _data["languageId"];
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): LanguageTextResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["languageId"] = this.languageId;
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface ILanguageTextResponse {
    id?: number | undefined;
    languageId?: number | undefined;
    key?: string | undefined;
    value?: string | undefined;
}

export class LanguageTextForEditResponse implements ILanguageTextForEditResponse {
    id?: number | undefined;
    languageId?: number | undefined;
    languageDesc?: string | undefined;
    key?: string | undefined;
    value?: string | undefined;

    constructor(data?: ILanguageTextForEditResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.languageId = _data["languageId"];
            this.languageDesc = _data["languageDesc"];
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): LanguageTextForEditResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextForEditResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["languageId"] = this.languageId;
        data["languageDesc"] = this.languageDesc;
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface ILanguageTextForEditResponse {
    id?: number | undefined;
    languageId?: number | undefined;
    languageDesc?: string | undefined;
    key?: string | undefined;
    value?: string | undefined;
}

export class LanguageTextGetForEditQuery implements ILanguageTextGetForEditQuery {
    id?: number | undefined;

    constructor(data?: ILanguageTextGetForEditQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LanguageTextGetForEditQuery {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextGetForEditQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ILanguageTextGetForEditQuery {
    id?: number | undefined;
}

export class LanguageTextUpdateCommand implements ILanguageTextUpdateCommand {
    id?: number | undefined;
    languageId!: number;
    key?: string | undefined;
    value?: string | undefined;

    constructor(data?: ILanguageTextUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.languageId = _data["languageId"];
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): LanguageTextUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["languageId"] = this.languageId;
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface ILanguageTextUpdateCommand {
    id?: number | undefined;
    languageId: number;
    key?: string | undefined;
    value?: string | undefined;
}

export class PagedResultDtoOfMailGroupListResponse implements IPagedResultDtoOfMailGroupListResponse {
    totalCount!: number;
    items?: MailGroupListResponse[] | undefined;

    constructor(data?: IPagedResultDtoOfMailGroupListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MailGroupListResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMailGroupListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMailGroupListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMailGroupListResponse {
    totalCount: number;
    items?: MailGroupListResponse[] | undefined;
}

export class MailGroupListResponse implements IMailGroupListResponse {
    id!: number;
    displayName?: string | undefined;
    isSelected?: boolean | undefined;

    constructor(data?: IMailGroupListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.isSelected = _data["isSelected"];
        }
    }

    static fromJS(data: any): MailGroupListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MailGroupListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["isSelected"] = this.isSelected;
        return data;
    }
}

export interface IMailGroupListResponse {
    id: number;
    displayName?: string | undefined;
    isSelected?: boolean | undefined;
}

export class MailGroupGetListQuery extends PageListByDto implements IMailGroupGetListQuery {

    constructor(data?: IMailGroupGetListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): MailGroupGetListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new MailGroupGetListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IMailGroupGetListQuery extends IPageListByDto {
}

export class MailGroupCreateCommand implements IMailGroupCreateCommand {
    displayName?: string | undefined;
    header?: string | undefined;
    footer?: string | undefined;

    constructor(data?: IMailGroupCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.header = _data["header"];
            this.footer = _data["footer"];
        }
    }

    static fromJS(data: any): MailGroupCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MailGroupCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["header"] = this.header;
        data["footer"] = this.footer;
        return data;
    }
}

export interface IMailGroupCreateCommand {
    displayName?: string | undefined;
    header?: string | undefined;
    footer?: string | undefined;
}

export class MailGroupUpdateCommand implements IMailGroupUpdateCommand {
    id!: number;
    displayName?: string | undefined;
    header?: string | undefined;
    footer?: string | undefined;

    constructor(data?: IMailGroupUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.header = _data["header"];
            this.footer = _data["footer"];
        }
    }

    static fromJS(data: any): MailGroupUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MailGroupUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["header"] = this.header;
        data["footer"] = this.footer;
        return data;
    }
}

export interface IMailGroupUpdateCommand {
    id: number;
    displayName?: string | undefined;
    header?: string | undefined;
    footer?: string | undefined;
}

export class MailGroupForEditResponse implements IMailGroupForEditResponse {
    id!: number;
    displayName?: string | undefined;
    header?: string | undefined;
    footer?: string | undefined;

    constructor(data?: IMailGroupForEditResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.header = _data["header"];
            this.footer = _data["footer"];
        }
    }

    static fromJS(data: any): MailGroupForEditResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MailGroupForEditResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["header"] = this.header;
        data["footer"] = this.footer;
        return data;
    }
}

export interface IMailGroupForEditResponse {
    id: number;
    displayName?: string | undefined;
    header?: string | undefined;
    footer?: string | undefined;
}

export class MailGroupGetForEditQuery implements IMailGroupGetForEditQuery {
    id!: number;

    constructor(data?: IMailGroupGetForEditQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MailGroupGetForEditQuery {
        data = typeof data === 'object' ? data : {};
        let result = new MailGroupGetForEditQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IMailGroupGetForEditQuery {
    id: number;
}

export class MailGroupCopyCommand implements IMailGroupCopyCommand {
    id!: number;
    displayName?: string | undefined;

    constructor(data?: IMailGroupCopyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): MailGroupCopyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MailGroupCopyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IMailGroupCopyCommand {
    id: number;
    displayName?: string | undefined;
}

export class MailGroupCheckCommand implements IMailGroupCheckCommand {
    id!: number;

    constructor(data?: IMailGroupCheckCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MailGroupCheckCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MailGroupCheckCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IMailGroupCheckCommand {
    id: number;
}

export class MailGroupUnCheckCommand implements IMailGroupUnCheckCommand {
    id!: number;

    constructor(data?: IMailGroupUnCheckCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MailGroupUnCheckCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MailGroupUnCheckCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IMailGroupUnCheckCommand {
    id: number;
}

export class PagedResultDtoOfMailTemplateListResponse implements IPagedResultDtoOfMailTemplateListResponse {
    totalCount!: number;
    items?: MailTemplateListResponse[] | undefined;

    constructor(data?: IPagedResultDtoOfMailTemplateListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MailTemplateListResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMailTemplateListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMailTemplateListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMailTemplateListResponse {
    totalCount: number;
    items?: MailTemplateListResponse[] | undefined;
}

export class MailTemplateListResponse implements IMailTemplateListResponse {
    id!: number;
    mailKeyDesc?: string | undefined;
    displayName?: string | undefined;

    constructor(data?: IMailTemplateListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.mailKeyDesc = _data["mailKeyDesc"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): MailTemplateListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MailTemplateListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["mailKeyDesc"] = this.mailKeyDesc;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IMailTemplateListResponse {
    id: number;
    mailKeyDesc?: string | undefined;
    displayName?: string | undefined;
}

export class MailTemplateGetListQuery extends PageListByDto implements IMailTemplateGetListQuery {
    mailGroup!: number;

    constructor(data?: IMailTemplateGetListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.mailGroup = _data["mailGroup"];
        }
    }

    static override fromJS(data: any): MailTemplateGetListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new MailTemplateGetListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mailGroup"] = this.mailGroup;
        super.toJSON(data);
        return data;
    }
}

export interface IMailTemplateGetListQuery extends IPageListByDto {
    mailGroup: number;
}

export class MailTemplateCreateCommand implements IMailTemplateCreateCommand {
    mailGroup?: number | undefined;
    mailKey?: string | undefined;
    displayName?: string | undefined;
    sendTo?: string | undefined;
    copyTo?: string | undefined;
    blindCopyTo?: string | undefined;
    subject?: string | undefined;
    body?: string | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IMailTemplateCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mailGroup = _data["mailGroup"];
            this.mailKey = _data["mailKey"];
            this.displayName = _data["displayName"];
            this.sendTo = _data["sendTo"];
            this.copyTo = _data["copyTo"];
            this.blindCopyTo = _data["blindCopyTo"];
            this.subject = _data["subject"];
            this.body = _data["body"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): MailTemplateCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MailTemplateCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mailGroup"] = this.mailGroup;
        data["mailKey"] = this.mailKey;
        data["displayName"] = this.displayName;
        data["sendTo"] = this.sendTo;
        data["copyTo"] = this.copyTo;
        data["blindCopyTo"] = this.blindCopyTo;
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IMailTemplateCreateCommand {
    mailGroup?: number | undefined;
    mailKey?: string | undefined;
    displayName?: string | undefined;
    sendTo?: string | undefined;
    copyTo?: string | undefined;
    blindCopyTo?: string | undefined;
    subject?: string | undefined;
    body?: string | undefined;
    isActive?: boolean | undefined;
}

export class MailTemplateUpdateCommand implements IMailTemplateUpdateCommand {
    id!: number;
    mailGroup?: number | undefined;
    mailKey?: string | undefined;
    displayName?: string | undefined;
    sendTo?: string | undefined;
    copyTo?: string | undefined;
    blindCopyTo?: string | undefined;
    subject?: string | undefined;
    body?: string | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IMailTemplateUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.mailGroup = _data["mailGroup"];
            this.mailKey = _data["mailKey"];
            this.displayName = _data["displayName"];
            this.sendTo = _data["sendTo"];
            this.copyTo = _data["copyTo"];
            this.blindCopyTo = _data["blindCopyTo"];
            this.subject = _data["subject"];
            this.body = _data["body"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): MailTemplateUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MailTemplateUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["mailGroup"] = this.mailGroup;
        data["mailKey"] = this.mailKey;
        data["displayName"] = this.displayName;
        data["sendTo"] = this.sendTo;
        data["copyTo"] = this.copyTo;
        data["blindCopyTo"] = this.blindCopyTo;
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IMailTemplateUpdateCommand {
    id: number;
    mailGroup?: number | undefined;
    mailKey?: string | undefined;
    displayName?: string | undefined;
    sendTo?: string | undefined;
    copyTo?: string | undefined;
    blindCopyTo?: string | undefined;
    subject?: string | undefined;
    body?: string | undefined;
    isActive?: boolean | undefined;
}

export class MailTemplateForEditResponse implements IMailTemplateForEditResponse {
    id!: number;
    mailGroup?: number | undefined;
    mailKey?: string | undefined;
    displayName?: string | undefined;
    sendTo?: string | undefined;
    copyTo?: string | undefined;
    blindCopyTo?: string | undefined;
    subject?: string | undefined;
    body?: string | undefined;
    isActive?: boolean | undefined;
    mailKeyList?: ComboboxItemDto[] | undefined;

    constructor(data?: IMailTemplateForEditResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.mailGroup = _data["mailGroup"];
            this.mailKey = _data["mailKey"];
            this.displayName = _data["displayName"];
            this.sendTo = _data["sendTo"];
            this.copyTo = _data["copyTo"];
            this.blindCopyTo = _data["blindCopyTo"];
            this.subject = _data["subject"];
            this.body = _data["body"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["mailKeyList"])) {
                this.mailKeyList = [] as any;
                for (let item of _data["mailKeyList"])
                    this.mailKeyList!.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MailTemplateForEditResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MailTemplateForEditResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["mailGroup"] = this.mailGroup;
        data["mailKey"] = this.mailKey;
        data["displayName"] = this.displayName;
        data["sendTo"] = this.sendTo;
        data["copyTo"] = this.copyTo;
        data["blindCopyTo"] = this.blindCopyTo;
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.mailKeyList)) {
            data["mailKeyList"] = [];
            for (let item of this.mailKeyList)
                data["mailKeyList"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMailTemplateForEditResponse {
    id: number;
    mailGroup?: number | undefined;
    mailKey?: string | undefined;
    displayName?: string | undefined;
    sendTo?: string | undefined;
    copyTo?: string | undefined;
    blindCopyTo?: string | undefined;
    subject?: string | undefined;
    body?: string | undefined;
    isActive?: boolean | undefined;
    mailKeyList?: ComboboxItemDto[] | undefined;
}

export class MailTemplateGetForEditQuery implements IMailTemplateGetForEditQuery {
    id!: number;

    constructor(data?: IMailTemplateGetForEditQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MailTemplateGetForEditQuery {
        data = typeof data === 'object' ? data : {};
        let result = new MailTemplateGetForEditQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IMailTemplateGetForEditQuery {
    id: number;
}

export class MailTemplateSendTestCommand implements IMailTemplateSendTestCommand {
    mailGroup!: number;
    email?: string | undefined;
    subject?: string | undefined;
    body?: string | undefined;

    constructor(data?: IMailTemplateSendTestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mailGroup = _data["mailGroup"];
            this.email = _data["email"];
            this.subject = _data["subject"];
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): MailTemplateSendTestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MailTemplateSendTestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mailGroup"] = this.mailGroup;
        data["email"] = this.email;
        data["subject"] = this.subject;
        data["body"] = this.body;
        return data;
    }
}

export interface IMailTemplateSendTestCommand {
    mailGroup: number;
    email?: string | undefined;
    subject?: string | undefined;
    body?: string | undefined;
}

export class MailTemplateGetBodyParamListQuery implements IMailTemplateGetBodyParamListQuery {
    mailKey?: string | undefined;

    constructor(data?: IMailTemplateGetBodyParamListQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mailKey = _data["mailKey"];
        }
    }

    static fromJS(data: any): MailTemplateGetBodyParamListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new MailTemplateGetBodyParamListQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mailKey"] = this.mailKey;
        return data;
    }
}

export interface IMailTemplateGetBodyParamListQuery {
    mailKey?: string | undefined;
}

export class MailTemplateGetMailKeyAvailableListQuery implements IMailTemplateGetMailKeyAvailableListQuery {
    mailGroup!: number;

    constructor(data?: IMailTemplateGetMailKeyAvailableListQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mailGroup = _data["mailGroup"];
        }
    }

    static fromJS(data: any): MailTemplateGetMailKeyAvailableListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new MailTemplateGetMailKeyAvailableListQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mailGroup"] = this.mailGroup;
        return data;
    }
}

export interface IMailTemplateGetMailKeyAvailableListQuery {
    mailGroup: number;
}

export class PagedResultDtoOfOrgUnitForListResponse implements IPagedResultDtoOfOrgUnitForListResponse {
    totalCount!: number;
    items?: OrgUnitForListResponse[] | undefined;

    constructor(data?: IPagedResultDtoOfOrgUnitForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrgUnitForListResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrgUnitForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrgUnitForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfOrgUnitForListResponse {
    totalCount: number;
    items?: OrgUnitForListResponse[] | undefined;
}

export class OrgUnitForListResponse implements IOrgUnitForListResponse {
    id!: number;
    parentOU?: number | undefined;
    parentOUDesc?: string | undefined;
    name?: string | undefined;
    level!: number;
    hasChildren!: boolean;
    size!: number;

    constructor(data?: IOrgUnitForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.parentOU = _data["parentOU"];
            this.parentOUDesc = _data["parentOUDesc"];
            this.name = _data["name"];
            this.level = _data["level"];
            this.hasChildren = _data["hasChildren"];
            this.size = _data["size"];
        }
    }

    static fromJS(data: any): OrgUnitForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OrgUnitForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentOU"] = this.parentOU;
        data["parentOUDesc"] = this.parentOUDesc;
        data["name"] = this.name;
        data["level"] = this.level;
        data["hasChildren"] = this.hasChildren;
        data["size"] = this.size;
        return data;
    }
}

export interface IOrgUnitForListResponse {
    id: number;
    parentOU?: number | undefined;
    parentOUDesc?: string | undefined;
    name?: string | undefined;
    level: number;
    hasChildren: boolean;
    size: number;
}

export class OrgUnitGetListQuery extends PageListByDto implements IOrgUnitGetListQuery {
    parentOU?: number | undefined;
    level?: number | undefined;

    constructor(data?: IOrgUnitGetListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.parentOU = _data["parentOU"];
            this.level = _data["level"];
        }
    }

    static override fromJS(data: any): OrgUnitGetListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new OrgUnitGetListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentOU"] = this.parentOU;
        data["level"] = this.level;
        super.toJSON(data);
        return data;
    }
}

export interface IOrgUnitGetListQuery extends IPageListByDto {
    parentOU?: number | undefined;
    level?: number | undefined;
}

export class OrgUnitResponse implements IOrgUnitResponse {
    id!: number;
    parentOU?: number | undefined;
    parentOUDesc?: string | undefined;
    name?: string | undefined;
    level!: number;
    hasChildren!: boolean;
    size!: number;

    constructor(data?: IOrgUnitResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.parentOU = _data["parentOU"];
            this.parentOUDesc = _data["parentOUDesc"];
            this.name = _data["name"];
            this.level = _data["level"];
            this.hasChildren = _data["hasChildren"];
            this.size = _data["size"];
        }
    }

    static fromJS(data: any): OrgUnitResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OrgUnitResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentOU"] = this.parentOU;
        data["parentOUDesc"] = this.parentOUDesc;
        data["name"] = this.name;
        data["level"] = this.level;
        data["hasChildren"] = this.hasChildren;
        data["size"] = this.size;
        return data;
    }
}

export interface IOrgUnitResponse {
    id: number;
    parentOU?: number | undefined;
    parentOUDesc?: string | undefined;
    name?: string | undefined;
    level: number;
    hasChildren: boolean;
    size: number;
}

export class OrgUnitGetComboQuery implements IOrgUnitGetComboQuery {
    filter?: string | undefined;

    constructor(data?: IOrgUnitGetComboQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): OrgUnitGetComboQuery {
        data = typeof data === 'object' ? data : {};
        let result = new OrgUnitGetComboQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        return data;
    }
}

export interface IOrgUnitGetComboQuery {
    filter?: string | undefined;
}

export class OrgUnitForEditResponse implements IOrgUnitForEditResponse {
    id!: number;
    parentOU?: number | undefined;
    parentOUDesc?: string | undefined;
    name?: string | undefined;
    level!: number;
    hasChildren!: boolean;
    size!: number;

    constructor(data?: IOrgUnitForEditResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.parentOU = _data["parentOU"];
            this.parentOUDesc = _data["parentOUDesc"];
            this.name = _data["name"];
            this.level = _data["level"];
            this.hasChildren = _data["hasChildren"];
            this.size = _data["size"];
        }
    }

    static fromJS(data: any): OrgUnitForEditResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OrgUnitForEditResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentOU"] = this.parentOU;
        data["parentOUDesc"] = this.parentOUDesc;
        data["name"] = this.name;
        data["level"] = this.level;
        data["hasChildren"] = this.hasChildren;
        data["size"] = this.size;
        return data;
    }
}

export interface IOrgUnitForEditResponse {
    id: number;
    parentOU?: number | undefined;
    parentOUDesc?: string | undefined;
    name?: string | undefined;
    level: number;
    hasChildren: boolean;
    size: number;
}

export class OrgUnitGetForEditQuery implements IOrgUnitGetForEditQuery {
    id?: number | undefined;

    constructor(data?: IOrgUnitGetForEditQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrgUnitGetForEditQuery {
        data = typeof data === 'object' ? data : {};
        let result = new OrgUnitGetForEditQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IOrgUnitGetForEditQuery {
    id?: number | undefined;
}

export class OrgUnitCreateCommand implements IOrgUnitCreateCommand {
    parentOU?: number | undefined;
    name?: string | undefined;
    level!: number;

    constructor(data?: IOrgUnitCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentOU = _data["parentOU"];
            this.name = _data["name"];
            this.level = _data["level"];
        }
    }

    static fromJS(data: any): OrgUnitCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new OrgUnitCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentOU"] = this.parentOU;
        data["name"] = this.name;
        data["level"] = this.level;
        return data;
    }
}

export interface IOrgUnitCreateCommand {
    parentOU?: number | undefined;
    name?: string | undefined;
    level: number;
}

export class OrgUnitUpdateCommand implements IOrgUnitUpdateCommand {
    id!: number;
    name?: string | undefined;

    constructor(data?: IOrgUnitUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): OrgUnitUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new OrgUnitUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IOrgUnitUpdateCommand {
    id: number;
    name?: string | undefined;
}

export class PagedResultDtoOfOrgUnitUserForListResponse implements IPagedResultDtoOfOrgUnitUserForListResponse {
    totalCount!: number;
    items?: OrgUnitUserForListResponse[] | undefined;

    constructor(data?: IPagedResultDtoOfOrgUnitUserForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrgUnitUserForListResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrgUnitUserForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrgUnitUserForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfOrgUnitUserForListResponse {
    totalCount: number;
    items?: OrgUnitUserForListResponse[] | undefined;
}

export class OrgUnitUserForListResponse implements IOrgUnitUserForListResponse {
    id!: number;
    orgUnit!: number;
    orgUnitDesc?: string | undefined;
    user!: number;
    userDesc?: string | undefined;

    constructor(data?: IOrgUnitUserForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orgUnit = _data["orgUnit"];
            this.orgUnitDesc = _data["orgUnitDesc"];
            this.user = _data["user"];
            this.userDesc = _data["userDesc"];
        }
    }

    static fromJS(data: any): OrgUnitUserForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OrgUnitUserForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orgUnit"] = this.orgUnit;
        data["orgUnitDesc"] = this.orgUnitDesc;
        data["user"] = this.user;
        data["userDesc"] = this.userDesc;
        return data;
    }
}

export interface IOrgUnitUserForListResponse {
    id: number;
    orgUnit: number;
    orgUnitDesc?: string | undefined;
    user: number;
    userDesc?: string | undefined;
}

export class OrgUnitUserGetListQuery extends PageListByDto implements IOrgUnitUserGetListQuery {
    orgUnit?: number | undefined;

    constructor(data?: IOrgUnitUserGetListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.orgUnit = _data["orgUnit"];
        }
    }

    static override fromJS(data: any): OrgUnitUserGetListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new OrgUnitUserGetListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orgUnit"] = this.orgUnit;
        super.toJSON(data);
        return data;
    }
}

export interface IOrgUnitUserGetListQuery extends IPageListByDto {
    orgUnit?: number | undefined;
}

export class OrgUnitUserCreateCommand implements IOrgUnitUserCreateCommand {
    orgUnit!: number;
    user!: number;

    constructor(data?: IOrgUnitUserCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orgUnit = _data["orgUnit"];
            this.user = _data["user"];
        }
    }

    static fromJS(data: any): OrgUnitUserCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new OrgUnitUserCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orgUnit"] = this.orgUnit;
        data["user"] = this.user;
        return data;
    }
}

export interface IOrgUnitUserCreateCommand {
    orgUnit: number;
    user: number;
}

export class Permission implements IPermission {
    parent?: Permission | undefined;
    name?: string | undefined;
    displayName?: string | undefined;
    description?: string | undefined;
    multiTenancySides!: MultiTenancySides;
    children?: Permission[] | undefined;

    constructor(data?: IPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parent = _data["parent"] ? Permission.fromJS(_data["parent"]) : <any>undefined;
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.multiTenancySides = _data["multiTenancySides"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(Permission.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Permission {
        data = typeof data === 'object' ? data : {};
        let result = new Permission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["multiTenancySides"] = this.multiTenancySides;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPermission {
    parent?: Permission | undefined;
    name?: string | undefined;
    displayName?: string | undefined;
    description?: string | undefined;
    multiTenancySides: MultiTenancySides;
    children?: Permission[] | undefined;
}

export enum MultiTenancySides {
    Tenant = 1,
    Host = 2,
}

export class ProcessGetListQuery extends PageListByDto implements IProcessGetListQuery {
    template!: number;
    viewType!: ProcessViewType;

    constructor(data?: IProcessGetListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.template = _data["template"];
            this.viewType = _data["viewType"];
        }
    }

    static override fromJS(data: any): ProcessGetListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessGetListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template;
        data["viewType"] = this.viewType;
        super.toJSON(data);
        return data;
    }
}

export interface IProcessGetListQuery extends IPageListByDto {
    template: number;
    viewType: ProcessViewType;
}

export enum ProcessViewType {
    Normal = 0,
    Own = 1,
    OwnPendings = 2,
}

export class ProcessGetComboQuery implements IProcessGetComboQuery {
    filter?: string | undefined;
    templateField!: number;

    constructor(data?: IProcessGetComboQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filter = _data["filter"];
            this.templateField = _data["templateField"];
        }
    }

    static fromJS(data: any): ProcessGetComboQuery {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessGetComboQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["templateField"] = this.templateField;
        return data;
    }
}

export interface IProcessGetComboQuery {
    filter?: string | undefined;
    templateField: number;
}

export class ProcessResponse implements IProcessResponse {
    id?: number | undefined;
    data?: { [key: string]: any; } | undefined;
    activity?: ProcessToDoActivityResponse | undefined;

    constructor(data?: IProcessResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
            this.activity = _data["activity"] ? ProcessToDoActivityResponse.fromJS(_data["activity"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProcessResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProcessResponse {
    id?: number | undefined;
    data?: { [key: string]: any; } | undefined;
    activity?: ProcessToDoActivityResponse | undefined;
}

export class ProcessToDoActivityResponse implements IProcessToDoActivityResponse {
    id?: number | undefined;
    userCreator!: number;
    status!: number;
    creationTime?: moment.Moment | undefined;
    description?: string | undefined;
    initialPlannedDate?: moment.Moment | undefined;
    initialRealDate?: moment.Moment | undefined;
    finalPlannedDate?: moment.Moment | undefined;
    finalRealDate?: moment.Moment | undefined;
    isOnTime!: boolean;
    evaluator?: ToDoActivityUserDto[] | undefined;
    executor?: ToDoActivityUserDto[] | undefined;

    constructor(data?: IProcessToDoActivityResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userCreator = _data["userCreator"];
            this.status = _data["status"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.initialPlannedDate = _data["initialPlannedDate"] ? moment(_data["initialPlannedDate"].toString()) : <any>undefined;
            this.initialRealDate = _data["initialRealDate"] ? moment(_data["initialRealDate"].toString()) : <any>undefined;
            this.finalPlannedDate = _data["finalPlannedDate"] ? moment(_data["finalPlannedDate"].toString()) : <any>undefined;
            this.finalRealDate = _data["finalRealDate"] ? moment(_data["finalRealDate"].toString()) : <any>undefined;
            this.isOnTime = _data["isOnTime"];
            if (Array.isArray(_data["evaluator"])) {
                this.evaluator = [] as any;
                for (let item of _data["evaluator"])
                    this.evaluator!.push(ToDoActivityUserDto.fromJS(item));
            }
            if (Array.isArray(_data["executor"])) {
                this.executor = [] as any;
                for (let item of _data["executor"])
                    this.executor!.push(ToDoActivityUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProcessToDoActivityResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessToDoActivityResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userCreator"] = this.userCreator;
        data["status"] = this.status;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["initialPlannedDate"] = this.initialPlannedDate ? this.initialPlannedDate.toISOString() : <any>undefined;
        data["initialRealDate"] = this.initialRealDate ? this.initialRealDate.toISOString() : <any>undefined;
        data["finalPlannedDate"] = this.finalPlannedDate ? this.finalPlannedDate.toISOString() : <any>undefined;
        data["finalRealDate"] = this.finalRealDate ? this.finalRealDate.toISOString() : <any>undefined;
        data["isOnTime"] = this.isOnTime;
        if (Array.isArray(this.evaluator)) {
            data["evaluator"] = [];
            for (let item of this.evaluator)
                data["evaluator"].push(item.toJSON());
        }
        if (Array.isArray(this.executor)) {
            data["executor"] = [];
            for (let item of this.executor)
                data["executor"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProcessToDoActivityResponse {
    id?: number | undefined;
    userCreator: number;
    status: number;
    creationTime?: moment.Moment | undefined;
    description?: string | undefined;
    initialPlannedDate?: moment.Moment | undefined;
    initialRealDate?: moment.Moment | undefined;
    finalPlannedDate?: moment.Moment | undefined;
    finalRealDate?: moment.Moment | undefined;
    isOnTime: boolean;
    evaluator?: ToDoActivityUserDto[] | undefined;
    executor?: ToDoActivityUserDto[] | undefined;
}

export class ToDoActivityUserDto implements IToDoActivityUserDto {
    id?: number | undefined;
    toDoActivity?: number | undefined;
    user!: number;
    userDesc?: string | undefined;

    constructor(data?: IToDoActivityUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.toDoActivity = _data["toDoActivity"];
            this.user = _data["user"];
            this.userDesc = _data["userDesc"];
        }
    }

    static fromJS(data: any): ToDoActivityUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ToDoActivityUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["toDoActivity"] = this.toDoActivity;
        data["user"] = this.user;
        data["userDesc"] = this.userDesc;
        return data;
    }
}

export interface IToDoActivityUserDto {
    id?: number | undefined;
    toDoActivity?: number | undefined;
    user: number;
    userDesc?: string | undefined;
}

export class ProcessGetByIdQuery implements IProcessGetByIdQuery {
    template!: number;
    id!: number;

    constructor(data?: IProcessGetByIdQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.template = _data["template"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProcessGetByIdQuery {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessGetByIdQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template;
        data["id"] = this.id;
        return data;
    }
}

export interface IProcessGetByIdQuery {
    template: number;
    id: number;
}

export class ProcessForReadResponse implements IProcessForReadResponse {
    template?: TemplateResponse | undefined;
    templateFields?: TemplateFieldResponse[] | undefined;
    id?: number | undefined;
    data?: { [key: string]: any; } | undefined;
    activity?: ProcessToDoActivityForEditResponse | undefined;

    constructor(data?: IProcessForReadResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.template = _data["template"] ? TemplateResponse.fromJS(_data["template"]) : <any>undefined;
            if (Array.isArray(_data["templateFields"])) {
                this.templateFields = [] as any;
                for (let item of _data["templateFields"])
                    this.templateFields!.push(TemplateFieldResponse.fromJS(item));
            }
            this.id = _data["id"];
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
            this.activity = _data["activity"] ? ProcessToDoActivityForEditResponse.fromJS(_data["activity"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProcessForReadResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessForReadResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template ? this.template.toJSON() : <any>undefined;
        if (Array.isArray(this.templateFields)) {
            data["templateFields"] = [];
            for (let item of this.templateFields)
                data["templateFields"].push(item.toJSON());
        }
        data["id"] = this.id;
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProcessForReadResponse {
    template?: TemplateResponse | undefined;
    templateFields?: TemplateFieldResponse[] | undefined;
    id?: number | undefined;
    data?: { [key: string]: any; } | undefined;
    activity?: ProcessToDoActivityForEditResponse | undefined;
}

export class TemplateResponse implements ITemplateResponse {
    id?: number | undefined;
    rgbColor?: string | undefined;
    nameSingular?: string | undefined;
    namePlural?: string | undefined;
    description?: string | undefined;
    icon?: string | undefined;
    tableName?: string | undefined;
    isTableGenerated!: boolean;
    hasChatRoom!: boolean;
    isActivity!: boolean;
    hasSecurity!: boolean;
    isActive!: boolean;

    constructor(data?: ITemplateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.rgbColor = _data["rgbColor"];
            this.nameSingular = _data["nameSingular"];
            this.namePlural = _data["namePlural"];
            this.description = _data["description"];
            this.icon = _data["icon"];
            this.tableName = _data["tableName"];
            this.isTableGenerated = _data["isTableGenerated"];
            this.hasChatRoom = _data["hasChatRoom"];
            this.isActivity = _data["isActivity"];
            this.hasSecurity = _data["hasSecurity"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): TemplateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rgbColor"] = this.rgbColor;
        data["nameSingular"] = this.nameSingular;
        data["namePlural"] = this.namePlural;
        data["description"] = this.description;
        data["icon"] = this.icon;
        data["tableName"] = this.tableName;
        data["isTableGenerated"] = this.isTableGenerated;
        data["hasChatRoom"] = this.hasChatRoom;
        data["isActivity"] = this.isActivity;
        data["hasSecurity"] = this.hasSecurity;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ITemplateResponse {
    id?: number | undefined;
    rgbColor?: string | undefined;
    nameSingular?: string | undefined;
    namePlural?: string | undefined;
    description?: string | undefined;
    icon?: string | undefined;
    tableName?: string | undefined;
    isTableGenerated: boolean;
    hasChatRoom: boolean;
    isActivity: boolean;
    hasSecurity: boolean;
    isActive: boolean;
}

export class TemplateFieldResponse implements ITemplateFieldResponse {
    id!: number;
    templateSection?: number | undefined;
    templateSectionDesc?: string | undefined;
    templateSectionIconAF?: string | undefined;
    templateSectionOrder?: number | undefined;
    name?: string | undefined;
    fieldName?: string | undefined;
    fieldType?: TemplateFieldType | undefined;
    fieldSize?: number | undefined;
    fieldControl?: TemplateFieldControl | undefined;
    inputMask?: string | undefined;
    hasKeyFilter!: boolean;
    keyFilter?: string | undefined;
    status?: TemplateFieldStatus | undefined;
    isRequired!: boolean;
    showOnGrid!: boolean;
    order?: number | undefined;
    inheritSecurity!: boolean;
    templateFieldRelationTemplate?: number | undefined;
    templateFieldRelationTemplateDesc?: string | undefined;
    templateFieldRelationTemplateField?: number | undefined;
    options?: TemplateFieldOptionDto[] | undefined;
    mustHaveOptions!: boolean;

    constructor(data?: ITemplateFieldResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.templateSection = _data["templateSection"];
            this.templateSectionDesc = _data["templateSectionDesc"];
            this.templateSectionIconAF = _data["templateSectionIconAF"];
            this.templateSectionOrder = _data["templateSectionOrder"];
            this.name = _data["name"];
            this.fieldName = _data["fieldName"];
            this.fieldType = _data["fieldType"];
            this.fieldSize = _data["fieldSize"];
            this.fieldControl = _data["fieldControl"];
            this.inputMask = _data["inputMask"];
            this.hasKeyFilter = _data["hasKeyFilter"];
            this.keyFilter = _data["keyFilter"];
            this.status = _data["status"];
            this.isRequired = _data["isRequired"];
            this.showOnGrid = _data["showOnGrid"];
            this.order = _data["order"];
            this.inheritSecurity = _data["inheritSecurity"];
            this.templateFieldRelationTemplate = _data["templateFieldRelationTemplate"];
            this.templateFieldRelationTemplateDesc = _data["templateFieldRelationTemplateDesc"];
            this.templateFieldRelationTemplateField = _data["templateFieldRelationTemplateField"];
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(TemplateFieldOptionDto.fromJS(item));
            }
            this.mustHaveOptions = _data["mustHaveOptions"];
        }
    }

    static fromJS(data: any): TemplateFieldResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateFieldResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["templateSection"] = this.templateSection;
        data["templateSectionDesc"] = this.templateSectionDesc;
        data["templateSectionIconAF"] = this.templateSectionIconAF;
        data["templateSectionOrder"] = this.templateSectionOrder;
        data["name"] = this.name;
        data["fieldName"] = this.fieldName;
        data["fieldType"] = this.fieldType;
        data["fieldSize"] = this.fieldSize;
        data["fieldControl"] = this.fieldControl;
        data["inputMask"] = this.inputMask;
        data["hasKeyFilter"] = this.hasKeyFilter;
        data["keyFilter"] = this.keyFilter;
        data["status"] = this.status;
        data["isRequired"] = this.isRequired;
        data["showOnGrid"] = this.showOnGrid;
        data["order"] = this.order;
        data["inheritSecurity"] = this.inheritSecurity;
        data["templateFieldRelationTemplate"] = this.templateFieldRelationTemplate;
        data["templateFieldRelationTemplateDesc"] = this.templateFieldRelationTemplateDesc;
        data["templateFieldRelationTemplateField"] = this.templateFieldRelationTemplateField;
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        data["mustHaveOptions"] = this.mustHaveOptions;
        return data;
    }
}

export interface ITemplateFieldResponse {
    id: number;
    templateSection?: number | undefined;
    templateSectionDesc?: string | undefined;
    templateSectionIconAF?: string | undefined;
    templateSectionOrder?: number | undefined;
    name?: string | undefined;
    fieldName?: string | undefined;
    fieldType?: TemplateFieldType | undefined;
    fieldSize?: number | undefined;
    fieldControl?: TemplateFieldControl | undefined;
    inputMask?: string | undefined;
    hasKeyFilter: boolean;
    keyFilter?: string | undefined;
    status?: TemplateFieldStatus | undefined;
    isRequired: boolean;
    showOnGrid: boolean;
    order?: number | undefined;
    inheritSecurity: boolean;
    templateFieldRelationTemplate?: number | undefined;
    templateFieldRelationTemplateDesc?: string | undefined;
    templateFieldRelationTemplateField?: number | undefined;
    options?: TemplateFieldOptionDto[] | undefined;
    mustHaveOptions: boolean;
}

export enum TemplateFieldType {
    Boolean = 1,
    Text = 10,
    Multivalue = 20,
    Date = 30,
    DateTime = 31,
    Time = 32,
    Integer = 40,
    Decimal = 41,
    GoogleAddress = 50,
    Template = 60,
    User = 70,
}

export enum TemplateFieldControl {
    InputText = 10,
    DropDown = 11,
    Listbox = 12,
    RadioButton = 13,
    InputSwitch = 14,
    InputMask = 15,
    InputTextArea = 16,
    ListboxMultivalue = 21,
    Checkbox = 22,
    Multiselect = 23,
    CalendarBasic = 30,
    CalendarTime = 31,
    CalendarTimeOnly = 32,
    Spinner = 40,
    SpinnerFormatInput = 41,
    TextNumber = 42,
    GoogleAddress = 50,
    Autocomplete = 60,
    AutocompleteDynamic = 61,
}

export enum TemplateFieldStatus {
    New = 1,
    Processed = 2,
    Modified = 3,
    Deleted = 4,
}

export class TemplateFieldOptionDto implements ITemplateFieldOptionDto {
    id?: number | undefined;
    templateField?: number | undefined;
    value!: number;
    description?: string | undefined;

    constructor(data?: ITemplateFieldOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.templateField = _data["templateField"];
            this.value = _data["value"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): TemplateFieldOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateFieldOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["templateField"] = this.templateField;
        data["value"] = this.value;
        data["description"] = this.description;
        return data;
    }
}

export interface ITemplateFieldOptionDto {
    id?: number | undefined;
    templateField?: number | undefined;
    value: number;
    description?: string | undefined;
}

export class ProcessToDoActivityForEditResponse implements IProcessToDoActivityForEditResponse {
    id?: number | undefined;
    userCreator!: number;
    userCreatorDesc?: string | undefined;
    status!: number;
    statusDesc?: string | undefined;
    creationTime?: moment.Moment | undefined;
    description?: string | undefined;
    initialPlannedDate?: moment.Moment | undefined;
    initialRealDate?: moment.Moment | undefined;
    finalPlannedDate?: moment.Moment | undefined;
    finalRealDate?: moment.Moment | undefined;
    isOnTime!: boolean;
    isOnTimeDesc?: string | undefined;
    evaluator?: ToDoActivityUserDto[] | undefined;
    executor?: ToDoActivityUserDto[] | undefined;

    constructor(data?: IProcessToDoActivityForEditResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userCreator = _data["userCreator"];
            this.userCreatorDesc = _data["userCreatorDesc"];
            this.status = _data["status"];
            this.statusDesc = _data["statusDesc"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.initialPlannedDate = _data["initialPlannedDate"] ? moment(_data["initialPlannedDate"].toString()) : <any>undefined;
            this.initialRealDate = _data["initialRealDate"] ? moment(_data["initialRealDate"].toString()) : <any>undefined;
            this.finalPlannedDate = _data["finalPlannedDate"] ? moment(_data["finalPlannedDate"].toString()) : <any>undefined;
            this.finalRealDate = _data["finalRealDate"] ? moment(_data["finalRealDate"].toString()) : <any>undefined;
            this.isOnTime = _data["isOnTime"];
            this.isOnTimeDesc = _data["isOnTimeDesc"];
            if (Array.isArray(_data["evaluator"])) {
                this.evaluator = [] as any;
                for (let item of _data["evaluator"])
                    this.evaluator!.push(ToDoActivityUserDto.fromJS(item));
            }
            if (Array.isArray(_data["executor"])) {
                this.executor = [] as any;
                for (let item of _data["executor"])
                    this.executor!.push(ToDoActivityUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProcessToDoActivityForEditResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessToDoActivityForEditResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userCreator"] = this.userCreator;
        data["userCreatorDesc"] = this.userCreatorDesc;
        data["status"] = this.status;
        data["statusDesc"] = this.statusDesc;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["initialPlannedDate"] = this.initialPlannedDate ? this.initialPlannedDate.toISOString() : <any>undefined;
        data["initialRealDate"] = this.initialRealDate ? this.initialRealDate.toISOString() : <any>undefined;
        data["finalPlannedDate"] = this.finalPlannedDate ? this.finalPlannedDate.toISOString() : <any>undefined;
        data["finalRealDate"] = this.finalRealDate ? this.finalRealDate.toISOString() : <any>undefined;
        data["isOnTime"] = this.isOnTime;
        data["isOnTimeDesc"] = this.isOnTimeDesc;
        if (Array.isArray(this.evaluator)) {
            data["evaluator"] = [];
            for (let item of this.evaluator)
                data["evaluator"].push(item.toJSON());
        }
        if (Array.isArray(this.executor)) {
            data["executor"] = [];
            for (let item of this.executor)
                data["executor"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProcessToDoActivityForEditResponse {
    id?: number | undefined;
    userCreator: number;
    userCreatorDesc?: string | undefined;
    status: number;
    statusDesc?: string | undefined;
    creationTime?: moment.Moment | undefined;
    description?: string | undefined;
    initialPlannedDate?: moment.Moment | undefined;
    initialRealDate?: moment.Moment | undefined;
    finalPlannedDate?: moment.Moment | undefined;
    finalRealDate?: moment.Moment | undefined;
    isOnTime: boolean;
    isOnTimeDesc?: string | undefined;
    evaluator?: ToDoActivityUserDto[] | undefined;
    executor?: ToDoActivityUserDto[] | undefined;
}

export class ProcessGetForReadQuery implements IProcessGetForReadQuery {
    template!: number;
    id!: number;

    constructor(data?: IProcessGetForReadQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.template = _data["template"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProcessGetForReadQuery {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessGetForReadQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template;
        data["id"] = this.id;
        return data;
    }
}

export interface IProcessGetForReadQuery {
    template: number;
    id: number;
}

export class ProcessForEditResponse implements IProcessForEditResponse {
    template?: TemplateResponse | undefined;
    templateFields?: TemplateFieldResponse[] | undefined;
    id?: number | undefined;
    data?: { [key: string]: any; } | undefined;
    activity?: ProcessToDoActivityForEditResponse | undefined;
    activityStatusCombo?: ComboboxItemDto[] | undefined;

    constructor(data?: IProcessForEditResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.template = _data["template"] ? TemplateResponse.fromJS(_data["template"]) : <any>undefined;
            if (Array.isArray(_data["templateFields"])) {
                this.templateFields = [] as any;
                for (let item of _data["templateFields"])
                    this.templateFields!.push(TemplateFieldResponse.fromJS(item));
            }
            this.id = _data["id"];
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
            this.activity = _data["activity"] ? ProcessToDoActivityForEditResponse.fromJS(_data["activity"]) : <any>undefined;
            if (Array.isArray(_data["activityStatusCombo"])) {
                this.activityStatusCombo = [] as any;
                for (let item of _data["activityStatusCombo"])
                    this.activityStatusCombo!.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProcessForEditResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessForEditResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template ? this.template.toJSON() : <any>undefined;
        if (Array.isArray(this.templateFields)) {
            data["templateFields"] = [];
            for (let item of this.templateFields)
                data["templateFields"].push(item.toJSON());
        }
        data["id"] = this.id;
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        if (Array.isArray(this.activityStatusCombo)) {
            data["activityStatusCombo"] = [];
            for (let item of this.activityStatusCombo)
                data["activityStatusCombo"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProcessForEditResponse {
    template?: TemplateResponse | undefined;
    templateFields?: TemplateFieldResponse[] | undefined;
    id?: number | undefined;
    data?: { [key: string]: any; } | undefined;
    activity?: ProcessToDoActivityForEditResponse | undefined;
    activityStatusCombo?: ComboboxItemDto[] | undefined;
}

export class ProcessGetForEditQuery implements IProcessGetForEditQuery {
    template!: number;
    id?: number | undefined;

    constructor(data?: IProcessGetForEditQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.template = _data["template"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProcessGetForEditQuery {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessGetForEditQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template;
        data["id"] = this.id;
        return data;
    }
}

export interface IProcessGetForEditQuery {
    template: number;
    id?: number | undefined;
}

export class ProcessCreateCommand implements IProcessCreateCommand {
    template!: number;
    data?: { [key: string]: string; } | undefined;
    activity?: ProcessToDoActivityCommand | undefined;

    constructor(data?: IProcessCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.template = _data["template"];
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
            this.activity = _data["activity"] ? ProcessToDoActivityCommand.fromJS(_data["activity"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProcessCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template;
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProcessCreateCommand {
    template: number;
    data?: { [key: string]: string; } | undefined;
    activity?: ProcessToDoActivityCommand | undefined;
}

export class ProcessToDoActivityCommand implements IProcessToDoActivityCommand {
    status!: number;
    description?: string | undefined;
    initialPlannedDate?: moment.Moment | undefined;
    initialRealDate?: moment.Moment | undefined;
    finalPlannedDate?: moment.Moment | undefined;
    finalRealDate?: moment.Moment | undefined;
    evaluator?: number[] | undefined;
    executor?: number[] | undefined;

    constructor(data?: IProcessToDoActivityCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.description = _data["description"];
            this.initialPlannedDate = _data["initialPlannedDate"] ? moment(_data["initialPlannedDate"].toString()) : <any>undefined;
            this.initialRealDate = _data["initialRealDate"] ? moment(_data["initialRealDate"].toString()) : <any>undefined;
            this.finalPlannedDate = _data["finalPlannedDate"] ? moment(_data["finalPlannedDate"].toString()) : <any>undefined;
            this.finalRealDate = _data["finalRealDate"] ? moment(_data["finalRealDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["evaluator"])) {
                this.evaluator = [] as any;
                for (let item of _data["evaluator"])
                    this.evaluator!.push(item);
            }
            if (Array.isArray(_data["executor"])) {
                this.executor = [] as any;
                for (let item of _data["executor"])
                    this.executor!.push(item);
            }
        }
    }

    static fromJS(data: any): ProcessToDoActivityCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessToDoActivityCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["description"] = this.description;
        data["initialPlannedDate"] = this.initialPlannedDate ? this.initialPlannedDate.toISOString() : <any>undefined;
        data["initialRealDate"] = this.initialRealDate ? this.initialRealDate.toISOString() : <any>undefined;
        data["finalPlannedDate"] = this.finalPlannedDate ? this.finalPlannedDate.toISOString() : <any>undefined;
        data["finalRealDate"] = this.finalRealDate ? this.finalRealDate.toISOString() : <any>undefined;
        if (Array.isArray(this.evaluator)) {
            data["evaluator"] = [];
            for (let item of this.evaluator)
                data["evaluator"].push(item);
        }
        if (Array.isArray(this.executor)) {
            data["executor"] = [];
            for (let item of this.executor)
                data["executor"].push(item);
        }
        return data;
    }
}

export interface IProcessToDoActivityCommand {
    status: number;
    description?: string | undefined;
    initialPlannedDate?: moment.Moment | undefined;
    initialRealDate?: moment.Moment | undefined;
    finalPlannedDate?: moment.Moment | undefined;
    finalRealDate?: moment.Moment | undefined;
    evaluator?: number[] | undefined;
    executor?: number[] | undefined;
}

export class ProcessUpdateCommand implements IProcessUpdateCommand {
    template!: number;
    id!: number;
    data?: { [key: string]: string; } | undefined;
    activity?: ProcessToDoActivityCommand | undefined;

    constructor(data?: IProcessUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.template = _data["template"];
            this.id = _data["id"];
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
            this.activity = _data["activity"] ? ProcessToDoActivityCommand.fromJS(_data["activity"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProcessUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template;
        data["id"] = this.id;
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProcessUpdateCommand {
    template: number;
    id: number;
    data?: { [key: string]: string; } | undefined;
    activity?: ProcessToDoActivityCommand | undefined;
}

export class ProcessDeleteCommand implements IProcessDeleteCommand {
    template!: number;
    id!: number;

    constructor(data?: IProcessDeleteCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.template = _data["template"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProcessDeleteCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessDeleteCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template;
        data["id"] = this.id;
        return data;
    }
}

export interface IProcessDeleteCommand {
    template: number;
    id: number;
}

export class ToDoTimeSheetResponse implements IToDoTimeSheetResponse {
    id!: number;
    activity!: number;
    userCreator!: number;
    userCreatorDesc?: string | undefined;
    creationDate?: moment.Moment | undefined;
    creationTime?: moment.Moment | undefined;
    comments?: string | undefined;
    hoursSpend!: number;

    constructor(data?: IToDoTimeSheetResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.activity = _data["activity"];
            this.userCreator = _data["userCreator"];
            this.userCreatorDesc = _data["userCreatorDesc"];
            this.creationDate = _data["creationDate"] ? moment(_data["creationDate"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.comments = _data["comments"];
            this.hoursSpend = _data["hoursSpend"];
        }
    }

    static fromJS(data: any): ToDoTimeSheetResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ToDoTimeSheetResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["activity"] = this.activity;
        data["userCreator"] = this.userCreator;
        data["userCreatorDesc"] = this.userCreatorDesc;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["comments"] = this.comments;
        data["hoursSpend"] = this.hoursSpend;
        return data;
    }
}

export interface IToDoTimeSheetResponse {
    id: number;
    activity: number;
    userCreator: number;
    userCreatorDesc?: string | undefined;
    creationDate?: moment.Moment | undefined;
    creationTime?: moment.Moment | undefined;
    comments?: string | undefined;
    hoursSpend: number;
}

export class ToDoTimeSheetForEditResponse implements IToDoTimeSheetForEditResponse {
    id?: number | undefined;
    activity!: number;
    userCreator!: number;
    userCreatorDesc?: string | undefined;
    creationDate?: moment.Moment | undefined;
    creationTime?: moment.Moment | undefined;
    comments?: string | undefined;
    hoursSpend!: number;
    activityStatusCombo?: ComboboxItemDto[] | undefined;

    constructor(data?: IToDoTimeSheetForEditResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.activity = _data["activity"];
            this.userCreator = _data["userCreator"];
            this.userCreatorDesc = _data["userCreatorDesc"];
            this.creationDate = _data["creationDate"] ? moment(_data["creationDate"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.comments = _data["comments"];
            this.hoursSpend = _data["hoursSpend"];
            if (Array.isArray(_data["activityStatusCombo"])) {
                this.activityStatusCombo = [] as any;
                for (let item of _data["activityStatusCombo"])
                    this.activityStatusCombo!.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ToDoTimeSheetForEditResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ToDoTimeSheetForEditResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["activity"] = this.activity;
        data["userCreator"] = this.userCreator;
        data["userCreatorDesc"] = this.userCreatorDesc;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["comments"] = this.comments;
        data["hoursSpend"] = this.hoursSpend;
        if (Array.isArray(this.activityStatusCombo)) {
            data["activityStatusCombo"] = [];
            for (let item of this.activityStatusCombo)
                data["activityStatusCombo"].push(item.toJSON());
        }
        return data;
    }
}

export interface IToDoTimeSheetForEditResponse {
    id?: number | undefined;
    activity: number;
    userCreator: number;
    userCreatorDesc?: string | undefined;
    creationDate?: moment.Moment | undefined;
    creationTime?: moment.Moment | undefined;
    comments?: string | undefined;
    hoursSpend: number;
    activityStatusCombo?: ComboboxItemDto[] | undefined;
}

export class ToDoTimeSheetGetForEditQuery implements IToDoTimeSheetGetForEditQuery {
    id?: number | undefined;
    template!: number;

    constructor(data?: IToDoTimeSheetGetForEditQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.template = _data["template"];
        }
    }

    static fromJS(data: any): ToDoTimeSheetGetForEditQuery {
        data = typeof data === 'object' ? data : {};
        let result = new ToDoTimeSheetGetForEditQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["template"] = this.template;
        return data;
    }
}

export interface IToDoTimeSheetGetForEditQuery {
    id?: number | undefined;
    template: number;
}

export class ToDoTimeSheetCreateCommand implements IToDoTimeSheetCreateCommand {
    template!: number;
    activity!: number;
    creationDate?: moment.Moment | undefined;
    comments?: string | undefined;
    hoursSpend!: number;
    activityStatus?: number | undefined;

    constructor(data?: IToDoTimeSheetCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.template = _data["template"];
            this.activity = _data["activity"];
            this.creationDate = _data["creationDate"] ? moment(_data["creationDate"].toString()) : <any>undefined;
            this.comments = _data["comments"];
            this.hoursSpend = _data["hoursSpend"];
            this.activityStatus = _data["activityStatus"];
        }
    }

    static fromJS(data: any): ToDoTimeSheetCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ToDoTimeSheetCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template;
        data["activity"] = this.activity;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["comments"] = this.comments;
        data["hoursSpend"] = this.hoursSpend;
        data["activityStatus"] = this.activityStatus;
        return data;
    }
}

export interface IToDoTimeSheetCreateCommand {
    template: number;
    activity: number;
    creationDate?: moment.Moment | undefined;
    comments?: string | undefined;
    hoursSpend: number;
    activityStatus?: number | undefined;
}

export class ToDoTimeSheetUpdateCommand implements IToDoTimeSheetUpdateCommand {
    template!: number;
    id!: number;
    creationDate?: moment.Moment | undefined;
    comments?: string | undefined;
    hoursSpend!: number;
    activityStatus?: number | undefined;

    constructor(data?: IToDoTimeSheetUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.template = _data["template"];
            this.id = _data["id"];
            this.creationDate = _data["creationDate"] ? moment(_data["creationDate"].toString()) : <any>undefined;
            this.comments = _data["comments"];
            this.hoursSpend = _data["hoursSpend"];
            this.activityStatus = _data["activityStatus"];
        }
    }

    static fromJS(data: any): ToDoTimeSheetUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ToDoTimeSheetUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template;
        data["id"] = this.id;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["comments"] = this.comments;
        data["hoursSpend"] = this.hoursSpend;
        data["activityStatus"] = this.activityStatus;
        return data;
    }
}

export interface IToDoTimeSheetUpdateCommand {
    template: number;
    id: number;
    creationDate?: moment.Moment | undefined;
    comments?: string | undefined;
    hoursSpend: number;
    activityStatus?: number | undefined;
}

export class PagedResultDtoOfProcessSecurityMemberForListResponse implements IPagedResultDtoOfProcessSecurityMemberForListResponse {
    totalCount!: number;
    items?: ProcessSecurityMemberForListResponse[] | undefined;

    constructor(data?: IPagedResultDtoOfProcessSecurityMemberForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProcessSecurityMemberForListResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProcessSecurityMemberForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProcessSecurityMemberForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfProcessSecurityMemberForListResponse {
    totalCount: number;
    items?: ProcessSecurityMemberForListResponse[] | undefined;
}

export class ProcessSecurityMemberForListResponse implements IProcessSecurityMemberForListResponse {
    id!: number;
    parent!: number;
    type!: SecurityMemberType;
    typeDesc?: string | undefined;
    member!: number;
    memberDesc?: string | undefined;
    level!: SecurityMemberLevel;
    levelDesc?: string | undefined;
    isExecutor!: boolean;
    isExecutorDesc?: string | undefined;

    constructor(data?: IProcessSecurityMemberForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.parent = _data["parent"];
            this.type = _data["type"];
            this.typeDesc = _data["typeDesc"];
            this.member = _data["member"];
            this.memberDesc = _data["memberDesc"];
            this.level = _data["level"];
            this.levelDesc = _data["levelDesc"];
            this.isExecutor = _data["isExecutor"];
            this.isExecutorDesc = _data["isExecutorDesc"];
        }
    }

    static fromJS(data: any): ProcessSecurityMemberForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessSecurityMemberForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parent"] = this.parent;
        data["type"] = this.type;
        data["typeDesc"] = this.typeDesc;
        data["member"] = this.member;
        data["memberDesc"] = this.memberDesc;
        data["level"] = this.level;
        data["levelDesc"] = this.levelDesc;
        data["isExecutor"] = this.isExecutor;
        data["isExecutorDesc"] = this.isExecutorDesc;
        return data;
    }
}

export interface IProcessSecurityMemberForListResponse {
    id: number;
    parent: number;
    type: SecurityMemberType;
    typeDesc?: string | undefined;
    member: number;
    memberDesc?: string | undefined;
    level: SecurityMemberLevel;
    levelDesc?: string | undefined;
    isExecutor: boolean;
    isExecutorDesc?: string | undefined;
}

export enum SecurityMemberType {
    User = 1,
    OrgUnit = 2,
}

export enum SecurityMemberLevel {
    Reader = 1,
    Editor = 2,
}

export class ProcessSecurityMemberGetListQuery extends PageListByDto implements IProcessSecurityMemberGetListQuery {
    template!: number;
    parent!: number;
    type?: SecurityMemberType | undefined;
    level?: SecurityMemberLevel | undefined;

    constructor(data?: IProcessSecurityMemberGetListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.template = _data["template"];
            this.parent = _data["parent"];
            this.type = _data["type"];
            this.level = _data["level"];
        }
    }

    static override fromJS(data: any): ProcessSecurityMemberGetListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessSecurityMemberGetListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template;
        data["parent"] = this.parent;
        data["type"] = this.type;
        data["level"] = this.level;
        super.toJSON(data);
        return data;
    }
}

export interface IProcessSecurityMemberGetListQuery extends IPageListByDto {
    template: number;
    parent: number;
    type?: SecurityMemberType | undefined;
    level?: SecurityMemberLevel | undefined;
}

export class ProcessSecurityMemberCreateCommand implements IProcessSecurityMemberCreateCommand {
    template!: number;
    parent!: number;
    type!: SecurityMemberType;
    member!: number;
    level!: SecurityMemberLevel;
    isExecutor!: boolean;

    constructor(data?: IProcessSecurityMemberCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.template = _data["template"];
            this.parent = _data["parent"];
            this.type = _data["type"];
            this.member = _data["member"];
            this.level = _data["level"];
            this.isExecutor = _data["isExecutor"];
        }
    }

    static fromJS(data: any): ProcessSecurityMemberCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessSecurityMemberCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template;
        data["parent"] = this.parent;
        data["type"] = this.type;
        data["member"] = this.member;
        data["level"] = this.level;
        data["isExecutor"] = this.isExecutor;
        return data;
    }
}

export interface IProcessSecurityMemberCreateCommand {
    template: number;
    parent: number;
    type: SecurityMemberType;
    member: number;
    level: SecurityMemberLevel;
    isExecutor: boolean;
}

export class ProcessSecurityMemberDeleteCommand implements IProcessSecurityMemberDeleteCommand {
    template!: number;
    id!: number;
    type!: SecurityMemberType;
    level!: SecurityMemberLevel;

    constructor(data?: IProcessSecurityMemberDeleteCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.template = _data["template"];
            this.id = _data["id"];
            this.type = _data["type"];
            this.level = _data["level"];
        }
    }

    static fromJS(data: any): ProcessSecurityMemberDeleteCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessSecurityMemberDeleteCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template;
        data["id"] = this.id;
        data["type"] = this.type;
        data["level"] = this.level;
        return data;
    }
}

export interface IProcessSecurityMemberDeleteCommand {
    template: number;
    id: number;
    type: SecurityMemberType;
    level: SecurityMemberLevel;
}

export class PagedResultDtoOfQuestionnaireForListResponse implements IPagedResultDtoOfQuestionnaireForListResponse {
    totalCount!: number;
    items?: QuestionnaireForListResponse[] | undefined;

    constructor(data?: IPagedResultDtoOfQuestionnaireForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(QuestionnaireForListResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfQuestionnaireForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfQuestionnaireForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfQuestionnaireForListResponse {
    totalCount: number;
    items?: QuestionnaireForListResponse[] | undefined;
}

export class QuestionnaireForListResponse implements IQuestionnaireForListResponse {
    id?: string | undefined;
    creationDateTime?: moment.Moment | undefined;
    name?: string | undefined;
    userCreator?: string | undefined;
    isActive!: boolean;
    isActiveDesc?: string | undefined;

    constructor(data?: IQuestionnaireForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationDateTime = _data["creationDateTime"] ? moment(_data["creationDateTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.userCreator = _data["userCreator"];
            this.isActive = _data["isActive"];
            this.isActiveDesc = _data["isActiveDesc"];
        }
    }

    static fromJS(data: any): QuestionnaireForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionnaireForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationDateTime"] = this.creationDateTime ? this.creationDateTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["userCreator"] = this.userCreator;
        data["isActive"] = this.isActive;
        data["isActiveDesc"] = this.isActiveDesc;
        return data;
    }
}

export interface IQuestionnaireForListResponse {
    id?: string | undefined;
    creationDateTime?: moment.Moment | undefined;
    name?: string | undefined;
    userCreator?: string | undefined;
    isActive: boolean;
    isActiveDesc?: string | undefined;
}

export class QuestionnaireGetListQuery extends PageListByDto implements IQuestionnaireGetListQuery {

    constructor(data?: IQuestionnaireGetListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): QuestionnaireGetListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionnaireGetListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IQuestionnaireGetListQuery extends IPageListByDto {
}

export class QuestionnaireGetComboQuery implements IQuestionnaireGetComboQuery {
    filter?: string | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IQuestionnaireGetComboQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filter = _data["filter"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): QuestionnaireGetComboQuery {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionnaireGetComboQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IQuestionnaireGetComboQuery {
    filter?: string | undefined;
    isActive?: boolean | undefined;
}

export class QuestionnaireCreateCommand implements IQuestionnaireCreateCommand {
    name?: string | undefined;
    customCode?: string | undefined;
    isActive!: boolean;
    sections?: QuestionnaireSectionResponse[] | undefined;

    constructor(data?: IQuestionnaireCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.customCode = _data["customCode"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(QuestionnaireSectionResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuestionnaireCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionnaireCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["customCode"] = this.customCode;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQuestionnaireCreateCommand {
    name?: string | undefined;
    customCode?: string | undefined;
    isActive: boolean;
    sections?: QuestionnaireSectionResponse[] | undefined;
}

export class QuestionnaireUpdateCommand implements IQuestionnaireUpdateCommand {
    id?: string | undefined;
    customCode?: string | undefined;
    name?: string | undefined;
    isActive!: boolean;
    sections?: QuestionnaireSectionResponse[] | undefined;

    constructor(data?: IQuestionnaireUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customCode = _data["customCode"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(QuestionnaireSectionResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuestionnaireUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionnaireUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customCode"] = this.customCode;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQuestionnaireUpdateCommand {
    id?: string | undefined;
    customCode?: string | undefined;
    name?: string | undefined;
    isActive: boolean;
    sections?: QuestionnaireSectionResponse[] | undefined;
}

export class QuestionnaireFieldGetComboQuery implements IQuestionnaireFieldGetComboQuery {
    questionnaire?: string | undefined;

    constructor(data?: IQuestionnaireFieldGetComboQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.questionnaire = _data["questionnaire"];
        }
    }

    static fromJS(data: any): QuestionnaireFieldGetComboQuery {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionnaireFieldGetComboQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionnaire"] = this.questionnaire;
        return data;
    }
}

export interface IQuestionnaireFieldGetComboQuery {
    questionnaire?: string | undefined;
}

export class TenantCreateRegistrationCommand implements ITenantCreateRegistrationCommand {
    tenancyName?: string | undefined;
    tenantName?: string | undefined;
    password?: string | undefined;
    passwordConfirm?: string | undefined;
    name?: string | undefined;
    lastName?: string | undefined;
    secondLastName?: string | undefined;
    emailAddress?: string | undefined;

    constructor(data?: ITenantCreateRegistrationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.tenantName = _data["tenantName"];
            this.password = _data["password"];
            this.passwordConfirm = _data["passwordConfirm"];
            this.name = _data["name"];
            this.lastName = _data["lastName"];
            this.secondLastName = _data["secondLastName"];
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): TenantCreateRegistrationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TenantCreateRegistrationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["tenantName"] = this.tenantName;
        data["password"] = this.password;
        data["passwordConfirm"] = this.passwordConfirm;
        data["name"] = this.name;
        data["lastName"] = this.lastName;
        data["secondLastName"] = this.secondLastName;
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface ITenantCreateRegistrationCommand {
    tenancyName?: string | undefined;
    tenantName?: string | undefined;
    password?: string | undefined;
    passwordConfirm?: string | undefined;
    name?: string | undefined;
    lastName?: string | undefined;
    secondLastName?: string | undefined;
    emailAddress?: string | undefined;
}

export class TenantConfirmRegistrationCommand implements ITenantConfirmRegistrationCommand {
    code?: string | undefined;

    constructor(data?: ITenantConfirmRegistrationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): TenantConfirmRegistrationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TenantConfirmRegistrationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        return data;
    }
}

export interface ITenantConfirmRegistrationCommand {
    code?: string | undefined;
}

export class PagedResultDtoOfRolForListResponse implements IPagedResultDtoOfRolForListResponse {
    totalCount!: number;
    items?: RolForListResponse[] | undefined;

    constructor(data?: IPagedResultDtoOfRolForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RolForListResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRolForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRolForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfRolForListResponse {
    totalCount: number;
    items?: RolForListResponse[] | undefined;
}

export class RolForListResponse implements IRolForListResponse {
    id!: number;
    name?: string | undefined;
    displayName?: string | undefined;
    isActive?: boolean | undefined;
    isActiveDesc?: string | undefined;

    constructor(data?: IRolForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
            this.isActiveDesc = _data["isActiveDesc"];
        }
    }

    static fromJS(data: any): RolForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RolForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        data["isActiveDesc"] = this.isActiveDesc;
        return data;
    }
}

export interface IRolForListResponse {
    id: number;
    name?: string | undefined;
    displayName?: string | undefined;
    isActive?: boolean | undefined;
    isActiveDesc?: string | undefined;
}

export class RolGetListQuery extends PageListByDto implements IRolGetListQuery {

    constructor(data?: IRolGetListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): RolGetListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new RolGetListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IRolGetListQuery extends IPageListByDto {
}

export class RolResponse implements IRolResponse {
    id!: number;
    tenantId?: number | undefined;
    name?: string | undefined;
    displayName?: string | undefined;
    isActive?: boolean | undefined;
    isDeleted?: boolean | undefined;

    constructor(data?: IRolResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
        }
    }

    static fromJS(data: any): RolResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RolResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        return data;
    }
}

export interface IRolResponse {
    id: number;
    tenantId?: number | undefined;
    name?: string | undefined;
    displayName?: string | undefined;
    isActive?: boolean | undefined;
    isDeleted?: boolean | undefined;
}

export class RolGetByIdQuery implements IRolGetByIdQuery {
    id!: number;

    constructor(data?: IRolGetByIdQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RolGetByIdQuery {
        data = typeof data === 'object' ? data : {};
        let result = new RolGetByIdQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IRolGetByIdQuery {
    id: number;
}

export class RolCreateCommand implements IRolCreateCommand {
    id!: number;
    name?: string | undefined;
    displayName?: string | undefined;
    isActive?: boolean | undefined;
    grantedPermissionNames?: string[] | undefined;

    constructor(data?: IRolCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): RolCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RolCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }
}

export interface IRolCreateCommand {
    id: number;
    name?: string | undefined;
    displayName?: string | undefined;
    isActive?: boolean | undefined;
    grantedPermissionNames?: string[] | undefined;
}

export class RolUpdateCommand implements IRolUpdateCommand {
    id!: number;
    name?: string | undefined;
    displayName?: string | undefined;
    isActive?: boolean | undefined;
    isDeleted?: boolean | undefined;
    grantedPermissionNames?: string[] | undefined;

    constructor(data?: IRolUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): RolUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RolUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }
}

export interface IRolUpdateCommand {
    id: number;
    name?: string | undefined;
    displayName?: string | undefined;
    isActive?: boolean | undefined;
    isDeleted?: boolean | undefined;
    grantedPermissionNames?: string[] | undefined;
}

export class RolDeleteCommand implements IRolDeleteCommand {
    id!: number;

    constructor(data?: IRolDeleteCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RolDeleteCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RolDeleteCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IRolDeleteCommand {
    id: number;
}

export class RolForEditReponse implements IRolForEditReponse {
    id!: number;
    tenantId?: number | undefined;
    name?: string | undefined;
    displayName?: string | undefined;
    isActive?: boolean | undefined;
    permisoList?: RolPermisoResponse[] | undefined;

    constructor(data?: IRolForEditReponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["permisoList"])) {
                this.permisoList = [] as any;
                for (let item of _data["permisoList"])
                    this.permisoList!.push(RolPermisoResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RolForEditReponse {
        data = typeof data === 'object' ? data : {};
        let result = new RolForEditReponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.permisoList)) {
            data["permisoList"] = [];
            for (let item of this.permisoList)
                data["permisoList"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRolForEditReponse {
    id: number;
    tenantId?: number | undefined;
    name?: string | undefined;
    displayName?: string | undefined;
    isActive?: boolean | undefined;
    permisoList?: RolPermisoResponse[] | undefined;
}

export class RolPermisoResponse implements IRolPermisoResponse {
    id!: number;
    name?: string | undefined;

    constructor(data?: IRolPermisoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RolPermisoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RolPermisoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IRolPermisoResponse {
    id: number;
    name?: string | undefined;
}

export class RolGetForEditQuery implements IRolGetForEditQuery {
    id!: number;

    constructor(data?: IRolGetForEditQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RolGetForEditQuery {
        data = typeof data === 'object' ? data : {};
        let result = new RolGetForEditQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IRolGetForEditQuery {
    id: number;
}

export class RolForListActiveResponse implements IRolForListActiveResponse {
    id!: number;
    name?: string | undefined;
    displayName?: string | undefined;

    constructor(data?: IRolForListActiveResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): RolForListActiveResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RolForListActiveResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IRolForListActiveResponse {
    id: number;
    name?: string | undefined;
    displayName?: string | undefined;
}

export class RolGetForListActiveQuery implements IRolGetForListActiveQuery {

    constructor(data?: IRolGetForListActiveQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): RolGetForListActiveQuery {
        data = typeof data === 'object' ? data : {};
        let result = new RolGetForListActiveQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IRolGetForListActiveQuery {
}

export class WeatherForecast implements IWeatherForecast {
    dateFormatted?: string | undefined;
    temperatureC!: number;
    summary?: string | undefined;
    temperatureF!: number;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateFormatted = _data["dateFormatted"];
            this.temperatureC = _data["temperatureC"];
            this.summary = _data["summary"];
            this.temperatureF = _data["temperatureF"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateFormatted"] = this.dateFormatted;
        data["temperatureC"] = this.temperatureC;
        data["summary"] = this.summary;
        data["temperatureF"] = this.temperatureF;
        return data;
    }
}

export interface IWeatherForecast {
    dateFormatted?: string | undefined;
    temperatureC: number;
    summary?: string | undefined;
    temperatureF: number;
}

export class PagedResultDtoOfSampleDateDataForListResponse implements IPagedResultDtoOfSampleDateDataForListResponse {
    totalCount!: number;
    items?: SampleDateDataForListResponse[] | undefined;

    constructor(data?: IPagedResultDtoOfSampleDateDataForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SampleDateDataForListResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSampleDateDataForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSampleDateDataForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfSampleDateDataForListResponse {
    totalCount: number;
    items?: SampleDateDataForListResponse[] | undefined;
}

export class SampleDateDataForListResponse implements ISampleDateDataForListResponse {
    id?: number | undefined;
    name?: string | undefined;
    dateTimeData?: moment.Moment | undefined;
    dateData?: moment.Moment | undefined;
    timeData?: moment.Duration | undefined;

    constructor(data?: ISampleDateDataForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.dateTimeData = _data["dateTimeData"] ? moment(_data["dateTimeData"].toString()) : <any>undefined;
            this.dateData = _data["dateData"] ? moment(_data["dateData"].toString()) : <any>undefined;
            this.timeData = _data["timeData"] ? moment.duration(_data["timeData"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SampleDateDataForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SampleDateDataForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["dateTimeData"] = this.dateTimeData ? this.dateTimeData.toISOString() : <any>undefined;
        data["dateData"] = this.dateData ? this.dateData.toISOString() : <any>undefined;
        data["timeData"] = this.timeData ? this.timeData.format('d.hh:mm:ss.SS', { trim: false }) : <any>undefined;
        return data;
    }
}

export interface ISampleDateDataForListResponse {
    id?: number | undefined;
    name?: string | undefined;
    dateTimeData?: moment.Moment | undefined;
    dateData?: moment.Moment | undefined;
    timeData?: moment.Duration | undefined;
}

export class SampleDateDataGetListQuery extends PageListByDto implements ISampleDateDataGetListQuery {

    constructor(data?: ISampleDateDataGetListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SampleDateDataGetListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new SampleDateDataGetListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISampleDateDataGetListQuery extends IPageListByDto {
}

export class SampleDateDataResponse implements ISampleDateDataResponse {
    id?: number | undefined;
    name?: string | undefined;
    dateTimeData?: moment.Moment | undefined;
    dateData?: moment.Moment | undefined;
    timeData?: moment.Duration | undefined;

    constructor(data?: ISampleDateDataResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.dateTimeData = _data["dateTimeData"] ? moment(_data["dateTimeData"].toString()) : <any>undefined;
            this.dateData = _data["dateData"] ? moment(_data["dateData"].toString()) : <any>undefined;
            this.timeData = _data["timeData"] ? moment.duration(_data["timeData"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SampleDateDataResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SampleDateDataResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["dateTimeData"] = this.dateTimeData ? this.dateTimeData.toISOString() : <any>undefined;
        data["dateData"] = this.dateData ? this.dateData.toISOString() : <any>undefined;
        data["timeData"] = this.timeData ? this.timeData.format('d.hh:mm:ss.SS', { trim: false }) : <any>undefined;
        return data;
    }
}

export interface ISampleDateDataResponse {
    id?: number | undefined;
    name?: string | undefined;
    dateTimeData?: moment.Moment | undefined;
    dateData?: moment.Moment | undefined;
    timeData?: moment.Duration | undefined;
}

export class SampleDateDataForEditResponse implements ISampleDateDataForEditResponse {
    id?: number | undefined;
    name?: string | undefined;
    dateTimeData?: moment.Moment | undefined;
    dateData?: moment.Moment | undefined;
    timeData?: moment.Duration | undefined;

    constructor(data?: ISampleDateDataForEditResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.dateTimeData = _data["dateTimeData"] ? moment(_data["dateTimeData"].toString()) : <any>undefined;
            this.dateData = _data["dateData"] ? moment(_data["dateData"].toString()) : <any>undefined;
            this.timeData = _data["timeData"] ? moment.duration(_data["timeData"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SampleDateDataForEditResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SampleDateDataForEditResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["dateTimeData"] = this.dateTimeData ? this.dateTimeData.toISOString() : <any>undefined;
        data["dateData"] = this.dateData ? this.dateData.toISOString() : <any>undefined;
        data["timeData"] = this.timeData ? this.timeData.format('d.hh:mm:ss.SS', { trim: false }) : <any>undefined;
        return data;
    }
}

export interface ISampleDateDataForEditResponse {
    id?: number | undefined;
    name?: string | undefined;
    dateTimeData?: moment.Moment | undefined;
    dateData?: moment.Moment | undefined;
    timeData?: moment.Duration | undefined;
}

export class SampleDateDataGetForEditQuery implements ISampleDateDataGetForEditQuery {
    id?: number | undefined;

    constructor(data?: ISampleDateDataGetForEditQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SampleDateDataGetForEditQuery {
        data = typeof data === 'object' ? data : {};
        let result = new SampleDateDataGetForEditQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ISampleDateDataGetForEditQuery {
    id?: number | undefined;
}

export class SampleDateDataCreateCommand implements ISampleDateDataCreateCommand {
    name?: string | undefined;
    dateTimeData?: moment.Moment | undefined;
    dateData?: moment.Moment | undefined;
    timeData?: moment.Duration | undefined;

    constructor(data?: ISampleDateDataCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.dateTimeData = _data["dateTimeData"] ? moment(_data["dateTimeData"].toString()) : <any>undefined;
            this.dateData = _data["dateData"] ? moment(_data["dateData"].toString()) : <any>undefined;
            this.timeData = _data["timeData"] ? moment.duration(_data["timeData"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SampleDateDataCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SampleDateDataCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["dateTimeData"] = this.dateTimeData ? this.dateTimeData.toISOString() : <any>undefined;
        data["dateData"] = this.dateData ? this.dateData.toISOString() : <any>undefined;
        data["timeData"] = this.timeData ? this.timeData.format('d.hh:mm:ss.SS', { trim: false }) : <any>undefined;
        return data;
    }
}

export interface ISampleDateDataCreateCommand {
    name?: string | undefined;
    dateTimeData?: moment.Moment | undefined;
    dateData?: moment.Moment | undefined;
    timeData?: moment.Duration | undefined;
}

export class SampleDateDataUpdateCommand implements ISampleDateDataUpdateCommand {
    id!: number;
    name?: string | undefined;
    dateTimeData?: moment.Moment | undefined;
    dateData?: moment.Moment | undefined;
    timeData?: moment.Duration | undefined;

    constructor(data?: ISampleDateDataUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.dateTimeData = _data["dateTimeData"] ? moment(_data["dateTimeData"].toString()) : <any>undefined;
            this.dateData = _data["dateData"] ? moment(_data["dateData"].toString()) : <any>undefined;
            this.timeData = _data["timeData"] ? moment.duration(_data["timeData"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SampleDateDataUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SampleDateDataUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["dateTimeData"] = this.dateTimeData ? this.dateTimeData.toISOString() : <any>undefined;
        data["dateData"] = this.dateData ? this.dateData.toISOString() : <any>undefined;
        data["timeData"] = this.timeData ? this.timeData.format('d.hh:mm:ss.SS', { trim: false }) : <any>undefined;
        return data;
    }
}

export interface ISampleDateDataUpdateCommand {
    id: number;
    name?: string | undefined;
    dateTimeData?: moment.Moment | undefined;
    dateData?: moment.Moment | undefined;
    timeData?: moment.Duration | undefined;
}

export class SampleDateDataConvertCommand implements ISampleDateDataConvertCommand {
    timeZoneFrom?: string | undefined;
    timeZoneTo?: string | undefined;
    dateTimeDataToConvert?: moment.Moment | undefined;

    constructor(data?: ISampleDateDataConvertCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeZoneFrom = _data["timeZoneFrom"];
            this.timeZoneTo = _data["timeZoneTo"];
            this.dateTimeDataToConvert = _data["dateTimeDataToConvert"] ? moment(_data["dateTimeDataToConvert"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SampleDateDataConvertCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SampleDateDataConvertCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZoneFrom"] = this.timeZoneFrom;
        data["timeZoneTo"] = this.timeZoneTo;
        data["dateTimeDataToConvert"] = this.dateTimeDataToConvert ? this.dateTimeDataToConvert.toISOString() : <any>undefined;
        return data;
    }
}

export interface ISampleDateDataConvertCommand {
    timeZoneFrom?: string | undefined;
    timeZoneTo?: string | undefined;
    dateTimeDataToConvert?: moment.Moment | undefined;
}

export class SettingClientChangeCommand implements ISettingClientChangeCommand {
    id!: number;
    clientType?: string | undefined;
    name?: string | undefined;
    value?: string | undefined;

    constructor(data?: ISettingClientChangeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientType = _data["clientType"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SettingClientChangeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SettingClientChangeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientType"] = this.clientType;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface ISettingClientChangeCommand {
    id: number;
    clientType?: string | undefined;
    name?: string | undefined;
    value?: string | undefined;
}

export class TemplateForListResponse implements ITemplateForListResponse {
    id?: number | undefined;
    rgbColor?: string | undefined;
    nameSingular?: string | undefined;
    namePlural?: string | undefined;
    description?: string | undefined;
    icon?: string | undefined;
    tableName?: string | undefined;
    isTableGenerated!: boolean;
    hasChatRoom!: boolean;
    isActivity!: boolean;
    hasSecurity!: boolean;
    isActive!: boolean;

    constructor(data?: ITemplateForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.rgbColor = _data["rgbColor"];
            this.nameSingular = _data["nameSingular"];
            this.namePlural = _data["namePlural"];
            this.description = _data["description"];
            this.icon = _data["icon"];
            this.tableName = _data["tableName"];
            this.isTableGenerated = _data["isTableGenerated"];
            this.hasChatRoom = _data["hasChatRoom"];
            this.isActivity = _data["isActivity"];
            this.hasSecurity = _data["hasSecurity"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): TemplateForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rgbColor"] = this.rgbColor;
        data["nameSingular"] = this.nameSingular;
        data["namePlural"] = this.namePlural;
        data["description"] = this.description;
        data["icon"] = this.icon;
        data["tableName"] = this.tableName;
        data["isTableGenerated"] = this.isTableGenerated;
        data["hasChatRoom"] = this.hasChatRoom;
        data["isActivity"] = this.isActivity;
        data["hasSecurity"] = this.hasSecurity;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ITemplateForListResponse {
    id?: number | undefined;
    rgbColor?: string | undefined;
    nameSingular?: string | undefined;
    namePlural?: string | undefined;
    description?: string | undefined;
    icon?: string | undefined;
    tableName?: string | undefined;
    isTableGenerated: boolean;
    hasChatRoom: boolean;
    isActivity: boolean;
    hasSecurity: boolean;
    isActive: boolean;
}

export class TemplateForEditResponse implements ITemplateForEditResponse {
    id?: number | undefined;
    rgbColor?: string | undefined;
    nameSingular?: string | undefined;
    namePlural?: string | undefined;
    description?: string | undefined;
    icon?: string | undefined;
    tableName?: string | undefined;
    isTableGenerated!: boolean;
    hasChatRoom!: boolean;
    isActivity!: boolean;
    hasSecurity!: boolean;
    isActive!: boolean;

    constructor(data?: ITemplateForEditResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.rgbColor = _data["rgbColor"];
            this.nameSingular = _data["nameSingular"];
            this.namePlural = _data["namePlural"];
            this.description = _data["description"];
            this.icon = _data["icon"];
            this.tableName = _data["tableName"];
            this.isTableGenerated = _data["isTableGenerated"];
            this.hasChatRoom = _data["hasChatRoom"];
            this.isActivity = _data["isActivity"];
            this.hasSecurity = _data["hasSecurity"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): TemplateForEditResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateForEditResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rgbColor"] = this.rgbColor;
        data["nameSingular"] = this.nameSingular;
        data["namePlural"] = this.namePlural;
        data["description"] = this.description;
        data["icon"] = this.icon;
        data["tableName"] = this.tableName;
        data["isTableGenerated"] = this.isTableGenerated;
        data["hasChatRoom"] = this.hasChatRoom;
        data["isActivity"] = this.isActivity;
        data["hasSecurity"] = this.hasSecurity;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ITemplateForEditResponse {
    id?: number | undefined;
    rgbColor?: string | undefined;
    nameSingular?: string | undefined;
    namePlural?: string | undefined;
    description?: string | undefined;
    icon?: string | undefined;
    tableName?: string | undefined;
    isTableGenerated: boolean;
    hasChatRoom: boolean;
    isActivity: boolean;
    hasSecurity: boolean;
    isActive: boolean;
}

export class TemplateGetForEditQuery implements ITemplateGetForEditQuery {
    id?: number | undefined;

    constructor(data?: ITemplateGetForEditQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TemplateGetForEditQuery {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateGetForEditQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ITemplateGetForEditQuery {
    id?: number | undefined;
}

export class TemplateCreateCommand implements ITemplateCreateCommand {
    rgbColor?: string | undefined;
    nameSingular?: string | undefined;
    namePlural?: string | undefined;
    description?: string | undefined;
    hasChatRoom!: boolean;
    isActivity!: boolean;
    hasSecurity!: boolean;
    isActive!: boolean;
    iconName?: string | undefined;

    constructor(data?: ITemplateCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rgbColor = _data["rgbColor"];
            this.nameSingular = _data["nameSingular"];
            this.namePlural = _data["namePlural"];
            this.description = _data["description"];
            this.hasChatRoom = _data["hasChatRoom"];
            this.isActivity = _data["isActivity"];
            this.hasSecurity = _data["hasSecurity"];
            this.isActive = _data["isActive"];
            this.iconName = _data["iconName"];
        }
    }

    static fromJS(data: any): TemplateCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rgbColor"] = this.rgbColor;
        data["nameSingular"] = this.nameSingular;
        data["namePlural"] = this.namePlural;
        data["description"] = this.description;
        data["hasChatRoom"] = this.hasChatRoom;
        data["isActivity"] = this.isActivity;
        data["hasSecurity"] = this.hasSecurity;
        data["isActive"] = this.isActive;
        data["iconName"] = this.iconName;
        return data;
    }
}

export interface ITemplateCreateCommand {
    rgbColor?: string | undefined;
    nameSingular?: string | undefined;
    namePlural?: string | undefined;
    description?: string | undefined;
    hasChatRoom: boolean;
    isActivity: boolean;
    hasSecurity: boolean;
    isActive: boolean;
    iconName?: string | undefined;
}

export class TemplateUpdateCommand implements ITemplateUpdateCommand {
    id!: number;
    rgbColor?: string | undefined;
    nameSingular?: string | undefined;
    namePlural?: string | undefined;
    description?: string | undefined;
    hasChatRoom!: boolean;
    isActivity!: boolean;
    hasSecurity!: boolean;
    isActive!: boolean;
    iconName?: string | undefined;

    constructor(data?: ITemplateUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.rgbColor = _data["rgbColor"];
            this.nameSingular = _data["nameSingular"];
            this.namePlural = _data["namePlural"];
            this.description = _data["description"];
            this.hasChatRoom = _data["hasChatRoom"];
            this.isActivity = _data["isActivity"];
            this.hasSecurity = _data["hasSecurity"];
            this.isActive = _data["isActive"];
            this.iconName = _data["iconName"];
        }
    }

    static fromJS(data: any): TemplateUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rgbColor"] = this.rgbColor;
        data["nameSingular"] = this.nameSingular;
        data["namePlural"] = this.namePlural;
        data["description"] = this.description;
        data["hasChatRoom"] = this.hasChatRoom;
        data["isActivity"] = this.isActivity;
        data["hasSecurity"] = this.hasSecurity;
        data["isActive"] = this.isActive;
        data["iconName"] = this.iconName;
        return data;
    }
}

export interface ITemplateUpdateCommand {
    id: number;
    rgbColor?: string | undefined;
    nameSingular?: string | undefined;
    namePlural?: string | undefined;
    description?: string | undefined;
    hasChatRoom: boolean;
    isActivity: boolean;
    hasSecurity: boolean;
    isActive: boolean;
    iconName?: string | undefined;
}

export class PagedResultDtoOfTemplateSectionForListResponse implements IPagedResultDtoOfTemplateSectionForListResponse {
    totalCount!: number;
    items?: TemplateSectionForListResponse[] | undefined;

    constructor(data?: IPagedResultDtoOfTemplateSectionForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TemplateSectionForListResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTemplateSectionForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTemplateSectionForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTemplateSectionForListResponse {
    totalCount: number;
    items?: TemplateSectionForListResponse[] | undefined;
}

export class TemplateSectionForListResponse implements ITemplateSectionForListResponse {
    id!: number;
    template?: number | undefined;
    templateDesc?: string | undefined;
    name?: string | undefined;
    order?: number | undefined;
    iconAF?: string | undefined;

    constructor(data?: ITemplateSectionForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.template = _data["template"];
            this.templateDesc = _data["templateDesc"];
            this.name = _data["name"];
            this.order = _data["order"];
            this.iconAF = _data["iconAF"];
        }
    }

    static fromJS(data: any): TemplateSectionForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateSectionForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["template"] = this.template;
        data["templateDesc"] = this.templateDesc;
        data["name"] = this.name;
        data["order"] = this.order;
        data["iconAF"] = this.iconAF;
        return data;
    }
}

export interface ITemplateSectionForListResponse {
    id: number;
    template?: number | undefined;
    templateDesc?: string | undefined;
    name?: string | undefined;
    order?: number | undefined;
    iconAF?: string | undefined;
}

export class TemplateSectionGetListQuery extends PageListByDto implements ITemplateSectionGetListQuery {
    template?: number | undefined;

    constructor(data?: ITemplateSectionGetListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.template = _data["template"];
        }
    }

    static override fromJS(data: any): TemplateSectionGetListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateSectionGetListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template;
        super.toJSON(data);
        return data;
    }
}

export interface ITemplateSectionGetListQuery extends IPageListByDto {
    template?: number | undefined;
}

export class TemplateSectionResponse implements ITemplateSectionResponse {
    id!: number;
    template?: number | undefined;
    templateDesc?: string | undefined;
    name?: string | undefined;
    order?: number | undefined;
    iconAF?: string | undefined;

    constructor(data?: ITemplateSectionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.template = _data["template"];
            this.templateDesc = _data["templateDesc"];
            this.name = _data["name"];
            this.order = _data["order"];
            this.iconAF = _data["iconAF"];
        }
    }

    static fromJS(data: any): TemplateSectionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateSectionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["template"] = this.template;
        data["templateDesc"] = this.templateDesc;
        data["name"] = this.name;
        data["order"] = this.order;
        data["iconAF"] = this.iconAF;
        return data;
    }
}

export interface ITemplateSectionResponse {
    id: number;
    template?: number | undefined;
    templateDesc?: string | undefined;
    name?: string | undefined;
    order?: number | undefined;
    iconAF?: string | undefined;
}

export class TemplateSectionForEditResponse implements ITemplateSectionForEditResponse {
    id?: number | undefined;
    template?: number | undefined;
    name?: string | undefined;
    order?: number | undefined;
    iconAF?: string | undefined;

    constructor(data?: ITemplateSectionForEditResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.template = _data["template"];
            this.name = _data["name"];
            this.order = _data["order"];
            this.iconAF = _data["iconAF"];
        }
    }

    static fromJS(data: any): TemplateSectionForEditResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateSectionForEditResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["template"] = this.template;
        data["name"] = this.name;
        data["order"] = this.order;
        data["iconAF"] = this.iconAF;
        return data;
    }
}

export interface ITemplateSectionForEditResponse {
    id?: number | undefined;
    template?: number | undefined;
    name?: string | undefined;
    order?: number | undefined;
    iconAF?: string | undefined;
}

export class TemplateSectionGetForEditQuery implements ITemplateSectionGetForEditQuery {
    id?: number | undefined;

    constructor(data?: ITemplateSectionGetForEditQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TemplateSectionGetForEditQuery {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateSectionGetForEditQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ITemplateSectionGetForEditQuery {
    id?: number | undefined;
}

export class TemplateSectionCreateCommand implements ITemplateSectionCreateCommand {
    template?: number | undefined;
    name?: string | undefined;
    order?: number | undefined;
    iconAF?: string | undefined;

    constructor(data?: ITemplateSectionCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.template = _data["template"];
            this.name = _data["name"];
            this.order = _data["order"];
            this.iconAF = _data["iconAF"];
        }
    }

    static fromJS(data: any): TemplateSectionCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateSectionCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template;
        data["name"] = this.name;
        data["order"] = this.order;
        data["iconAF"] = this.iconAF;
        return data;
    }
}

export interface ITemplateSectionCreateCommand {
    template?: number | undefined;
    name?: string | undefined;
    order?: number | undefined;
    iconAF?: string | undefined;
}

export class TemplateSectionUpdateCommand implements ITemplateSectionUpdateCommand {
    id!: number;
    template?: number | undefined;
    name?: string | undefined;
    order?: number | undefined;
    iconAF?: string | undefined;

    constructor(data?: ITemplateSectionUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.template = _data["template"];
            this.name = _data["name"];
            this.order = _data["order"];
            this.iconAF = _data["iconAF"];
        }
    }

    static fromJS(data: any): TemplateSectionUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateSectionUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["template"] = this.template;
        data["name"] = this.name;
        data["order"] = this.order;
        data["iconAF"] = this.iconAF;
        return data;
    }
}

export interface ITemplateSectionUpdateCommand {
    id: number;
    template?: number | undefined;
    name?: string | undefined;
    order?: number | undefined;
    iconAF?: string | undefined;
}

export class PagedResultDtoOfTemplateFieldForListResponse implements IPagedResultDtoOfTemplateFieldForListResponse {
    totalCount!: number;
    items?: TemplateFieldForListResponse[] | undefined;

    constructor(data?: IPagedResultDtoOfTemplateFieldForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TemplateFieldForListResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTemplateFieldForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTemplateFieldForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTemplateFieldForListResponse {
    totalCount: number;
    items?: TemplateFieldForListResponse[] | undefined;
}

export class TemplateFieldForListResponse implements ITemplateFieldForListResponse {
    id!: number;
    templateSection?: number | undefined;
    templateSectionDesc?: string | undefined;
    templateSectionIconAF?: string | undefined;
    templateSectionOrder?: number | undefined;
    name?: string | undefined;
    fieldName?: string | undefined;
    fieldTypeDesc?: string | undefined;
    fieldSize?: number | undefined;
    fieldControlDesc?: string | undefined;
    inputMask?: string | undefined;
    keyFilter?: string | undefined;
    status!: TemplateFieldStatus;
    statusDesc?: string | undefined;
    isRequiredDesc?: string | undefined;
    showOnGridDesc?: string | undefined;
    order?: number | undefined;
    mustHaveOptions!: boolean;

    constructor(data?: ITemplateFieldForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.templateSection = _data["templateSection"];
            this.templateSectionDesc = _data["templateSectionDesc"];
            this.templateSectionIconAF = _data["templateSectionIconAF"];
            this.templateSectionOrder = _data["templateSectionOrder"];
            this.name = _data["name"];
            this.fieldName = _data["fieldName"];
            this.fieldTypeDesc = _data["fieldTypeDesc"];
            this.fieldSize = _data["fieldSize"];
            this.fieldControlDesc = _data["fieldControlDesc"];
            this.inputMask = _data["inputMask"];
            this.keyFilter = _data["keyFilter"];
            this.status = _data["status"];
            this.statusDesc = _data["statusDesc"];
            this.isRequiredDesc = _data["isRequiredDesc"];
            this.showOnGridDesc = _data["showOnGridDesc"];
            this.order = _data["order"];
            this.mustHaveOptions = _data["mustHaveOptions"];
        }
    }

    static fromJS(data: any): TemplateFieldForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateFieldForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["templateSection"] = this.templateSection;
        data["templateSectionDesc"] = this.templateSectionDesc;
        data["templateSectionIconAF"] = this.templateSectionIconAF;
        data["templateSectionOrder"] = this.templateSectionOrder;
        data["name"] = this.name;
        data["fieldName"] = this.fieldName;
        data["fieldTypeDesc"] = this.fieldTypeDesc;
        data["fieldSize"] = this.fieldSize;
        data["fieldControlDesc"] = this.fieldControlDesc;
        data["inputMask"] = this.inputMask;
        data["keyFilter"] = this.keyFilter;
        data["status"] = this.status;
        data["statusDesc"] = this.statusDesc;
        data["isRequiredDesc"] = this.isRequiredDesc;
        data["showOnGridDesc"] = this.showOnGridDesc;
        data["order"] = this.order;
        data["mustHaveOptions"] = this.mustHaveOptions;
        return data;
    }
}

export interface ITemplateFieldForListResponse {
    id: number;
    templateSection?: number | undefined;
    templateSectionDesc?: string | undefined;
    templateSectionIconAF?: string | undefined;
    templateSectionOrder?: number | undefined;
    name?: string | undefined;
    fieldName?: string | undefined;
    fieldTypeDesc?: string | undefined;
    fieldSize?: number | undefined;
    fieldControlDesc?: string | undefined;
    inputMask?: string | undefined;
    keyFilter?: string | undefined;
    status: TemplateFieldStatus;
    statusDesc?: string | undefined;
    isRequiredDesc?: string | undefined;
    showOnGridDesc?: string | undefined;
    order?: number | undefined;
    mustHaveOptions: boolean;
}

export class TemplateFieldGetListQuery extends PageListByDto implements ITemplateFieldGetListQuery {
    onlyProcessed!: boolean;
    template?: number | undefined;
    templateSection?: number | undefined;

    constructor(data?: ITemplateFieldGetListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.onlyProcessed = _data["onlyProcessed"];
            this.template = _data["template"];
            this.templateSection = _data["templateSection"];
        }
    }

    static override fromJS(data: any): TemplateFieldGetListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateFieldGetListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onlyProcessed"] = this.onlyProcessed;
        data["template"] = this.template;
        data["templateSection"] = this.templateSection;
        super.toJSON(data);
        return data;
    }
}

export interface ITemplateFieldGetListQuery extends IPageListByDto {
    onlyProcessed: boolean;
    template?: number | undefined;
    templateSection?: number | undefined;
}

export class TemplateFieldGetListByTemplateQuery implements ITemplateFieldGetListByTemplateQuery {
    onlyProcessed!: boolean;
    template!: number;

    constructor(data?: ITemplateFieldGetListByTemplateQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onlyProcessed = _data["onlyProcessed"];
            this.template = _data["template"];
        }
    }

    static fromJS(data: any): TemplateFieldGetListByTemplateQuery {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateFieldGetListByTemplateQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onlyProcessed"] = this.onlyProcessed;
        data["template"] = this.template;
        return data;
    }
}

export interface ITemplateFieldGetListByTemplateQuery {
    onlyProcessed: boolean;
    template: number;
}

export class TemplateFieldGetComboQuery implements ITemplateFieldGetComboQuery {
    template?: number | undefined;

    constructor(data?: ITemplateFieldGetComboQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.template = _data["template"];
        }
    }

    static fromJS(data: any): TemplateFieldGetComboQuery {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateFieldGetComboQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template;
        return data;
    }
}

export interface ITemplateFieldGetComboQuery {
    template?: number | undefined;
}

export class TemplateFieldForEditResponse implements ITemplateFieldForEditResponse {
    id?: number | undefined;
    templateSection?: number | undefined;
    templateSectionDesc?: string | undefined;
    templateSectionIconAF?: string | undefined;
    name?: string | undefined;
    fieldName?: string | undefined;
    fieldType?: TemplateFieldType | undefined;
    fieldSize?: number | undefined;
    fieldControl?: TemplateFieldControl | undefined;
    inputMask?: string | undefined;
    hasKeyFilter!: boolean;
    keyFilter?: string | undefined;
    status?: TemplateFieldStatus | undefined;
    statusDesc?: string | undefined;
    isRequired!: boolean;
    showOnGrid!: boolean;
    order?: number | undefined;
    inheritSecurity!: boolean;
    templateFieldRelationTemplate?: number | undefined;
    templateFieldRelationTemplateDesc?: string | undefined;
    templateFieldRelationTemplateField?: number | undefined;
    templateFieldRelationTemplateFieldDesc?: string | undefined;
    options?: TemplateFieldOptionDto[] | undefined;
    templateCombo?: ComboboxItemDto[] | undefined;
    templateFieldCombo?: ComboboxItemDto[] | undefined;

    constructor(data?: ITemplateFieldForEditResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.templateSection = _data["templateSection"];
            this.templateSectionDesc = _data["templateSectionDesc"];
            this.templateSectionIconAF = _data["templateSectionIconAF"];
            this.name = _data["name"];
            this.fieldName = _data["fieldName"];
            this.fieldType = _data["fieldType"];
            this.fieldSize = _data["fieldSize"];
            this.fieldControl = _data["fieldControl"];
            this.inputMask = _data["inputMask"];
            this.hasKeyFilter = _data["hasKeyFilter"];
            this.keyFilter = _data["keyFilter"];
            this.status = _data["status"];
            this.statusDesc = _data["statusDesc"];
            this.isRequired = _data["isRequired"];
            this.showOnGrid = _data["showOnGrid"];
            this.order = _data["order"];
            this.inheritSecurity = _data["inheritSecurity"];
            this.templateFieldRelationTemplate = _data["templateFieldRelationTemplate"];
            this.templateFieldRelationTemplateDesc = _data["templateFieldRelationTemplateDesc"];
            this.templateFieldRelationTemplateField = _data["templateFieldRelationTemplateField"];
            this.templateFieldRelationTemplateFieldDesc = _data["templateFieldRelationTemplateFieldDesc"];
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(TemplateFieldOptionDto.fromJS(item));
            }
            if (Array.isArray(_data["templateCombo"])) {
                this.templateCombo = [] as any;
                for (let item of _data["templateCombo"])
                    this.templateCombo!.push(ComboboxItemDto.fromJS(item));
            }
            if (Array.isArray(_data["templateFieldCombo"])) {
                this.templateFieldCombo = [] as any;
                for (let item of _data["templateFieldCombo"])
                    this.templateFieldCombo!.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TemplateFieldForEditResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateFieldForEditResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["templateSection"] = this.templateSection;
        data["templateSectionDesc"] = this.templateSectionDesc;
        data["templateSectionIconAF"] = this.templateSectionIconAF;
        data["name"] = this.name;
        data["fieldName"] = this.fieldName;
        data["fieldType"] = this.fieldType;
        data["fieldSize"] = this.fieldSize;
        data["fieldControl"] = this.fieldControl;
        data["inputMask"] = this.inputMask;
        data["hasKeyFilter"] = this.hasKeyFilter;
        data["keyFilter"] = this.keyFilter;
        data["status"] = this.status;
        data["statusDesc"] = this.statusDesc;
        data["isRequired"] = this.isRequired;
        data["showOnGrid"] = this.showOnGrid;
        data["order"] = this.order;
        data["inheritSecurity"] = this.inheritSecurity;
        data["templateFieldRelationTemplate"] = this.templateFieldRelationTemplate;
        data["templateFieldRelationTemplateDesc"] = this.templateFieldRelationTemplateDesc;
        data["templateFieldRelationTemplateField"] = this.templateFieldRelationTemplateField;
        data["templateFieldRelationTemplateFieldDesc"] = this.templateFieldRelationTemplateFieldDesc;
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        if (Array.isArray(this.templateCombo)) {
            data["templateCombo"] = [];
            for (let item of this.templateCombo)
                data["templateCombo"].push(item.toJSON());
        }
        if (Array.isArray(this.templateFieldCombo)) {
            data["templateFieldCombo"] = [];
            for (let item of this.templateFieldCombo)
                data["templateFieldCombo"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITemplateFieldForEditResponse {
    id?: number | undefined;
    templateSection?: number | undefined;
    templateSectionDesc?: string | undefined;
    templateSectionIconAF?: string | undefined;
    name?: string | undefined;
    fieldName?: string | undefined;
    fieldType?: TemplateFieldType | undefined;
    fieldSize?: number | undefined;
    fieldControl?: TemplateFieldControl | undefined;
    inputMask?: string | undefined;
    hasKeyFilter: boolean;
    keyFilter?: string | undefined;
    status?: TemplateFieldStatus | undefined;
    statusDesc?: string | undefined;
    isRequired: boolean;
    showOnGrid: boolean;
    order?: number | undefined;
    inheritSecurity: boolean;
    templateFieldRelationTemplate?: number | undefined;
    templateFieldRelationTemplateDesc?: string | undefined;
    templateFieldRelationTemplateField?: number | undefined;
    templateFieldRelationTemplateFieldDesc?: string | undefined;
    options?: TemplateFieldOptionDto[] | undefined;
    templateCombo?: ComboboxItemDto[] | undefined;
    templateFieldCombo?: ComboboxItemDto[] | undefined;
}

export class TemplateFieldGetForEditQuery implements ITemplateFieldGetForEditQuery {
    id?: number | undefined;

    constructor(data?: ITemplateFieldGetForEditQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TemplateFieldGetForEditQuery {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateFieldGetForEditQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ITemplateFieldGetForEditQuery {
    id?: number | undefined;
}

export class TemplateFieldCreateCommand implements ITemplateFieldCreateCommand {
    templateSection?: number | undefined;
    name?: string | undefined;
    fieldName?: string | undefined;
    fieldType?: TemplateFieldType | undefined;
    fieldSize?: number | undefined;
    fieldControl?: TemplateFieldControl | undefined;
    inputMask?: string | undefined;
    hasKeyFilter!: boolean;
    keyFilter?: string | undefined;
    isRequired!: boolean;
    showOnGrid!: boolean;
    order?: number | undefined;
    inheritSecurity!: boolean;
    templateFieldRelationTemplateField?: number | undefined;
    options?: TemplateFieldOptionDto[] | undefined;

    constructor(data?: ITemplateFieldCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateSection = _data["templateSection"];
            this.name = _data["name"];
            this.fieldName = _data["fieldName"];
            this.fieldType = _data["fieldType"];
            this.fieldSize = _data["fieldSize"];
            this.fieldControl = _data["fieldControl"];
            this.inputMask = _data["inputMask"];
            this.hasKeyFilter = _data["hasKeyFilter"];
            this.keyFilter = _data["keyFilter"];
            this.isRequired = _data["isRequired"];
            this.showOnGrid = _data["showOnGrid"];
            this.order = _data["order"];
            this.inheritSecurity = _data["inheritSecurity"];
            this.templateFieldRelationTemplateField = _data["templateFieldRelationTemplateField"];
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(TemplateFieldOptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TemplateFieldCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateFieldCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateSection"] = this.templateSection;
        data["name"] = this.name;
        data["fieldName"] = this.fieldName;
        data["fieldType"] = this.fieldType;
        data["fieldSize"] = this.fieldSize;
        data["fieldControl"] = this.fieldControl;
        data["inputMask"] = this.inputMask;
        data["hasKeyFilter"] = this.hasKeyFilter;
        data["keyFilter"] = this.keyFilter;
        data["isRequired"] = this.isRequired;
        data["showOnGrid"] = this.showOnGrid;
        data["order"] = this.order;
        data["inheritSecurity"] = this.inheritSecurity;
        data["templateFieldRelationTemplateField"] = this.templateFieldRelationTemplateField;
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITemplateFieldCreateCommand {
    templateSection?: number | undefined;
    name?: string | undefined;
    fieldName?: string | undefined;
    fieldType?: TemplateFieldType | undefined;
    fieldSize?: number | undefined;
    fieldControl?: TemplateFieldControl | undefined;
    inputMask?: string | undefined;
    hasKeyFilter: boolean;
    keyFilter?: string | undefined;
    isRequired: boolean;
    showOnGrid: boolean;
    order?: number | undefined;
    inheritSecurity: boolean;
    templateFieldRelationTemplateField?: number | undefined;
    options?: TemplateFieldOptionDto[] | undefined;
}

export class TemplateFieldUpdateCommand implements ITemplateFieldUpdateCommand {
    id!: number;
    templateSection?: number | undefined;
    name?: string | undefined;
    fieldName?: string | undefined;
    fieldType?: TemplateFieldType | undefined;
    fieldSize?: number | undefined;
    fieldControl?: TemplateFieldControl | undefined;
    inputMask?: string | undefined;
    hasKeyFilter!: boolean;
    keyFilter?: string | undefined;
    status?: TemplateFieldStatus | undefined;
    isRequired!: boolean;
    showOnGrid!: boolean;
    order?: number | undefined;
    inheritSecurity!: boolean;
    templateFieldRelationTemplateField?: number | undefined;
    options?: TemplateFieldOptionDto[] | undefined;

    constructor(data?: ITemplateFieldUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.templateSection = _data["templateSection"];
            this.name = _data["name"];
            this.fieldName = _data["fieldName"];
            this.fieldType = _data["fieldType"];
            this.fieldSize = _data["fieldSize"];
            this.fieldControl = _data["fieldControl"];
            this.inputMask = _data["inputMask"];
            this.hasKeyFilter = _data["hasKeyFilter"];
            this.keyFilter = _data["keyFilter"];
            this.status = _data["status"];
            this.isRequired = _data["isRequired"];
            this.showOnGrid = _data["showOnGrid"];
            this.order = _data["order"];
            this.inheritSecurity = _data["inheritSecurity"];
            this.templateFieldRelationTemplateField = _data["templateFieldRelationTemplateField"];
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(TemplateFieldOptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TemplateFieldUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateFieldUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["templateSection"] = this.templateSection;
        data["name"] = this.name;
        data["fieldName"] = this.fieldName;
        data["fieldType"] = this.fieldType;
        data["fieldSize"] = this.fieldSize;
        data["fieldControl"] = this.fieldControl;
        data["inputMask"] = this.inputMask;
        data["hasKeyFilter"] = this.hasKeyFilter;
        data["keyFilter"] = this.keyFilter;
        data["status"] = this.status;
        data["isRequired"] = this.isRequired;
        data["showOnGrid"] = this.showOnGrid;
        data["order"] = this.order;
        data["inheritSecurity"] = this.inheritSecurity;
        data["templateFieldRelationTemplateField"] = this.templateFieldRelationTemplateField;
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITemplateFieldUpdateCommand {
    id: number;
    templateSection?: number | undefined;
    name?: string | undefined;
    fieldName?: string | undefined;
    fieldType?: TemplateFieldType | undefined;
    fieldSize?: number | undefined;
    fieldControl?: TemplateFieldControl | undefined;
    inputMask?: string | undefined;
    hasKeyFilter: boolean;
    keyFilter?: string | undefined;
    status?: TemplateFieldStatus | undefined;
    isRequired: boolean;
    showOnGrid: boolean;
    order?: number | undefined;
    inheritSecurity: boolean;
    templateFieldRelationTemplateField?: number | undefined;
    options?: TemplateFieldOptionDto[] | undefined;
}

export class PagedResultDtoOfTemplateToDoStatusForListResponse implements IPagedResultDtoOfTemplateToDoStatusForListResponse {
    totalCount!: number;
    items?: TemplateToDoStatusForListResponse[] | undefined;

    constructor(data?: IPagedResultDtoOfTemplateToDoStatusForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TemplateToDoStatusForListResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTemplateToDoStatusForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTemplateToDoStatusForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTemplateToDoStatusForListResponse {
    totalCount: number;
    items?: TemplateToDoStatusForListResponse[] | undefined;
}

export class TemplateToDoStatusForListResponse implements ITemplateToDoStatusForListResponse {
    id!: number;
    template!: number;
    templateDesc?: string | undefined;
    type!: TemplateToDoStatusType;
    typeDesc?: string | undefined;
    name?: string | undefined;
    isDefault!: boolean;
    isDefaultDesc?: string | undefined;
    isActive!: boolean;
    isActiveDesc?: string | undefined;

    constructor(data?: ITemplateToDoStatusForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.template = _data["template"];
            this.templateDesc = _data["templateDesc"];
            this.type = _data["type"];
            this.typeDesc = _data["typeDesc"];
            this.name = _data["name"];
            this.isDefault = _data["isDefault"];
            this.isDefaultDesc = _data["isDefaultDesc"];
            this.isActive = _data["isActive"];
            this.isActiveDesc = _data["isActiveDesc"];
        }
    }

    static fromJS(data: any): TemplateToDoStatusForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateToDoStatusForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["template"] = this.template;
        data["templateDesc"] = this.templateDesc;
        data["type"] = this.type;
        data["typeDesc"] = this.typeDesc;
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        data["isDefaultDesc"] = this.isDefaultDesc;
        data["isActive"] = this.isActive;
        data["isActiveDesc"] = this.isActiveDesc;
        return data;
    }
}

export interface ITemplateToDoStatusForListResponse {
    id: number;
    template: number;
    templateDesc?: string | undefined;
    type: TemplateToDoStatusType;
    typeDesc?: string | undefined;
    name?: string | undefined;
    isDefault: boolean;
    isDefaultDesc?: string | undefined;
    isActive: boolean;
    isActiveDesc?: string | undefined;
}

export enum TemplateToDoStatusType {
    Pending = 1,
    InRevision = 2,
    Returned = 3,
    Rejected = 4,
    Closed = 5,
    Canceled = 9,
}

export class TemplateToDoStatusGetListQuery extends PageListByDto implements ITemplateToDoStatusGetListQuery {
    template?: number | undefined;

    constructor(data?: ITemplateToDoStatusGetListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.template = _data["template"];
        }
    }

    static override fromJS(data: any): TemplateToDoStatusGetListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateToDoStatusGetListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template;
        super.toJSON(data);
        return data;
    }
}

export interface ITemplateToDoStatusGetListQuery extends IPageListByDto {
    template?: number | undefined;
}

export class TemplateToDoStatusResponse implements ITemplateToDoStatusResponse {
    id!: number;
    template!: number;
    type!: TemplateToDoStatusType;
    name?: string | undefined;
    isDefault!: boolean;
    isActive!: boolean;

    constructor(data?: ITemplateToDoStatusResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.template = _data["template"];
            this.type = _data["type"];
            this.name = _data["name"];
            this.isDefault = _data["isDefault"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): TemplateToDoStatusResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateToDoStatusResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["template"] = this.template;
        data["type"] = this.type;
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ITemplateToDoStatusResponse {
    id: number;
    template: number;
    type: TemplateToDoStatusType;
    name?: string | undefined;
    isDefault: boolean;
    isActive: boolean;
}

export class TemplateToDoStatusForEditResponse implements ITemplateToDoStatusForEditResponse {
    id?: number | undefined;
    template!: number;
    type!: TemplateToDoStatusType;
    name?: string | undefined;
    isDefault!: boolean;
    isActive!: boolean;

    constructor(data?: ITemplateToDoStatusForEditResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.template = _data["template"];
            this.type = _data["type"];
            this.name = _data["name"];
            this.isDefault = _data["isDefault"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): TemplateToDoStatusForEditResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateToDoStatusForEditResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["template"] = this.template;
        data["type"] = this.type;
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ITemplateToDoStatusForEditResponse {
    id?: number | undefined;
    template: number;
    type: TemplateToDoStatusType;
    name?: string | undefined;
    isDefault: boolean;
    isActive: boolean;
}

export class TemplateToDoStatusGetForEditQuery implements ITemplateToDoStatusGetForEditQuery {
    id?: number | undefined;

    constructor(data?: ITemplateToDoStatusGetForEditQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TemplateToDoStatusGetForEditQuery {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateToDoStatusGetForEditQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ITemplateToDoStatusGetForEditQuery {
    id?: number | undefined;
}

export class TemplateToDoStatusCreateCommand implements ITemplateToDoStatusCreateCommand {
    template!: number;
    type!: TemplateToDoStatusType;
    name?: string | undefined;
    isDefault!: boolean;
    isActive!: boolean;

    constructor(data?: ITemplateToDoStatusCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.template = _data["template"];
            this.type = _data["type"];
            this.name = _data["name"];
            this.isDefault = _data["isDefault"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): TemplateToDoStatusCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateToDoStatusCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template;
        data["type"] = this.type;
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ITemplateToDoStatusCreateCommand {
    template: number;
    type: TemplateToDoStatusType;
    name?: string | undefined;
    isDefault: boolean;
    isActive: boolean;
}

export class TemplateToDoStatusUpdateCommand implements ITemplateToDoStatusUpdateCommand {
    id!: number;
    type!: TemplateToDoStatusType;
    name?: string | undefined;
    isDefault!: boolean;
    isActive!: boolean;

    constructor(data?: ITemplateToDoStatusUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.name = _data["name"];
            this.isDefault = _data["isDefault"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): TemplateToDoStatusUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateToDoStatusUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ITemplateToDoStatusUpdateCommand {
    id: number;
    type: TemplateToDoStatusType;
    name?: string | undefined;
    isDefault: boolean;
    isActive: boolean;
}

export class PagedResultDtoOfTemplateSecurityMemberForListResponse implements IPagedResultDtoOfTemplateSecurityMemberForListResponse {
    totalCount!: number;
    items?: TemplateSecurityMemberForListResponse[] | undefined;

    constructor(data?: IPagedResultDtoOfTemplateSecurityMemberForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TemplateSecurityMemberForListResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTemplateSecurityMemberForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTemplateSecurityMemberForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTemplateSecurityMemberForListResponse {
    totalCount: number;
    items?: TemplateSecurityMemberForListResponse[] | undefined;
}

export class TemplateSecurityMemberForListResponse implements ITemplateSecurityMemberForListResponse {
    id!: number;
    template!: number;
    type!: SecurityMemberType;
    typeDesc?: string | undefined;
    member!: number;
    memberDesc?: string | undefined;
    level!: SecurityMemberLevel;
    levelDesc?: string | undefined;
    isExecutor!: boolean;
    isExecutorDesc?: string | undefined;

    constructor(data?: ITemplateSecurityMemberForListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.template = _data["template"];
            this.type = _data["type"];
            this.typeDesc = _data["typeDesc"];
            this.member = _data["member"];
            this.memberDesc = _data["memberDesc"];
            this.level = _data["level"];
            this.levelDesc = _data["levelDesc"];
            this.isExecutor = _data["isExecutor"];
            this.isExecutorDesc = _data["isExecutorDesc"];
        }
    }

    static fromJS(data: any): TemplateSecurityMemberForListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateSecurityMemberForListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["template"] = this.template;
        data["type"] = this.type;
        data["typeDesc"] = this.typeDesc;
        data["member"] = this.member;
        data["memberDesc"] = this.memberDesc;
        data["level"] = this.level;
        data["levelDesc"] = this.levelDesc;
        data["isExecutor"] = this.isExecutor;
        data["isExecutorDesc"] = this.isExecutorDesc;
        return data;
    }
}

export interface ITemplateSecurityMemberForListResponse {
    id: number;
    template: number;
    type: SecurityMemberType;
    typeDesc?: string | undefined;
    member: number;
    memberDesc?: string | undefined;
    level: SecurityMemberLevel;
    levelDesc?: string | undefined;
    isExecutor: boolean;
    isExecutorDesc?: string | undefined;
}

export class TemplateSecurityMemberGetListQuery extends PageListByDto implements ITemplateSecurityMemberGetListQuery {
    template!: number;
    type?: SecurityMemberType | undefined;
    level?: SecurityMemberLevel | undefined;

    constructor(data?: ITemplateSecurityMemberGetListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.template = _data["template"];
            this.type = _data["type"];
            this.level = _data["level"];
        }
    }

    static override fromJS(data: any): TemplateSecurityMemberGetListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateSecurityMemberGetListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template;
        data["type"] = this.type;
        data["level"] = this.level;
        super.toJSON(data);
        return data;
    }
}

export interface ITemplateSecurityMemberGetListQuery extends IPageListByDto {
    template: number;
    type?: SecurityMemberType | undefined;
    level?: SecurityMemberLevel | undefined;
}

export class TemplateSecurityMemberCreateCommand implements ITemplateSecurityMemberCreateCommand {
    template!: number;
    type!: SecurityMemberType;
    member!: number;
    level!: SecurityMemberLevel;
    isExecutor!: boolean;

    constructor(data?: ITemplateSecurityMemberCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.template = _data["template"];
            this.type = _data["type"];
            this.member = _data["member"];
            this.level = _data["level"];
            this.isExecutor = _data["isExecutor"];
        }
    }

    static fromJS(data: any): TemplateSecurityMemberCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateSecurityMemberCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template;
        data["type"] = this.type;
        data["member"] = this.member;
        data["level"] = this.level;
        data["isExecutor"] = this.isExecutor;
        return data;
    }
}

export interface ITemplateSecurityMemberCreateCommand {
    template: number;
    type: SecurityMemberType;
    member: number;
    level: SecurityMemberLevel;
    isExecutor: boolean;
}

export class TemplateSecurityMemberDeleteCommand implements ITemplateSecurityMemberDeleteCommand {
    template!: number;
    id!: number;
    type!: SecurityMemberType;
    level!: SecurityMemberLevel;

    constructor(data?: ITemplateSecurityMemberDeleteCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.template = _data["template"];
            this.id = _data["id"];
            this.type = _data["type"];
            this.level = _data["level"];
        }
    }

    static fromJS(data: any): TemplateSecurityMemberDeleteCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateSecurityMemberDeleteCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template;
        data["id"] = this.id;
        data["type"] = this.type;
        data["level"] = this.level;
        return data;
    }
}

export interface ITemplateSecurityMemberDeleteCommand {
    template: number;
    id: number;
    type: SecurityMemberType;
    level: SecurityMemberLevel;
}

export class TenantResponse implements ITenantResponse {
    id!: number;
    tenancyName?: string | undefined;
    name?: string | undefined;
    creationTime?: moment.Moment | undefined;
    isActive!: boolean;
    isDeleted!: boolean;

    constructor(data?: ITenantResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
        }
    }

    static fromJS(data: any): TenantResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TenantResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        return data;
    }
}

export interface ITenantResponse {
    id: number;
    tenancyName?: string | undefined;
    name?: string | undefined;
    creationTime?: moment.Moment | undefined;
    isActive: boolean;
    isDeleted: boolean;
}

export class TenantCreateCommand implements ITenantCreateCommand {
    tenancyName?: string | undefined;
    tenantName?: string | undefined;
    password?: string | undefined;
    passwordConfirm?: string | undefined;
    name?: string | undefined;
    lastName?: string | undefined;
    secondLastName?: string | undefined;
    emailAddress?: string | undefined;

    constructor(data?: ITenantCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.tenantName = _data["tenantName"];
            this.password = _data["password"];
            this.passwordConfirm = _data["passwordConfirm"];
            this.name = _data["name"];
            this.lastName = _data["lastName"];
            this.secondLastName = _data["secondLastName"];
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): TenantCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TenantCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["tenantName"] = this.tenantName;
        data["password"] = this.password;
        data["passwordConfirm"] = this.passwordConfirm;
        data["name"] = this.name;
        data["lastName"] = this.lastName;
        data["secondLastName"] = this.secondLastName;
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface ITenantCreateCommand {
    tenancyName?: string | undefined;
    tenantName?: string | undefined;
    password?: string | undefined;
    passwordConfirm?: string | undefined;
    name?: string | undefined;
    lastName?: string | undefined;
    secondLastName?: string | undefined;
    emailAddress?: string | undefined;
}

export class UpdateTenantCommand implements IUpdateTenantCommand {
    id!: number;
    tenancyName?: string | undefined;
    name?: string | undefined;
    isActive!: boolean;

    constructor(data?: IUpdateTenantCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateTenantCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateTenantCommand {
    id: number;
    tenancyName?: string | undefined;
    name?: string | undefined;
    isActive: boolean;
}

export class PagedResultDtoOfTenantListResponse implements IPagedResultDtoOfTenantListResponse {
    totalCount!: number;
    items?: TenantListResponse[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TenantListResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTenantListResponse {
    totalCount: number;
    items?: TenantListResponse[] | undefined;
}

export class TenantListResponse implements ITenantListResponse {
    id!: number;
    tenancyName?: string | undefined;
    name?: string | undefined;
    largeName?: string | undefined;
    creationTime?: moment.Moment | undefined;
    isActive!: boolean;
    isActiveDesc?: string | undefined;

    constructor(data?: ITenantListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.largeName = _data["largeName"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isActiveDesc = _data["isActiveDesc"];
        }
    }

    static fromJS(data: any): TenantListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TenantListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["largeName"] = this.largeName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isActiveDesc"] = this.isActiveDesc;
        return data;
    }
}

export interface ITenantListResponse {
    id: number;
    tenancyName?: string | undefined;
    name?: string | undefined;
    largeName?: string | undefined;
    creationTime?: moment.Moment | undefined;
    isActive: boolean;
    isActiveDesc?: string | undefined;
}

export class TenantGetListQuery extends PageListByDto implements ITenantGetListQuery {

    constructor(data?: ITenantGetListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): TenantGetListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new TenantGetListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ITenantGetListQuery extends IPageListByDto {
}

export class TenantGetListCompleterQuery implements ITenantGetListCompleterQuery {
    filter?: string | undefined;

    constructor(data?: ITenantGetListCompleterQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): TenantGetListCompleterQuery {
        data = typeof data === 'object' ? data : {};
        let result = new TenantGetListCompleterQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        return data;
    }
}

export interface ITenantGetListCompleterQuery {
    filter?: string | undefined;
}

export class TenantDeleteCommand implements ITenantDeleteCommand {
    id!: number;

    constructor(data?: ITenantDeleteCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantDeleteCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDeleteCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ITenantDeleteCommand {
    id: number;
}

export class TenantSettingsForEditResponse implements ITenantSettingsForEditResponse {
    passwordUseDefaultConfiguration!: boolean;
    passwordComplexity?: TenantSettingsPasswordComplexityResponse | undefined;
    passwordComplexityDefault?: TenantSettingsPasswordComplexityResponse | undefined;
    enablePasswordReuseValidation!: boolean;
    enablePasswordPeriod!: boolean;
    passwordValidDays!: number;
    enableUserBlocking!: boolean;
    failedAttemptsToBlockUser!: number;
    preventConcurrentSesions!: boolean;
    userBlockingDuration!: number;
    mailSMTPSenderDefault?: string | undefined;
    mailSMTPSenderDefaultDisplayName?: string | undefined;
    mailSMTPHost?: string | undefined;
    mailSMTPPort?: number | undefined;
    mailEnableSSL!: boolean;
    mailUseDefaultCredentials!: boolean;
    mailDomainName?: string | undefined;
    mailUserName?: string | undefined;
    mailUserPassword?: string | undefined;
    emailSendMethod!: EmailSendMethod;
    grpcEmail?: GrpcEmailResponse | undefined;

    constructor(data?: ITenantSettingsForEditResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.passwordUseDefaultConfiguration = _data["passwordUseDefaultConfiguration"];
            this.passwordComplexity = _data["passwordComplexity"] ? TenantSettingsPasswordComplexityResponse.fromJS(_data["passwordComplexity"]) : <any>undefined;
            this.passwordComplexityDefault = _data["passwordComplexityDefault"] ? TenantSettingsPasswordComplexityResponse.fromJS(_data["passwordComplexityDefault"]) : <any>undefined;
            this.enablePasswordReuseValidation = _data["enablePasswordReuseValidation"];
            this.enablePasswordPeriod = _data["enablePasswordPeriod"];
            this.passwordValidDays = _data["passwordValidDays"];
            this.enableUserBlocking = _data["enableUserBlocking"];
            this.failedAttemptsToBlockUser = _data["failedAttemptsToBlockUser"];
            this.preventConcurrentSesions = _data["preventConcurrentSesions"];
            this.userBlockingDuration = _data["userBlockingDuration"];
            this.mailSMTPSenderDefault = _data["mailSMTPSenderDefault"];
            this.mailSMTPSenderDefaultDisplayName = _data["mailSMTPSenderDefaultDisplayName"];
            this.mailSMTPHost = _data["mailSMTPHost"];
            this.mailSMTPPort = _data["mailSMTPPort"];
            this.mailEnableSSL = _data["mailEnableSSL"];
            this.mailUseDefaultCredentials = _data["mailUseDefaultCredentials"];
            this.mailDomainName = _data["mailDomainName"];
            this.mailUserName = _data["mailUserName"];
            this.mailUserPassword = _data["mailUserPassword"];
            this.emailSendMethod = _data["emailSendMethod"];
            this.grpcEmail = _data["grpcEmail"] ? GrpcEmailResponse.fromJS(_data["grpcEmail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantSettingsForEditResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsForEditResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["passwordUseDefaultConfiguration"] = this.passwordUseDefaultConfiguration;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["passwordComplexityDefault"] = this.passwordComplexityDefault ? this.passwordComplexityDefault.toJSON() : <any>undefined;
        data["enablePasswordReuseValidation"] = this.enablePasswordReuseValidation;
        data["enablePasswordPeriod"] = this.enablePasswordPeriod;
        data["passwordValidDays"] = this.passwordValidDays;
        data["enableUserBlocking"] = this.enableUserBlocking;
        data["failedAttemptsToBlockUser"] = this.failedAttemptsToBlockUser;
        data["preventConcurrentSesions"] = this.preventConcurrentSesions;
        data["userBlockingDuration"] = this.userBlockingDuration;
        data["mailSMTPSenderDefault"] = this.mailSMTPSenderDefault;
        data["mailSMTPSenderDefaultDisplayName"] = this.mailSMTPSenderDefaultDisplayName;
        data["mailSMTPHost"] = this.mailSMTPHost;
        data["mailSMTPPort"] = this.mailSMTPPort;
        data["mailEnableSSL"] = this.mailEnableSSL;
        data["mailUseDefaultCredentials"] = this.mailUseDefaultCredentials;
        data["mailDomainName"] = this.mailDomainName;
        data["mailUserName"] = this.mailUserName;
        data["mailUserPassword"] = this.mailUserPassword;
        data["emailSendMethod"] = this.emailSendMethod;
        data["grpcEmail"] = this.grpcEmail ? this.grpcEmail.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITenantSettingsForEditResponse {
    passwordUseDefaultConfiguration: boolean;
    passwordComplexity?: TenantSettingsPasswordComplexityResponse | undefined;
    passwordComplexityDefault?: TenantSettingsPasswordComplexityResponse | undefined;
    enablePasswordReuseValidation: boolean;
    enablePasswordPeriod: boolean;
    passwordValidDays: number;
    enableUserBlocking: boolean;
    failedAttemptsToBlockUser: number;
    preventConcurrentSesions: boolean;
    userBlockingDuration: number;
    mailSMTPSenderDefault?: string | undefined;
    mailSMTPSenderDefaultDisplayName?: string | undefined;
    mailSMTPHost?: string | undefined;
    mailSMTPPort?: number | undefined;
    mailEnableSSL: boolean;
    mailUseDefaultCredentials: boolean;
    mailDomainName?: string | undefined;
    mailUserName?: string | undefined;
    mailUserPassword?: string | undefined;
    emailSendMethod: EmailSendMethod;
    grpcEmail?: GrpcEmailResponse | undefined;
}

export class TenantSettingsPasswordComplexityResponse implements ITenantSettingsPasswordComplexityResponse {
    minimumLength!: number;
    maximumLength!: number;
    useNumbers!: boolean;
    useUppercase!: boolean;
    useLowercase!: boolean;
    usePunctuationSymbols!: boolean;

    constructor(data?: ITenantSettingsPasswordComplexityResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.minimumLength = _data["minimumLength"];
            this.maximumLength = _data["maximumLength"];
            this.useNumbers = _data["useNumbers"];
            this.useUppercase = _data["useUppercase"];
            this.useLowercase = _data["useLowercase"];
            this.usePunctuationSymbols = _data["usePunctuationSymbols"];
        }
    }

    static fromJS(data: any): TenantSettingsPasswordComplexityResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsPasswordComplexityResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minimumLength"] = this.minimumLength;
        data["maximumLength"] = this.maximumLength;
        data["useNumbers"] = this.useNumbers;
        data["useUppercase"] = this.useUppercase;
        data["useLowercase"] = this.useLowercase;
        data["usePunctuationSymbols"] = this.usePunctuationSymbols;
        return data;
    }
}

export interface ITenantSettingsPasswordComplexityResponse {
    minimumLength: number;
    maximumLength: number;
    useNumbers: boolean;
    useUppercase: boolean;
    useLowercase: boolean;
    usePunctuationSymbols: boolean;
}

export class GrpcEmailResponse implements IGrpcEmailResponse {
    sendConfiguration!: boolean;
    tenancyName?: string | undefined;
    userName?: string | undefined;
    password?: string | undefined;

    constructor(data?: IGrpcEmailResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sendConfiguration = _data["sendConfiguration"];
            this.tenancyName = _data["tenancyName"];
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): GrpcEmailResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GrpcEmailResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sendConfiguration"] = this.sendConfiguration;
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data;
    }
}

export interface IGrpcEmailResponse {
    sendConfiguration: boolean;
    tenancyName?: string | undefined;
    userName?: string | undefined;
    password?: string | undefined;
}

export class TenantSettingsGetForEditQuery implements ITenantSettingsGetForEditQuery {

    constructor(data?: ITenantSettingsGetForEditQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): TenantSettingsGetForEditQuery {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsGetForEditQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface ITenantSettingsGetForEditQuery {
}

export class TenantSettingsUpdateCommand implements ITenantSettingsUpdateCommand {
    passwordUseDefaultConfiguration!: boolean;
    passwordComplexity?: TenantSettingsPasswordComplexityCommand | undefined;
    enablePasswordReuseValidation!: boolean;
    enablePasswordPeriod!: boolean;
    passwordValidDays!: number;
    enableUserBlocking!: boolean;
    failedAttemptsToBlockUser!: number;
    userBlockingDuration!: number;
    preventConcurrentSesions!: boolean;
    mailSMTPSenderDefault?: string | undefined;
    mailSMTPSenderDefaultDisplayName?: string | undefined;
    mailSMTPHost?: string | undefined;
    mailSMTPPort?: number | undefined;
    mailEnableSSL!: boolean;
    mailUseDefaultCredentials!: boolean;
    mailDomainName?: string | undefined;
    mailUserName?: string | undefined;
    mailUserPassword?: string | undefined;
    grpcEmail?: GrpcEmailCommand | undefined;

    constructor(data?: ITenantSettingsUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.passwordUseDefaultConfiguration = _data["passwordUseDefaultConfiguration"];
            this.passwordComplexity = _data["passwordComplexity"] ? TenantSettingsPasswordComplexityCommand.fromJS(_data["passwordComplexity"]) : <any>undefined;
            this.enablePasswordReuseValidation = _data["enablePasswordReuseValidation"];
            this.enablePasswordPeriod = _data["enablePasswordPeriod"];
            this.passwordValidDays = _data["passwordValidDays"];
            this.enableUserBlocking = _data["enableUserBlocking"];
            this.failedAttemptsToBlockUser = _data["failedAttemptsToBlockUser"];
            this.userBlockingDuration = _data["userBlockingDuration"];
            this.preventConcurrentSesions = _data["preventConcurrentSesions"];
            this.mailSMTPSenderDefault = _data["mailSMTPSenderDefault"];
            this.mailSMTPSenderDefaultDisplayName = _data["mailSMTPSenderDefaultDisplayName"];
            this.mailSMTPHost = _data["mailSMTPHost"];
            this.mailSMTPPort = _data["mailSMTPPort"];
            this.mailEnableSSL = _data["mailEnableSSL"];
            this.mailUseDefaultCredentials = _data["mailUseDefaultCredentials"];
            this.mailDomainName = _data["mailDomainName"];
            this.mailUserName = _data["mailUserName"];
            this.mailUserPassword = _data["mailUserPassword"];
            this.grpcEmail = _data["grpcEmail"] ? GrpcEmailCommand.fromJS(_data["grpcEmail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantSettingsUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["passwordUseDefaultConfiguration"] = this.passwordUseDefaultConfiguration;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["enablePasswordReuseValidation"] = this.enablePasswordReuseValidation;
        data["enablePasswordPeriod"] = this.enablePasswordPeriod;
        data["passwordValidDays"] = this.passwordValidDays;
        data["enableUserBlocking"] = this.enableUserBlocking;
        data["failedAttemptsToBlockUser"] = this.failedAttemptsToBlockUser;
        data["userBlockingDuration"] = this.userBlockingDuration;
        data["preventConcurrentSesions"] = this.preventConcurrentSesions;
        data["mailSMTPSenderDefault"] = this.mailSMTPSenderDefault;
        data["mailSMTPSenderDefaultDisplayName"] = this.mailSMTPSenderDefaultDisplayName;
        data["mailSMTPHost"] = this.mailSMTPHost;
        data["mailSMTPPort"] = this.mailSMTPPort;
        data["mailEnableSSL"] = this.mailEnableSSL;
        data["mailUseDefaultCredentials"] = this.mailUseDefaultCredentials;
        data["mailDomainName"] = this.mailDomainName;
        data["mailUserName"] = this.mailUserName;
        data["mailUserPassword"] = this.mailUserPassword;
        data["grpcEmail"] = this.grpcEmail ? this.grpcEmail.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITenantSettingsUpdateCommand {
    passwordUseDefaultConfiguration: boolean;
    passwordComplexity?: TenantSettingsPasswordComplexityCommand | undefined;
    enablePasswordReuseValidation: boolean;
    enablePasswordPeriod: boolean;
    passwordValidDays: number;
    enableUserBlocking: boolean;
    failedAttemptsToBlockUser: number;
    userBlockingDuration: number;
    preventConcurrentSesions: boolean;
    mailSMTPSenderDefault?: string | undefined;
    mailSMTPSenderDefaultDisplayName?: string | undefined;
    mailSMTPHost?: string | undefined;
    mailSMTPPort?: number | undefined;
    mailEnableSSL: boolean;
    mailUseDefaultCredentials: boolean;
    mailDomainName?: string | undefined;
    mailUserName?: string | undefined;
    mailUserPassword?: string | undefined;
    grpcEmail?: GrpcEmailCommand | undefined;
}

export class TenantSettingsPasswordComplexityCommand implements ITenantSettingsPasswordComplexityCommand {
    minimumLength!: number;
    maximumLength!: number;
    useNumbers!: boolean;
    useUppercase!: boolean;
    useLowercase!: boolean;
    usePunctuationSymbols!: boolean;

    constructor(data?: ITenantSettingsPasswordComplexityCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.minimumLength = _data["minimumLength"];
            this.maximumLength = _data["maximumLength"];
            this.useNumbers = _data["useNumbers"];
            this.useUppercase = _data["useUppercase"];
            this.useLowercase = _data["useLowercase"];
            this.usePunctuationSymbols = _data["usePunctuationSymbols"];
        }
    }

    static fromJS(data: any): TenantSettingsPasswordComplexityCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsPasswordComplexityCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minimumLength"] = this.minimumLength;
        data["maximumLength"] = this.maximumLength;
        data["useNumbers"] = this.useNumbers;
        data["useUppercase"] = this.useUppercase;
        data["useLowercase"] = this.useLowercase;
        data["usePunctuationSymbols"] = this.usePunctuationSymbols;
        return data;
    }
}

export interface ITenantSettingsPasswordComplexityCommand {
    minimumLength: number;
    maximumLength: number;
    useNumbers: boolean;
    useUppercase: boolean;
    useLowercase: boolean;
    usePunctuationSymbols: boolean;
}

export class GrpcEmailCommand implements IGrpcEmailCommand {
    tenancyName?: string | undefined;
    userName?: string | undefined;
    password?: string | undefined;

    constructor(data?: IGrpcEmailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): GrpcEmailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new GrpcEmailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data;
    }
}

export interface IGrpcEmailCommand {
    tenancyName?: string | undefined;
    userName?: string | undefined;
    password?: string | undefined;
}

export class TenantSettingsSendTestEmailCommand implements ITenantSettingsSendTestEmailCommand {
    emailAddress?: string | undefined;

    constructor(data?: ITenantSettingsSendTestEmailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): TenantSettingsSendTestEmailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsSendTestEmailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface ITenantSettingsSendTestEmailCommand {
    emailAddress?: string | undefined;
}

export class UserConfigurationResponse implements IUserConfigurationResponse {
    localization?: UserLocalizationConfigResponse | undefined;
    permission?: UserPermissionConfigResponse | undefined;
    settingsClient?: { [key: string]: string; } | undefined;
    templates?: TemplateResponse[] | undefined;
    catalogsCustom?: CatalogCustomResponse[] | undefined;
    multiTenancyConfig?: MultiTenancyConfigResponse | undefined;
    passwordComplexity?: PasswordComplexityDto | undefined;

    constructor(data?: IUserConfigurationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.localization = _data["localization"] ? UserLocalizationConfigResponse.fromJS(_data["localization"]) : <any>undefined;
            this.permission = _data["permission"] ? UserPermissionConfigResponse.fromJS(_data["permission"]) : <any>undefined;
            if (_data["settingsClient"]) {
                this.settingsClient = {} as any;
                for (let key in _data["settingsClient"]) {
                    if (_data["settingsClient"].hasOwnProperty(key))
                        (<any>this.settingsClient)![key] = _data["settingsClient"][key];
                }
            }
            if (Array.isArray(_data["templates"])) {
                this.templates = [] as any;
                for (let item of _data["templates"])
                    this.templates!.push(TemplateResponse.fromJS(item));
            }
            if (Array.isArray(_data["catalogsCustom"])) {
                this.catalogsCustom = [] as any;
                for (let item of _data["catalogsCustom"])
                    this.catalogsCustom!.push(CatalogCustomResponse.fromJS(item));
            }
            this.multiTenancyConfig = _data["multiTenancyConfig"] ? MultiTenancyConfigResponse.fromJS(_data["multiTenancyConfig"]) : <any>undefined;
            this.passwordComplexity = _data["passwordComplexity"] ? PasswordComplexityDto.fromJS(_data["passwordComplexity"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserConfigurationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserConfigurationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["localization"] = this.localization ? this.localization.toJSON() : <any>undefined;
        data["permission"] = this.permission ? this.permission.toJSON() : <any>undefined;
        if (this.settingsClient) {
            data["settingsClient"] = {};
            for (let key in this.settingsClient) {
                if (this.settingsClient.hasOwnProperty(key))
                    (<any>data["settingsClient"])[key] = (<any>this.settingsClient)[key];
            }
        }
        if (Array.isArray(this.templates)) {
            data["templates"] = [];
            for (let item of this.templates)
                data["templates"].push(item.toJSON());
        }
        if (Array.isArray(this.catalogsCustom)) {
            data["catalogsCustom"] = [];
            for (let item of this.catalogsCustom)
                data["catalogsCustom"].push(item.toJSON());
        }
        data["multiTenancyConfig"] = this.multiTenancyConfig ? this.multiTenancyConfig.toJSON() : <any>undefined;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserConfigurationResponse {
    localization?: UserLocalizationConfigResponse | undefined;
    permission?: UserPermissionConfigResponse | undefined;
    settingsClient?: { [key: string]: string; } | undefined;
    templates?: TemplateResponse[] | undefined;
    catalogsCustom?: CatalogCustomResponse[] | undefined;
    multiTenancyConfig?: MultiTenancyConfigResponse | undefined;
    passwordComplexity?: PasswordComplexityDto | undefined;
}

export class UserLocalizationConfigResponse implements IUserLocalizationConfigResponse {
    defaultLanguage?: LanguageInfoResponse | undefined;
    currentLanguage?: LanguageInfoResponse | undefined;
    values?: { [key: string]: string; } | undefined;

    constructor(data?: IUserLocalizationConfigResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultLanguage = _data["defaultLanguage"] ? LanguageInfoResponse.fromJS(_data["defaultLanguage"]) : <any>undefined;
            this.currentLanguage = _data["currentLanguage"] ? LanguageInfoResponse.fromJS(_data["currentLanguage"]) : <any>undefined;
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        (<any>this.values)![key] = _data["values"][key];
                }
            }
        }
    }

    static fromJS(data: any): UserLocalizationConfigResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserLocalizationConfigResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultLanguage"] = this.defaultLanguage ? this.defaultLanguage.toJSON() : <any>undefined;
        data["currentLanguage"] = this.currentLanguage ? this.currentLanguage.toJSON() : <any>undefined;
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    (<any>data["values"])[key] = (<any>this.values)[key];
            }
        }
        return data;
    }
}

export interface IUserLocalizationConfigResponse {
    defaultLanguage?: LanguageInfoResponse | undefined;
    currentLanguage?: LanguageInfoResponse | undefined;
    values?: { [key: string]: string; } | undefined;
}

export class LanguageInfoResponse implements ILanguageInfoResponse {
    name?: string | undefined;
    displayName?: string | undefined;

    constructor(data?: ILanguageInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): LanguageInfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageInfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ILanguageInfoResponse {
    name?: string | undefined;
    displayName?: string | undefined;
}

export class UserPermissionConfigResponse implements IUserPermissionConfigResponse {
    values?: { [key: string]: boolean; } | undefined;

    constructor(data?: IUserPermissionConfigResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        (<any>this.values)![key] = _data["values"][key];
                }
            }
        }
    }

    static fromJS(data: any): UserPermissionConfigResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserPermissionConfigResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    (<any>data["values"])[key] = (<any>this.values)[key];
            }
        }
        return data;
    }
}

export interface IUserPermissionConfigResponse {
    values?: { [key: string]: boolean; } | undefined;
}

export class MultiTenancyConfigResponse implements IMultiTenancyConfigResponse {
    enabled!: boolean;
    tenancyNameDefault?: string | undefined;

    constructor(data?: IMultiTenancyConfigResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enabled = _data["enabled"];
            this.tenancyNameDefault = _data["tenancyNameDefault"];
        }
    }

    static fromJS(data: any): MultiTenancyConfigResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MultiTenancyConfigResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enabled"] = this.enabled;
        data["tenancyNameDefault"] = this.tenancyNameDefault;
        return data;
    }
}

export interface IMultiTenancyConfigResponse {
    enabled: boolean;
    tenancyNameDefault?: string | undefined;
}

export class PasswordComplexityDto implements IPasswordComplexityDto {
    minimumLength!: number;
    maximumLength!: number;
    useNumbers!: boolean;
    useUppercase!: boolean;
    useLowercase!: boolean;
    usePunctuationSymbols!: boolean;

    constructor(data?: IPasswordComplexityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.minimumLength = _data["minimumLength"];
            this.maximumLength = _data["maximumLength"];
            this.useNumbers = _data["useNumbers"];
            this.useUppercase = _data["useUppercase"];
            this.useLowercase = _data["useLowercase"];
            this.usePunctuationSymbols = _data["usePunctuationSymbols"];
        }
    }

    static fromJS(data: any): PasswordComplexityDto {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordComplexityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minimumLength"] = this.minimumLength;
        data["maximumLength"] = this.maximumLength;
        data["useNumbers"] = this.useNumbers;
        data["useUppercase"] = this.useUppercase;
        data["useLowercase"] = this.useLowercase;
        data["usePunctuationSymbols"] = this.usePunctuationSymbols;
        return data;
    }
}

export interface IPasswordComplexityDto {
    minimumLength: number;
    maximumLength: number;
    useNumbers: boolean;
    useUppercase: boolean;
    useLowercase: boolean;
    usePunctuationSymbols: boolean;
}

export class UserConfigurationGetAllQuery implements IUserConfigurationGetAllQuery {
    clientType?: string | undefined;

    constructor(data?: IUserConfigurationGetAllQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientType = _data["clientType"];
        }
    }

    static fromJS(data: any): UserConfigurationGetAllQuery {
        data = typeof data === 'object' ? data : {};
        let result = new UserConfigurationGetAllQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientType"] = this.clientType;
        return data;
    }
}

export interface IUserConfigurationGetAllQuery {
    clientType?: string | undefined;
}

export class PagedResultDtoOfUserListResponse implements IPagedResultDtoOfUserListResponse {
    totalCount!: number;
    items?: UserListResponse[] | undefined;

    constructor(data?: IPagedResultDtoOfUserListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserListResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfUserListResponse {
    totalCount: number;
    items?: UserListResponse[] | undefined;
}

export class UserListResponse implements IUserListResponse {
    id!: number;
    login?: string | undefined;
    name?: string | undefined;
    lastName?: string | undefined;
    secondLastName?: string | undefined;
    emailAddress?: string | undefined;
    isEmailConfirmed?: boolean | undefined;
    userLocked?: boolean | undefined;
    userLockedDesc?: string | undefined;
    isActive?: boolean | undefined;
    isActiveDesc?: string | undefined;
    creationTime?: moment.Moment | undefined;
    fullName?: string | undefined;

    constructor(data?: IUserListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.login = _data["login"];
            this.name = _data["name"];
            this.lastName = _data["lastName"];
            this.secondLastName = _data["secondLastName"];
            this.emailAddress = _data["emailAddress"];
            this.isEmailConfirmed = _data["isEmailConfirmed"];
            this.userLocked = _data["userLocked"];
            this.userLockedDesc = _data["userLockedDesc"];
            this.isActive = _data["isActive"];
            this.isActiveDesc = _data["isActiveDesc"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): UserListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["login"] = this.login;
        data["name"] = this.name;
        data["lastName"] = this.lastName;
        data["secondLastName"] = this.secondLastName;
        data["emailAddress"] = this.emailAddress;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["userLocked"] = this.userLocked;
        data["userLockedDesc"] = this.userLockedDesc;
        data["isActive"] = this.isActive;
        data["isActiveDesc"] = this.isActiveDesc;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["fullName"] = this.fullName;
        return data;
    }
}

export interface IUserListResponse {
    id: number;
    login?: string | undefined;
    name?: string | undefined;
    lastName?: string | undefined;
    secondLastName?: string | undefined;
    emailAddress?: string | undefined;
    isEmailConfirmed?: boolean | undefined;
    userLocked?: boolean | undefined;
    userLockedDesc?: string | undefined;
    isActive?: boolean | undefined;
    isActiveDesc?: string | undefined;
    creationTime?: moment.Moment | undefined;
    fullName?: string | undefined;
}

export class UserGetListQuery extends PageListByDto implements IUserGetListQuery {
    tenant?: number | undefined;

    constructor(data?: IUserGetListQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.tenant = _data["tenant"];
        }
    }

    static override fromJS(data: any): UserGetListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new UserGetListQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenant"] = this.tenant;
        super.toJSON(data);
        return data;
    }
}

export interface IUserGetListQuery extends IPageListByDto {
    tenant?: number | undefined;
}

export class UserCreateCommand implements IUserCreateCommand {
    userName?: string | undefined;
    password?: string | undefined;
    passwordRepeat?: string | undefined;
    name?: string | undefined;
    lastName?: string | undefined;
    secondLastName?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    isActive?: boolean | undefined;
    setRandomPassword?: boolean | undefined;
    shouldChangePasswordOnNextLogin?: boolean | undefined;
    assignedRoleNames?: string[] | undefined;

    constructor(data?: IUserCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.passwordRepeat = _data["passwordRepeat"];
            this.name = _data["name"];
            this.lastName = _data["lastName"];
            this.secondLastName = _data["secondLastName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.isActive = _data["isActive"];
            this.setRandomPassword = _data["setRandomPassword"];
            this.shouldChangePasswordOnNextLogin = _data["shouldChangePasswordOnNextLogin"];
            if (Array.isArray(_data["assignedRoleNames"])) {
                this.assignedRoleNames = [] as any;
                for (let item of _data["assignedRoleNames"])
                    this.assignedRoleNames!.push(item);
            }
        }
    }

    static fromJS(data: any): UserCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UserCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["passwordRepeat"] = this.passwordRepeat;
        data["name"] = this.name;
        data["lastName"] = this.lastName;
        data["secondLastName"] = this.secondLastName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isActive"] = this.isActive;
        data["setRandomPassword"] = this.setRandomPassword;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        if (Array.isArray(this.assignedRoleNames)) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        return data;
    }
}

export interface IUserCreateCommand {
    userName?: string | undefined;
    password?: string | undefined;
    passwordRepeat?: string | undefined;
    name?: string | undefined;
    lastName?: string | undefined;
    secondLastName?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    isActive?: boolean | undefined;
    setRandomPassword?: boolean | undefined;
    shouldChangePasswordOnNextLogin?: boolean | undefined;
    assignedRoleNames?: string[] | undefined;
}

export class UserUpdateCommand implements IUserUpdateCommand {
    id!: number;
    userName?: string | undefined;
    password?: string | undefined;
    passwordRepeat?: string | undefined;
    name?: string | undefined;
    lastName?: string | undefined;
    secondLastName?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    isActive?: boolean | undefined;
    setRandomPassword?: boolean | undefined;
    shouldChangePasswordOnNextLogin?: boolean | undefined;
    assignedRoleNames?: string[] | undefined;

    constructor(data?: IUserUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.passwordRepeat = _data["passwordRepeat"];
            this.name = _data["name"];
            this.lastName = _data["lastName"];
            this.secondLastName = _data["secondLastName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.isActive = _data["isActive"];
            this.setRandomPassword = _data["setRandomPassword"];
            this.shouldChangePasswordOnNextLogin = _data["shouldChangePasswordOnNextLogin"];
            if (Array.isArray(_data["assignedRoleNames"])) {
                this.assignedRoleNames = [] as any;
                for (let item of _data["assignedRoleNames"])
                    this.assignedRoleNames!.push(item);
            }
        }
    }

    static fromJS(data: any): UserUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UserUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["passwordRepeat"] = this.passwordRepeat;
        data["name"] = this.name;
        data["lastName"] = this.lastName;
        data["secondLastName"] = this.secondLastName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isActive"] = this.isActive;
        data["setRandomPassword"] = this.setRandomPassword;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        if (Array.isArray(this.assignedRoleNames)) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        return data;
    }
}

export interface IUserUpdateCommand {
    id: number;
    userName?: string | undefined;
    password?: string | undefined;
    passwordRepeat?: string | undefined;
    name?: string | undefined;
    lastName?: string | undefined;
    secondLastName?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    isActive?: boolean | undefined;
    setRandomPassword?: boolean | undefined;
    shouldChangePasswordOnNextLogin?: boolean | undefined;
    assignedRoleNames?: string[] | undefined;
}

export class UserForEditResponse implements IUserForEditResponse {
    id!: number;
    userName?: string | undefined;
    name?: string | undefined;
    lastName?: string | undefined;
    secondLastName?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    isActive?: boolean | undefined;
    setRandomPassword?: boolean | undefined;
    shouldChangePasswordOnNextLogin?: boolean | undefined;
    sendActivationEmail?: boolean | undefined;
    language?: number | undefined;
    preferences?: { [key: string]: string; } | undefined;
    languageCombo?: ComboboxItemDto[] | undefined;
    rolList?: UserRolResponse[] | undefined;

    constructor(data?: IUserForEditResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.lastName = _data["lastName"];
            this.secondLastName = _data["secondLastName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.isActive = _data["isActive"];
            this.setRandomPassword = _data["setRandomPassword"];
            this.shouldChangePasswordOnNextLogin = _data["shouldChangePasswordOnNextLogin"];
            this.sendActivationEmail = _data["sendActivationEmail"];
            this.language = _data["language"];
            if (_data["preferences"]) {
                this.preferences = {} as any;
                for (let key in _data["preferences"]) {
                    if (_data["preferences"].hasOwnProperty(key))
                        (<any>this.preferences)![key] = _data["preferences"][key];
                }
            }
            if (Array.isArray(_data["languageCombo"])) {
                this.languageCombo = [] as any;
                for (let item of _data["languageCombo"])
                    this.languageCombo!.push(ComboboxItemDto.fromJS(item));
            }
            if (Array.isArray(_data["rolList"])) {
                this.rolList = [] as any;
                for (let item of _data["rolList"])
                    this.rolList!.push(UserRolResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserForEditResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserForEditResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["lastName"] = this.lastName;
        data["secondLastName"] = this.secondLastName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isActive"] = this.isActive;
        data["setRandomPassword"] = this.setRandomPassword;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["language"] = this.language;
        if (this.preferences) {
            data["preferences"] = {};
            for (let key in this.preferences) {
                if (this.preferences.hasOwnProperty(key))
                    (<any>data["preferences"])[key] = (<any>this.preferences)[key];
            }
        }
        if (Array.isArray(this.languageCombo)) {
            data["languageCombo"] = [];
            for (let item of this.languageCombo)
                data["languageCombo"].push(item.toJSON());
        }
        if (Array.isArray(this.rolList)) {
            data["rolList"] = [];
            for (let item of this.rolList)
                data["rolList"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserForEditResponse {
    id: number;
    userName?: string | undefined;
    name?: string | undefined;
    lastName?: string | undefined;
    secondLastName?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    isActive?: boolean | undefined;
    setRandomPassword?: boolean | undefined;
    shouldChangePasswordOnNextLogin?: boolean | undefined;
    sendActivationEmail?: boolean | undefined;
    language?: number | undefined;
    preferences?: { [key: string]: string; } | undefined;
    languageCombo?: ComboboxItemDto[] | undefined;
    rolList?: UserRolResponse[] | undefined;
}

export class UserRolResponse implements IUserRolResponse {
    roleId?: number | undefined;
    roleName?: string | undefined;
    roleDisplayName?: string | undefined;

    constructor(data?: IUserRolResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            this.roleDisplayName = _data["roleDisplayName"];
        }
    }

    static fromJS(data: any): UserRolResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserRolResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleDisplayName"] = this.roleDisplayName;
        return data;
    }
}

export interface IUserRolResponse {
    roleId?: number | undefined;
    roleName?: string | undefined;
    roleDisplayName?: string | undefined;
}

export class UserGetForEditQuery implements IUserGetForEditQuery {
    id!: number;

    constructor(data?: IUserGetForEditQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserGetForEditQuery {
        data = typeof data === 'object' ? data : {};
        let result = new UserGetForEditQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IUserGetForEditQuery {
    id: number;
}

export class UserProfileQuery implements IUserProfileQuery {
    id!: number;
    clientType?: string | undefined;

    constructor(data?: IUserProfileQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientType = _data["clientType"];
        }
    }

    static fromJS(data: any): UserProfileQuery {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfileQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientType"] = this.clientType;
        return data;
    }
}

export interface IUserProfileQuery {
    id: number;
    clientType?: string | undefined;
}

export class UserUpdateProfileCommand implements IUserUpdateProfileCommand {
    name?: string | undefined;
    lastName?: string | undefined;
    secondLastName?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    pictureName?: string | undefined;
    currentPassword?: string | undefined;
    newPassword?: string | undefined;
    newPasswordConfirm?: string | undefined;
    language?: number | undefined;
    clientType?: string | undefined;
    preferences?: { [key: string]: string; } | undefined;

    constructor(data?: IUserUpdateProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.lastName = _data["lastName"];
            this.secondLastName = _data["secondLastName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.pictureName = _data["pictureName"];
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
            this.newPasswordConfirm = _data["newPasswordConfirm"];
            this.language = _data["language"];
            this.clientType = _data["clientType"];
            if (_data["preferences"]) {
                this.preferences = {} as any;
                for (let key in _data["preferences"]) {
                    if (_data["preferences"].hasOwnProperty(key))
                        (<any>this.preferences)![key] = _data["preferences"][key];
                }
            }
        }
    }

    static fromJS(data: any): UserUpdateProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UserUpdateProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["lastName"] = this.lastName;
        data["secondLastName"] = this.secondLastName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["pictureName"] = this.pictureName;
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        data["newPasswordConfirm"] = this.newPasswordConfirm;
        data["language"] = this.language;
        data["clientType"] = this.clientType;
        if (this.preferences) {
            data["preferences"] = {};
            for (let key in this.preferences) {
                if (this.preferences.hasOwnProperty(key))
                    (<any>data["preferences"])[key] = (<any>this.preferences)[key];
            }
        }
        return data;
    }
}

export interface IUserUpdateProfileCommand {
    name?: string | undefined;
    lastName?: string | undefined;
    secondLastName?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    pictureName?: string | undefined;
    currentPassword?: string | undefined;
    newPassword?: string | undefined;
    newPasswordConfirm?: string | undefined;
    language?: number | undefined;
    clientType?: string | undefined;
    preferences?: { [key: string]: string; } | undefined;
}

export class UserDeleteCommand implements IUserDeleteCommand {
    id!: number;

    constructor(data?: IUserDeleteCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserDeleteCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UserDeleteCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IUserDeleteCommand {
    id: number;
}

export class WebLogGetLastestResponse implements IWebLogGetLastestResponse {
    latesWebLogLines?: string[] | undefined;

    constructor(data?: IWebLogGetLastestResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["latesWebLogLines"])) {
                this.latesWebLogLines = [] as any;
                for (let item of _data["latesWebLogLines"])
                    this.latesWebLogLines!.push(item);
            }
        }
    }

    static fromJS(data: any): WebLogGetLastestResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WebLogGetLastestResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.latesWebLogLines)) {
            data["latesWebLogLines"] = [];
            for (let item of this.latesWebLogLines)
                data["latesWebLogLines"].push(item);
        }
        return data;
    }
}

export interface IWebLogGetLastestResponse {
    latesWebLogLines?: string[] | undefined;
}

export class WebLogGetLastestQuery implements IWebLogGetLastestQuery {

    constructor(data?: IWebLogGetLastestQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): WebLogGetLastestQuery {
        data = typeof data === 'object' ? data : {};
        let result = new WebLogGetLastestQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IWebLogGetLastestQuery {
}

export class WebLogDownloadZipResponse implements IWebLogDownloadZipResponse {
    fileName?: string | undefined;
    fileType?: string | undefined;
    fileToken?: string | undefined;

    constructor(data?: IWebLogDownloadZipResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fileToken = _data["fileToken"];
        }
    }

    static fromJS(data: any): WebLogDownloadZipResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WebLogDownloadZipResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data;
    }
}

export interface IWebLogDownloadZipResponse {
    fileName?: string | undefined;
    fileType?: string | undefined;
    fileToken?: string | undefined;
}

export class WebLogDownloadZipQuery implements IWebLogDownloadZipQuery {

    constructor(data?: IWebLogDownloadZipQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): WebLogDownloadZipQuery {
        data = typeof data === 'object' ? data : {};
        let result = new WebLogDownloadZipQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IWebLogDownloadZipQuery {
}

export class Data implements IData {

    constructor(data?: IData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Data {
        data = typeof data === 'object' ? data : {};
        let result = new Data();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IData {
}

export class Data2 implements IData2 {

    constructor(data?: IData2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Data2 {
        data = typeof data === 'object' ? data : {};
        let result = new Data2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IData2 {
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}